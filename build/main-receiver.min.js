!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in p||(p[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==v.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=p[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(v.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=p[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return x[e]||(x[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=p[s],v=x[s];v?l=v.exports:c&&!c.declarative?l=c.esModule:c?(d(c),v=c.module,l=v.exports):l=f(s),v&&v.importers?(v.importers.push(t),t.dependencies.push(v)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=p[e];if(t)t.declarative?c(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=f(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=p[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){if(r===e)return r;var t={};if("object"==typeof r||"function"==typeof r)if(g){var n;for(var o in r)(n=Object.getOwnPropertyDescriptor(r,o))&&h(t,o,n)}else{var a=r&&r.hasOwnProperty;for(var o in r)(!a||r.hasOwnProperty(o))&&(t[o]=r[o])}return t["default"]=r,h(t,"__useDefault",{value:!0}),t}function c(r,t){var n=p[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==v.call(t,u)&&(p[u]?c(u,t):f(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function f(e){if(D[e])return D[e];if("@node/"==e.substr(0,6))return y(e.substr(6));var r=p[e];if(!r)throw"Module "+e+" not present.";return a(e),c(e,[]),p[e]=void 0,r.declarative&&h(r.module.exports,"__esModule",{value:!0}),D[e]=r.declarative?r.module.exports:r.esModule}var p={},v=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},g=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(m){g=!1}var h;!function(){try{Object.defineProperty({},"a",{})&&(h=Object.defineProperty)}catch(e){h=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var x={},y="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,D={"@empty":{}};return function(e,n,o){return function(a){a(function(a){for(var u={_nodeRequire:y,register:r,registerDynamic:t,get:f,set:function(e,r){D[e]=r},newModule:function(e){return e}},d=0;d<n.length;d++)(function(e,r){r&&r.__esModule?D[e]=r:D[e]=s(r)})(n[d],arguments[d]);o(u);var i=f(e[0]);if(e.length>1)for(var d=1;d<e.length;d++)f(e[d]);return i.__useDefault?i["default"]:i})}}}("undefined"!=typeof self?self:global)

(["1"], [], function($__System) {

!function(e){function n(e,n){for(var t=e.split(".");t.length;)n=n[t.shift()];return n}function t(n){if(Object.keys)Object.keys(e).forEach(n);else for(var t in e)f.call(e,t)&&n(t)}function r(n){t(function(t){if(-1==a.call(l,t)){try{var r=e[t]}catch(o){l.push(t)}n(t,r)}})}var o,i=$__System,f=Object.prototype.hasOwnProperty,a=Array.prototype.indexOf||function(e){for(var n=0,t=this.length;t>n;n++)if(this[n]===e)return n;return-1},l=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(t,i,f){var a=e.define;e.define=void 0,e.exports=void 0,e.module&&e.module.exports&&(e.module=void 0);var l;if(f){l={};for(var u in f)l[u]=e[u],e[u]=f[u]}return i||(o={},r(function(e,n){o[e]=n})),function(){var t;if(i)t=n(i,e);else{var f,u,s={};r(function(e,n){o[e]!==n&&"undefined"!=typeof n&&(s[e]=n,"undefined"!=typeof f?u||f===n||(u=!0):f=n)}),t=u?s:f}if(l)for(var c in l)e[c]=l[c];return e.define=a,t}}}))}("undefined"!=typeof self?self:global);
!function(){var t=$__System;if("undefined"!=typeof window&&"undefined"!=typeof document&&window.location)var s=location.protocol+"//"+location.hostname+(location.port?":"+location.port:"");t.set("@@cjs-helpers",t.newModule({getPathVars:function(t){var n,o=t.lastIndexOf("!");n=-1!=o?t.substr(0,o):t;var e=n.split("/");return e.pop(),e=e.join("/"),"file:///"==n.substr(0,8)?(n=n.substr(7),e=e.substr(7),isWindows&&(n=n.substr(1),e=e.substr(1))):s&&n.substr(0,s.length)===s&&(n=n.substr(s.length),e=e.substr(s.length)),{filename:n,dirname:e}}}))}();
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(s),i=(r[1].split(",")[n]||"require").replace(p,""),t=c[i]||(c[i]=new RegExp(u+i+a,"g"));t.lastIndex=0;for(var o,f=[];o=t.exec(e);)f.push(o[2]||o[3]);return f}function r(e,n,i,t){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var f=o.get(e);return f.__useDefault?f["default"]:f}throw new TypeError("Invalid require")}for(var l=[],u=0;u<e.length;u++)l.push(o["import"](e[u],t));Promise.all(l).then(function(e){n&&n.apply(null,e)},i)}function i(i,t,l){"string"!=typeof i&&(l=t,t=i,i=null),t instanceof Array||(l=t,t=["require","exports","module"].splice(0,l.length)),"function"!=typeof l&&(l=function(e){return function(){return e}}(l)),void 0===t[t.length-1]&&t.pop();var u,a,s;-1!=(u=f.call(t,"require"))&&(t.splice(u,1),i||(t=t.concat(n(l.toString(),u)))),-1!=(a=f.call(t,"exports"))&&t.splice(a,1),-1!=(s=f.call(t,"module"))&&t.splice(s,1);var p={name:i,deps:t,execute:function(n,i,f){for(var p=[],c=0;c<t.length;c++)p.push(n(t[c]));f.uri=f.id,f.config=function(){},-1!=s&&p.splice(s,0,f),-1!=a&&p.splice(a,0,i),-1!=u&&p.splice(u,0,function(e,i,t){return"string"==typeof e&&"function"!=typeof i?n(e):r.call(o,e,i,t,f.id)});var d=l.apply(-1==a?e:i,p);return"undefined"==typeof d&&f&&(d=f.exports),"undefined"!=typeof d?d:void 0}};if(i)d.anonDefine||d.isBundle?(d.anonDefine&&d.anonDefine.name&&o.registerDynamic(d.anonDefine.name,d.anonDefine.deps,!1,d.anonDefine.execute),d.anonDefine=null):d.anonDefine=p,d.isBundle=!0,o.registerDynamic(i,p.deps,!1,p.execute);else{if(d.anonDefine)throw new TypeError("Multiple defines for anonymous module");d.anonDefine=p}}function t(n){d.anonDefine=null,d.isBundle=!1;var r=e.module,t=e.exports,o=e.define;return e.module=void 0,e.exports=void 0,e.define=i,function(){e.define=o,e.module=r,e.exports=t}}var o=$__System,f=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,u="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",a="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",s=/\(([^\)]*)\)/,p=/^\s+|\s+$/g,c={};i.amd={};var d={isBundle:!1,anonDefine:null};o.set("@@amd-helpers",o.newModule({createDefine:t,require:r,define:i,lastModule:d})),o.amdDefine=i,o.amdRequire=r}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3", ["2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('2');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5", ["4"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('4');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7", ["6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8", ["3", "5", "7"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var base64 = $__require('3');
  var ieee754 = $__require('5');
  var isArray = $__require('7');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte,
            thirdByte,
            fourthByte,
            tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9", ["8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a", ["9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('buffer') : $__require('9');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b", ["a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c", ["b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(Buffer) {
    (function() {
      var cache = {};
      var ctx = null,
          usingWebAudio = true,
          noAudio = false;
      try {
        if (typeof AudioContext !== 'undefined') {
          ctx = new AudioContext();
        } else if (typeof webkitAudioContext !== 'undefined') {
          ctx = new webkitAudioContext();
        } else {
          usingWebAudio = false;
        }
      } catch (e) {
        usingWebAudio = false;
      }
      if (!usingWebAudio) {
        if (typeof Audio !== 'undefined') {
          try {
            new Audio();
          } catch (e) {
            noAudio = true;
          }
        } else {
          noAudio = true;
        }
      }
      if (usingWebAudio) {
        var masterGain = (typeof ctx.createGain === 'undefined') ? ctx.createGainNode() : ctx.createGain();
        masterGain.gain.value = 1;
        masterGain.connect(ctx.destination);
      }
      var HowlerGlobal = function(codecs) {
        this._volume = 1;
        this._muted = false;
        this.usingWebAudio = usingWebAudio;
        this.ctx = ctx;
        this.noAudio = noAudio;
        this._howls = [];
        this._codecs = codecs;
        this.iOSAutoEnable = true;
      };
      HowlerGlobal.prototype = {
        volume: function(vol) {
          var self = this;
          vol = parseFloat(vol);
          if (vol >= 0 && vol <= 1) {
            self._volume = vol;
            if (usingWebAudio) {
              masterGain.gain.value = vol;
            }
            for (var key in self._howls) {
              if (self._howls.hasOwnProperty(key) && self._howls[key]._webAudio === false) {
                for (var i = 0; i < self._howls[key]._audioNode.length; i++) {
                  self._howls[key]._audioNode[i].volume = self._howls[key]._volume * self._volume;
                }
              }
            }
            return self;
          }
          return (usingWebAudio) ? masterGain.gain.value : self._volume;
        },
        mute: function() {
          this._setMuted(true);
          return this;
        },
        unmute: function() {
          this._setMuted(false);
          return this;
        },
        _setMuted: function(muted) {
          var self = this;
          self._muted = muted;
          if (usingWebAudio) {
            masterGain.gain.value = muted ? 0 : self._volume;
          }
          for (var key in self._howls) {
            if (self._howls.hasOwnProperty(key) && self._howls[key]._webAudio === false) {
              for (var i = 0; i < self._howls[key]._audioNode.length; i++) {
                self._howls[key]._audioNode[i].muted = muted;
              }
            }
          }
        },
        codecs: function(ext) {
          return this._codecs[ext];
        },
        _enableiOSAudio: function() {
          var self = this;
          if (ctx && (self._iOSEnabled || !/iPhone|iPad|iPod/i.test(navigator.userAgent))) {
            return;
          }
          self._iOSEnabled = false;
          var unlock = function() {
            var buffer = ctx.createBuffer(1, 1, 22050);
            var source = ctx.createBufferSource();
            source.buffer = buffer;
            source.connect(ctx.destination);
            if (typeof source.start === 'undefined') {
              source.noteOn(0);
            } else {
              source.start(0);
            }
            setTimeout(function() {
              if ((source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE)) {
                self._iOSEnabled = true;
                self.iOSAutoEnable = false;
                window.removeEventListener('touchend', unlock, false);
              }
            }, 0);
          };
          window.addEventListener('touchend', unlock, false);
          return self;
        }
      };
      var audioTest = null;
      var codecs = {};
      if (!noAudio) {
        audioTest = new Audio();
        codecs = {
          mp3: !!audioTest.canPlayType('audio/mpeg;').replace(/^no$/, ''),
          opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
          ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
          wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
          aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
          m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
          mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
          weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')
        };
      }
      var Howler = new HowlerGlobal(codecs);
      var Howl = function(o) {
        var self = this;
        self._autoplay = o.autoplay || false;
        self._buffer = o.buffer || false;
        self._duration = o.duration || 0;
        self._format = o.format || null;
        self._loop = o.loop || false;
        self._loaded = false;
        self._sprite = o.sprite || {};
        self._src = o.src || '';
        self._pos3d = o.pos3d || [0, 0, -0.5];
        self._volume = o.volume !== undefined ? o.volume : 1;
        self._urls = o.urls || [];
        self._rate = o.rate || 1;
        self._model = o.model || null;
        self._onload = [o.onload || function() {}];
        self._onloaderror = [o.onloaderror || function() {}];
        self._onend = [o.onend || function() {}];
        self._onpause = [o.onpause || function() {}];
        self._onplay = [o.onplay || function() {}];
        self._onendTimer = [];
        self._webAudio = usingWebAudio && !self._buffer;
        self._audioNode = [];
        if (self._webAudio) {
          self._setupAudioNode();
        }
        if (typeof ctx !== 'undefined' && ctx && Howler.iOSAutoEnable) {
          Howler._enableiOSAudio();
        }
        Howler._howls.push(self);
        self.load();
      };
      Howl.prototype = {
        load: function() {
          var self = this,
              url = null;
          if (noAudio) {
            self.on('loaderror', new Error('No audio support.'));
            return;
          }
          for (var i = 0; i < self._urls.length; i++) {
            var ext,
                urlItem;
            if (self._format) {
              ext = self._format;
            } else {
              urlItem = self._urls[i];
              ext = /^data:audio\/([^;,]+);/i.exec(urlItem);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(urlItem.split('?', 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              } else {
                self.on('loaderror', new Error('Could not extract format from passed URLs, please add format parameter.'));
                return;
              }
            }
            if (codecs[ext]) {
              url = self._urls[i];
              break;
            }
          }
          if (!url) {
            self.on('loaderror', new Error('No codec support for selected audio sources.'));
            return;
          }
          self._src = url;
          if (self._webAudio) {
            loadBuffer(self, url);
          } else {
            var newNode = new Audio();
            newNode.addEventListener('error', function() {
              if (newNode.error && newNode.error.code === 4) {
                HowlerGlobal.noAudio = true;
              }
              self.on('loaderror', {type: newNode.error ? newNode.error.code : 0});
            }, false);
            self._audioNode.push(newNode);
            newNode.src = url;
            newNode._pos = 0;
            newNode.preload = 'auto';
            newNode.volume = (Howler._muted) ? 0 : self._volume * Howler.volume();
            var listener = function() {
              self._duration = Math.ceil(newNode.duration * 10) / 10;
              if (Object.getOwnPropertyNames(self._sprite).length === 0) {
                self._sprite = {_default: [0, self._duration * 1000]};
              }
              if (!self._loaded) {
                self._loaded = true;
                self.on('load');
              }
              if (self._autoplay) {
                self.play();
              }
              newNode.removeEventListener('canplaythrough', listener, false);
            };
            newNode.addEventListener('canplaythrough', listener, false);
            newNode.load();
          }
          return self;
        },
        urls: function(urls) {
          var self = this;
          if (urls) {
            self.stop();
            self._urls = (typeof urls === 'string') ? [urls] : urls;
            self._loaded = false;
            self.load();
            return self;
          } else {
            return self._urls;
          }
        },
        play: function(sprite, callback) {
          var self = this;
          if (typeof sprite === 'function') {
            callback = sprite;
          }
          if (!sprite || typeof sprite === 'function') {
            sprite = '_default';
          }
          if (!self._loaded) {
            self.on('load', function() {
              self.play(sprite, callback);
            });
            return self;
          }
          if (!self._sprite[sprite]) {
            if (typeof callback === 'function')
              callback();
            return self;
          }
          self._inactiveNode(function(node) {
            node._sprite = sprite;
            var pos = (node._pos > 0) ? node._pos : self._sprite[sprite][0] / 1000;
            var duration = 0;
            if (self._webAudio) {
              duration = self._sprite[sprite][1] / 1000 - node._pos;
              if (node._pos > 0) {
                pos = self._sprite[sprite][0] / 1000 + pos;
              }
            } else {
              duration = self._sprite[sprite][1] / 1000 - (pos - self._sprite[sprite][0] / 1000);
            }
            var loop = !!(self._loop || self._sprite[sprite][2]);
            var soundId = (typeof callback === 'string') ? callback : Math.round(Date.now() * Math.random()) + '',
                timerId;
            (function() {
              var data = {
                id: soundId,
                sprite: sprite,
                loop: loop
              };
              timerId = setTimeout(function() {
                if (!self._webAudio && loop) {
                  self.stop(data.id).play(sprite, data.id);
                }
                if (self._webAudio && !loop) {
                  self._nodeById(data.id).paused = true;
                  self._nodeById(data.id)._pos = 0;
                  self._clearEndTimer(data.id);
                }
                if (!self._webAudio && !loop) {
                  self.stop(data.id);
                }
                self.on('end', soundId);
              }, (duration / self._rate) * 1000);
              self._onendTimer.push({
                timer: timerId,
                id: data.id
              });
            })();
            if (self._webAudio) {
              var loopStart = self._sprite[sprite][0] / 1000,
                  loopEnd = self._sprite[sprite][1] / 1000;
              node.id = soundId;
              node.paused = false;
              refreshBuffer(self, [loop, loopStart, loopEnd], soundId);
              self._playStart = ctx.currentTime;
              node.gain.value = self._volume;
              if (typeof node.bufferSource.start === 'undefined') {
                loop ? node.bufferSource.noteGrainOn(0, pos, 86400) : node.bufferSource.noteGrainOn(0, pos, duration);
              } else {
                loop ? node.bufferSource.start(0, pos, 86400) : node.bufferSource.start(0, pos, duration);
              }
            } else {
              if (node.readyState === 4 || !node.readyState && navigator.isCocoonJS) {
                node.readyState = 4;
                node.id = soundId;
                node.currentTime = pos;
                node.muted = Howler._muted || node.muted;
                node.volume = self._volume * Howler.volume();
                setTimeout(function() {
                  node.play();
                }, 0);
              } else {
                self._clearEndTimer(soundId);
                (function() {
                  var sound = self,
                      playSprite = sprite,
                      fn = callback,
                      newNode = node;
                  var listener = function() {
                    sound.play(playSprite, fn);
                    newNode.removeEventListener('canplaythrough', listener, false);
                  };
                  newNode.addEventListener('canplaythrough', listener, false);
                })();
                return self;
              }
            }
            self.on('play');
            if (typeof callback === 'function')
              callback(soundId);
            return self;
          });
          return self;
        },
        pause: function(id) {
          var self = this;
          if (!self._loaded) {
            self.on('play', function() {
              self.pause(id);
            });
            return self;
          }
          self._clearEndTimer(id);
          var activeNode = (id) ? self._nodeById(id) : self._activeNode();
          if (activeNode) {
            activeNode._pos = self.pos(null, id);
            if (self._webAudio) {
              if (!activeNode.bufferSource || activeNode.paused) {
                return self;
              }
              activeNode.paused = true;
              if (typeof activeNode.bufferSource.stop === 'undefined') {
                activeNode.bufferSource.noteOff(0);
              } else {
                activeNode.bufferSource.stop(0);
              }
            } else {
              activeNode.pause();
            }
          }
          self.on('pause');
          return self;
        },
        stop: function(id) {
          var self = this;
          if (!self._loaded) {
            self.on('play', function() {
              self.stop(id);
            });
            return self;
          }
          self._clearEndTimer(id);
          var activeNode = (id) ? self._nodeById(id) : self._activeNode();
          if (activeNode) {
            activeNode._pos = 0;
            if (self._webAudio) {
              if (!activeNode.bufferSource || activeNode.paused) {
                return self;
              }
              activeNode.paused = true;
              if (typeof activeNode.bufferSource.stop === 'undefined') {
                activeNode.bufferSource.noteOff(0);
              } else {
                activeNode.bufferSource.stop(0);
              }
            } else if (!isNaN(activeNode.duration)) {
              activeNode.pause();
              activeNode.currentTime = 0;
            }
          }
          return self;
        },
        mute: function(id) {
          var self = this;
          if (!self._loaded) {
            self.on('play', function() {
              self.mute(id);
            });
            return self;
          }
          var activeNode = (id) ? self._nodeById(id) : self._activeNode();
          if (activeNode) {
            if (self._webAudio) {
              activeNode.gain.value = 0;
            } else {
              activeNode.muted = true;
            }
          }
          return self;
        },
        unmute: function(id) {
          var self = this;
          if (!self._loaded) {
            self.on('play', function() {
              self.unmute(id);
            });
            return self;
          }
          var activeNode = (id) ? self._nodeById(id) : self._activeNode();
          if (activeNode) {
            if (self._webAudio) {
              activeNode.gain.value = self._volume;
            } else {
              activeNode.muted = false;
            }
          }
          return self;
        },
        volume: function(vol, id) {
          var self = this;
          vol = parseFloat(vol);
          if (vol >= 0 && vol <= 1) {
            self._volume = vol;
            if (!self._loaded) {
              self.on('play', function() {
                self.volume(vol, id);
              });
              return self;
            }
            var activeNode = (id) ? self._nodeById(id) : self._activeNode();
            if (activeNode) {
              if (self._webAudio) {
                activeNode.gain.value = vol;
              } else {
                activeNode.volume = vol * Howler.volume();
              }
            }
            return self;
          } else {
            return self._volume;
          }
        },
        loop: function(loop) {
          var self = this;
          if (typeof loop === 'boolean') {
            self._loop = loop;
            return self;
          } else {
            return self._loop;
          }
        },
        sprite: function(sprite) {
          var self = this;
          if (typeof sprite === 'object') {
            self._sprite = sprite;
            return self;
          } else {
            return self._sprite;
          }
        },
        pos: function(pos, id) {
          var self = this;
          if (!self._loaded) {
            self.on('load', function() {
              self.pos(pos);
            });
            return typeof pos === 'number' ? self : self._pos || 0;
          }
          pos = parseFloat(pos);
          var activeNode = (id) ? self._nodeById(id) : self._activeNode();
          if (activeNode) {
            if (pos >= 0) {
              self.pause(id);
              activeNode._pos = pos;
              self.play(activeNode._sprite, id);
              return self;
            } else {
              return self._webAudio ? activeNode._pos + (ctx.currentTime - self._playStart) : activeNode.currentTime;
            }
          } else if (pos >= 0) {
            return self;
          } else {
            for (var i = 0; i < self._audioNode.length; i++) {
              if (self._audioNode[i].paused && self._audioNode[i].readyState === 4) {
                return (self._webAudio) ? self._audioNode[i]._pos : self._audioNode[i].currentTime;
              }
            }
          }
        },
        pos3d: function(x, y, z, id) {
          var self = this;
          y = (typeof y === 'undefined' || !y) ? 0 : y;
          z = (typeof z === 'undefined' || !z) ? -0.5 : z;
          if (!self._loaded) {
            self.on('play', function() {
              self.pos3d(x, y, z, id);
            });
            return self;
          }
          if (x >= 0 || x < 0) {
            if (self._webAudio) {
              var activeNode = (id) ? self._nodeById(id) : self._activeNode();
              if (activeNode) {
                self._pos3d = [x, y, z];
                activeNode.panner.setPosition(x, y, z);
                activeNode.panner.panningModel = self._model || 'HRTF';
              }
            }
          } else {
            return self._pos3d;
          }
          return self;
        },
        fade: function(from, to, len, callback, id) {
          var self = this,
              diff = Math.abs(from - to),
              dir = from > to ? 'down' : 'up',
              steps = diff / 0.01,
              stepTime = len / steps;
          if (!self._loaded) {
            self.on('load', function() {
              self.fade(from, to, len, callback, id);
            });
            return self;
          }
          self.volume(from, id);
          for (var i = 1; i <= steps; i++) {
            (function() {
              var change = self._volume + (dir === 'up' ? 0.01 : -0.01) * i,
                  vol = Math.round(1000 * change) / 1000,
                  toVol = to;
              setTimeout(function() {
                self.volume(vol, id);
                if (vol === toVol) {
                  if (callback)
                    callback();
                }
              }, stepTime * i);
            })();
          }
        },
        fadeIn: function(to, len, callback) {
          return this.volume(0).play().fade(0, to, len, callback);
        },
        fadeOut: function(to, len, callback, id) {
          var self = this;
          return self.fade(self._volume, to, len, function() {
            if (callback)
              callback();
            self.pause(id);
            self.on('end');
          }, id);
        },
        _nodeById: function(id) {
          var self = this,
              node = self._audioNode[0];
          for (var i = 0; i < self._audioNode.length; i++) {
            if (self._audioNode[i].id === id) {
              node = self._audioNode[i];
              break;
            }
          }
          return node;
        },
        _activeNode: function() {
          var self = this,
              node = null;
          for (var i = 0; i < self._audioNode.length; i++) {
            if (!self._audioNode[i].paused) {
              node = self._audioNode[i];
              break;
            }
          }
          self._drainPool();
          return node;
        },
        _inactiveNode: function(callback) {
          var self = this,
              node = null;
          for (var i = 0; i < self._audioNode.length; i++) {
            if (self._audioNode[i].paused && self._audioNode[i].readyState === 4) {
              callback(self._audioNode[i]);
              node = true;
              break;
            }
          }
          self._drainPool();
          if (node) {
            return;
          }
          var newNode;
          if (self._webAudio) {
            newNode = self._setupAudioNode();
            callback(newNode);
          } else {
            self.load();
            newNode = self._audioNode[self._audioNode.length - 1];
            var listenerEvent = navigator.isCocoonJS ? 'canplaythrough' : 'loadedmetadata';
            var listener = function() {
              newNode.removeEventListener(listenerEvent, listener, false);
              callback(newNode);
            };
            newNode.addEventListener(listenerEvent, listener, false);
          }
        },
        _drainPool: function() {
          var self = this,
              inactive = 0,
              i;
          for (i = 0; i < self._audioNode.length; i++) {
            if (self._audioNode[i].paused) {
              inactive++;
            }
          }
          for (i = self._audioNode.length - 1; i >= 0; i--) {
            if (inactive <= 5) {
              break;
            }
            if (self._audioNode[i].paused) {
              if (self._webAudio) {
                self._audioNode[i].disconnect(0);
              }
              inactive--;
              self._audioNode.splice(i, 1);
            }
          }
        },
        _clearEndTimer: function(soundId) {
          var self = this,
              index = -1;
          for (var i = 0; i < self._onendTimer.length; i++) {
            if (self._onendTimer[i].id === soundId) {
              index = i;
              break;
            }
          }
          var timer = self._onendTimer[index];
          if (timer) {
            clearTimeout(timer.timer);
            self._onendTimer.splice(index, 1);
          }
        },
        _setupAudioNode: function() {
          var self = this,
              node = self._audioNode,
              index = self._audioNode.length;
          node[index] = (typeof ctx.createGain === 'undefined') ? ctx.createGainNode() : ctx.createGain();
          node[index].gain.value = self._volume;
          node[index].paused = true;
          node[index]._pos = 0;
          node[index].readyState = 4;
          node[index].connect(masterGain);
          node[index].panner = ctx.createPanner();
          node[index].panner.panningModel = self._model || 'equalpower';
          node[index].panner.setPosition(self._pos3d[0], self._pos3d[1], self._pos3d[2]);
          node[index].panner.connect(node[index]);
          return node[index];
        },
        on: function(event, fn) {
          var self = this,
              events = self['_on' + event];
          if (typeof fn === 'function') {
            events.push(fn);
          } else {
            for (var i = 0; i < events.length; i++) {
              if (fn) {
                events[i].call(self, fn);
              } else {
                events[i].call(self);
              }
            }
          }
          return self;
        },
        off: function(event, fn) {
          var self = this,
              events = self['_on' + event];
          if (fn) {
            for (var i = 0; i < events.length; i++) {
              if (fn === events[i]) {
                events.splice(i, 1);
                break;
              }
            }
          } else {
            self['_on' + event] = [];
          }
          return self;
        },
        unload: function() {
          var self = this;
          var nodes = self._audioNode;
          for (var i = 0; i < self._audioNode.length; i++) {
            if (!nodes[i].paused) {
              self.stop(nodes[i].id);
              self.on('end', nodes[i].id);
            }
            if (!self._webAudio) {
              nodes[i].src = '';
            } else {
              nodes[i].disconnect(0);
            }
          }
          for (i = 0; i < self._onendTimer.length; i++) {
            clearTimeout(self._onendTimer[i].timer);
          }
          var index = Howler._howls.indexOf(self);
          if (index !== null && index >= 0) {
            Howler._howls.splice(index, 1);
          }
          delete cache[self._src];
          self = null;
        }
      };
      if (usingWebAudio) {
        var loadBuffer = function(obj, url) {
          if (url in cache) {
            obj._duration = cache[url].duration;
            loadSound(obj);
            return;
          }
          if (/^data:[^;]+;base64,/.test(url)) {
            var data = atob(url.split(',')[1]);
            var dataView = new Uint8Array(data.length);
            for (var i = 0; i < data.length; ++i) {
              dataView[i] = data.charCodeAt(i);
            }
            decodeAudioData(dataView.buffer, obj, url);
          } else {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'arraybuffer';
            xhr.onload = function() {
              decodeAudioData(xhr.response, obj, url);
            };
            xhr.onerror = function() {
              if (obj._webAudio) {
                obj._buffer = true;
                obj._webAudio = false;
                obj._audioNode = [];
                delete obj._gainNode;
                delete cache[url];
                obj.load();
              }
            };
            try {
              xhr.send();
            } catch (e) {
              xhr.onerror();
            }
          }
        };
        var decodeAudioData = function(arraybuffer, obj, url) {
          ctx.decodeAudioData(arraybuffer, function(buffer) {
            if (buffer) {
              cache[url] = buffer;
              loadSound(obj, buffer);
            }
          }, function(err) {
            obj.on('loaderror', err);
          });
        };
        var loadSound = function(obj, buffer) {
          obj._duration = (buffer) ? buffer.duration : obj._duration;
          if (Object.getOwnPropertyNames(obj._sprite).length === 0) {
            obj._sprite = {_default: [0, obj._duration * 1000]};
          }
          if (!obj._loaded) {
            obj._loaded = true;
            obj.on('load');
          }
          if (obj._autoplay) {
            obj.play();
          }
        };
        var refreshBuffer = function(obj, loop, id) {
          var node = obj._nodeById(id);
          node.bufferSource = ctx.createBufferSource();
          node.bufferSource.buffer = cache[obj._src];
          node.bufferSource.connect(node.panner);
          node.bufferSource.loop = loop[0];
          if (loop[0]) {
            node.bufferSource.loopStart = loop[1];
            node.bufferSource.loopEnd = loop[1] + loop[2];
          }
          node.bufferSource.playbackRate.value = obj._rate;
        };
      }
      if (typeof define === 'function' && define.amd) {
        define(function() {
          return {
            Howler: Howler,
            Howl: Howl
          };
        });
      }
      if (typeof exports !== 'undefined') {
        exports.Howler = Howler;
        exports.Howl = Howl;
      }
      if (typeof window !== 'undefined') {
        window.Howler = Howler;
        window.Howl = Howl;
      }
    })();
  })($__require('b').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d", ["c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e", ["f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window;
    (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
      "use strict";
      _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
        var _slice = function(a) {
          var b = [],
              l = a.length,
              i;
          for (i = 0; i !== l; b.push(a[i++]))
            ;
          return b;
        },
            _applyCycle = function(vars, targets, i) {
              var alt = vars.cycle,
                  p,
                  val;
              for (p in alt) {
                val = alt[p];
                vars[p] = (typeof(val) === "function") ? val.call(targets[i], i) : val[i % val.length];
              }
              delete vars.cycle;
            },
            TweenMax = function(target, duration, vars) {
              TweenLite.call(this, target, duration, vars);
              this._cycle = 0;
              this._yoyo = (this.vars.yoyo === true);
              this._repeat = this.vars.repeat || 0;
              this._repeatDelay = this.vars.repeatDelay || 0;
              this._dirty = true;
              this.render = TweenMax.prototype.render;
            },
            _tinyNum = 0.0000000001,
            TweenLiteInternals = TweenLite._internals,
            _isSelector = TweenLiteInternals.isSelector,
            _isArray = TweenLiteInternals.isArray,
            p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
            _blankArray = [];
        TweenMax.version = "1.18.2";
        p.constructor = TweenMax;
        p.kill()._gc = false;
        TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
        TweenMax.getTweensOf = TweenLite.getTweensOf;
        TweenMax.lagSmoothing = TweenLite.lagSmoothing;
        TweenMax.ticker = TweenLite.ticker;
        TweenMax.render = TweenLite.render;
        p.invalidate = function() {
          this._yoyo = (this.vars.yoyo === true);
          this._repeat = this.vars.repeat || 0;
          this._repeatDelay = this.vars.repeatDelay || 0;
          this._uncache(true);
          return TweenLite.prototype.invalidate.call(this);
        };
        p.updateTo = function(vars, resetDuration) {
          var curRatio = this.ratio,
              immediate = this.vars.immediateRender || vars.immediateRender,
              p;
          if (resetDuration && this._startTime < this._timeline._time) {
            this._startTime = this._timeline._time;
            this._uncache(false);
            if (this._gc) {
              this._enabled(true, false);
            } else {
              this._timeline.insert(this, this._startTime - this._delay);
            }
          }
          for (p in vars) {
            this.vars[p] = vars[p];
          }
          if (this._initted || immediate) {
            if (resetDuration) {
              this._initted = false;
              if (immediate) {
                this.render(0, true, true);
              }
            } else {
              if (this._gc) {
                this._enabled(true, false);
              }
              if (this._notifyPluginsOfEnabled && this._firstPT) {
                TweenLite._onPluginEvent("_onDisable", this);
              }
              if (this._time / this._duration > 0.998) {
                var prevTime = this._totalTime;
                this.render(0, true, false);
                this._initted = false;
                this.render(prevTime, true, false);
              } else {
                this._initted = false;
                this._init();
                if (this._time > 0 || immediate) {
                  var inv = 1 / (1 - curRatio),
                      pt = this._firstPT,
                      endValue;
                  while (pt) {
                    endValue = pt.s + pt.c;
                    pt.c *= inv;
                    pt.s = endValue - pt.c;
                    pt = pt._next;
                  }
                }
              }
            }
          }
          return this;
        };
        p.render = function(time, suppressEvents, force) {
          if (!this._initted)
            if (this._duration === 0 && this.vars.repeat) {
              this.invalidate();
            }
          var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
              prevTime = this._time,
              prevTotalTime = this._totalTime,
              prevCycle = this._cycle,
              duration = this._duration,
              prevRawPrevTime = this._rawPrevTime,
              isComplete,
              callback,
              pt,
              cycleDuration,
              r,
              type,
              pow,
              rawPrevTime;
          if (time >= totalDur - 0.0000001) {
            this._totalTime = totalDur;
            this._cycle = this._repeat;
            if (this._yoyo && (this._cycle & 1) !== 0) {
              this._time = 0;
              this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
            } else {
              this._time = duration;
              this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
            }
            if (!this._reversed) {
              isComplete = true;
              callback = "onComplete";
              force = (force || this._timeline.autoRemoveChildren);
            }
            if (duration === 0)
              if (this._initted || !this.vars.lazy || force) {
                if (this._startTime === this._timeline._duration) {
                  time = 0;
                }
                if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause"))
                  if (prevRawPrevTime !== time) {
                    force = true;
                    if (prevRawPrevTime > _tinyNum) {
                      callback = "onReverseComplete";
                    }
                  }
                this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
              }
          } else if (time < 0.0000001) {
            this._totalTime = this._time = this._cycle = 0;
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
            if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
              callback = "onReverseComplete";
              isComplete = this._reversed;
            }
            if (time < 0) {
              this._active = false;
              if (duration === 0)
                if (this._initted || !this.vars.lazy || force) {
                  if (prevRawPrevTime >= 0) {
                    force = true;
                  }
                  this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
                }
            }
            if (!this._initted) {
              force = true;
            }
          } else {
            this._totalTime = this._time = time;
            if (this._repeat !== 0) {
              cycleDuration = duration + this._repeatDelay;
              this._cycle = (this._totalTime / cycleDuration) >> 0;
              if (this._cycle !== 0)
                if (this._cycle === this._totalTime / cycleDuration) {
                  this._cycle--;
                }
              this._time = this._totalTime - (this._cycle * cycleDuration);
              if (this._yoyo)
                if ((this._cycle & 1) !== 0) {
                  this._time = duration - this._time;
                }
              if (this._time > duration) {
                this._time = duration;
              } else if (this._time < 0) {
                this._time = 0;
              }
            }
            if (this._easeType) {
              r = this._time / duration;
              type = this._easeType;
              pow = this._easePower;
              if (type === 1 || (type === 3 && r >= 0.5)) {
                r = 1 - r;
              }
              if (type === 3) {
                r *= 2;
              }
              if (pow === 1) {
                r *= r;
              } else if (pow === 2) {
                r *= r * r;
              } else if (pow === 3) {
                r *= r * r * r;
              } else if (pow === 4) {
                r *= r * r * r * r;
              }
              if (type === 1) {
                this.ratio = 1 - r;
              } else if (type === 2) {
                this.ratio = r;
              } else if (this._time / duration < 0.5) {
                this.ratio = r / 2;
              } else {
                this.ratio = 1 - (r / 2);
              }
            } else {
              this.ratio = this._ease.getRatio(this._time / duration);
            }
          }
          if (prevTime === this._time && !force && prevCycle === this._cycle) {
            if (prevTotalTime !== this._totalTime)
              if (this._onUpdate)
                if (!suppressEvents) {
                  this._callback("onUpdate");
                }
            return;
          } else if (!this._initted) {
            this._init();
            if (!this._initted || this._gc) {
              return;
            } else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
              this._time = prevTime;
              this._totalTime = prevTotalTime;
              this._rawPrevTime = prevRawPrevTime;
              this._cycle = prevCycle;
              TweenLiteInternals.lazyTweens.push(this);
              this._lazy = [time, suppressEvents];
              return;
            }
            if (this._time && !isComplete) {
              this.ratio = this._ease.getRatio(this._time / duration);
            } else if (isComplete && this._ease._calcEnd) {
              this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
            }
          }
          if (this._lazy !== false) {
            this._lazy = false;
          }
          if (!this._active)
            if (!this._paused && this._time !== prevTime && time >= 0) {
              this._active = true;
            }
          if (prevTotalTime === 0) {
            if (this._initted === 2 && time > 0) {
              this._init();
            }
            if (this._startAt) {
              if (time >= 0) {
                this._startAt.render(time, suppressEvents, force);
              } else if (!callback) {
                callback = "_dummyGS";
              }
            }
            if (this.vars.onStart)
              if (this._totalTime !== 0 || duration === 0)
                if (!suppressEvents) {
                  this._callback("onStart");
                }
          }
          pt = this._firstPT;
          while (pt) {
            if (pt.f) {
              pt.t[pt.p](pt.c * this.ratio + pt.s);
            } else {
              pt.t[pt.p] = pt.c * this.ratio + pt.s;
            }
            pt = pt._next;
          }
          if (this._onUpdate) {
            if (time < 0)
              if (this._startAt && this._startTime) {
                this._startAt.render(time, suppressEvents, force);
              }
            if (!suppressEvents)
              if (this._totalTime !== prevTotalTime || isComplete) {
                this._callback("onUpdate");
              }
          }
          if (this._cycle !== prevCycle)
            if (!suppressEvents)
              if (!this._gc)
                if (this.vars.onRepeat) {
                  this._callback("onRepeat");
                }
          if (callback)
            if (!this._gc || force) {
              if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
                this._startAt.render(time, suppressEvents, force);
              }
              if (isComplete) {
                if (this._timeline.autoRemoveChildren) {
                  this._enabled(false, false);
                }
                this._active = false;
              }
              if (!suppressEvents && this.vars[callback]) {
                this._callback(callback);
              }
              if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                this._rawPrevTime = 0;
              }
            }
        };
        TweenMax.to = function(target, duration, vars) {
          return new TweenMax(target, duration, vars);
        };
        TweenMax.from = function(target, duration, vars) {
          vars.runBackwards = true;
          vars.immediateRender = (vars.immediateRender != false);
          return new TweenMax(target, duration, vars);
        };
        TweenMax.fromTo = function(target, duration, fromVars, toVars) {
          toVars.startAt = fromVars;
          toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
          return new TweenMax(target, duration, toVars);
        };
        TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
          stagger = stagger || 0;
          var delay = 0,
              a = [],
              finalComplete = function() {
                if (vars.onComplete) {
                  vars.onComplete.apply(vars.onCompleteScope || this, arguments);
                }
                onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
              },
              cycle = vars.cycle,
              fromCycle = (vars.startAt && vars.startAt.cycle),
              l,
              copy,
              i,
              p;
          if (!_isArray(targets)) {
            if (typeof(targets) === "string") {
              targets = TweenLite.selector(targets) || targets;
            }
            if (_isSelector(targets)) {
              targets = _slice(targets);
            }
          }
          targets = targets || [];
          if (stagger < 0) {
            targets = _slice(targets);
            targets.reverse();
            stagger *= -1;
          }
          l = targets.length - 1;
          for (i = 0; i <= l; i++) {
            copy = {};
            for (p in vars) {
              copy[p] = vars[p];
            }
            if (cycle) {
              _applyCycle(copy, targets, i);
            }
            if (fromCycle) {
              fromCycle = copy.startAt = {};
              for (p in vars.startAt) {
                fromCycle[p] = vars.startAt[p];
              }
              _applyCycle(copy.startAt, targets, i);
            }
            copy.delay = delay + (copy.delay || 0);
            if (i === l && onCompleteAll) {
              copy.onComplete = finalComplete;
            }
            a[i] = new TweenMax(targets[i], duration, copy);
            delay += stagger;
          }
          return a;
        };
        TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
          vars.runBackwards = true;
          vars.immediateRender = (vars.immediateRender != false);
          return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
          toVars.startAt = fromVars;
          toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
          return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
          return new TweenMax(callback, 0, {
            delay: delay,
            onComplete: callback,
            onCompleteParams: params,
            callbackScope: scope,
            onReverseComplete: callback,
            onReverseCompleteParams: params,
            immediateRender: false,
            useFrames: useFrames,
            overwrite: 0
          });
        };
        TweenMax.set = function(target, vars) {
          return new TweenMax(target, 0, vars);
        };
        TweenMax.isTweening = function(target) {
          return (TweenLite.getTweensOf(target, true).length > 0);
        };
        var _getChildrenOf = function(timeline, includeTimelines) {
          var a = [],
              cnt = 0,
              tween = timeline._first;
          while (tween) {
            if (tween instanceof TweenLite) {
              a[cnt++] = tween;
            } else {
              if (includeTimelines) {
                a[cnt++] = tween;
              }
              a = a.concat(_getChildrenOf(tween, includeTimelines));
              cnt = a.length;
            }
            tween = tween._next;
          }
          return a;
        },
            getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
              return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
            };
        TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
          if (tweens == null) {
            tweens = true;
          }
          if (delayedCalls == null) {
            delayedCalls = true;
          }
          var a = getAllTweens((timelines != false)),
              l = a.length,
              allTrue = (tweens && delayedCalls && timelines),
              isDC,
              tween,
              i;
          for (i = 0; i < l; i++) {
            tween = a[i];
            if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
              if (complete) {
                tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
              } else {
                tween._enabled(false, false);
              }
            }
          }
        };
        TweenMax.killChildTweensOf = function(parent, complete) {
          if (parent == null) {
            return;
          }
          var tl = TweenLiteInternals.tweenLookup,
              a,
              curParent,
              p,
              i,
              l;
          if (typeof(parent) === "string") {
            parent = TweenLite.selector(parent) || parent;
          }
          if (_isSelector(parent)) {
            parent = _slice(parent);
          }
          if (_isArray(parent)) {
            i = parent.length;
            while (--i > -1) {
              TweenMax.killChildTweensOf(parent[i], complete);
            }
            return;
          }
          a = [];
          for (p in tl) {
            curParent = tl[p].target.parentNode;
            while (curParent) {
              if (curParent === parent) {
                a = a.concat(tl[p].tweens);
              }
              curParent = curParent.parentNode;
            }
          }
          l = a.length;
          for (i = 0; i < l; i++) {
            if (complete) {
              a[i].totalTime(a[i].totalDuration());
            }
            a[i]._enabled(false, false);
          }
        };
        var _changePause = function(pause, tweens, delayedCalls, timelines) {
          tweens = (tweens !== false);
          delayedCalls = (delayedCalls !== false);
          timelines = (timelines !== false);
          var a = getAllTweens(timelines),
              allTrue = (tweens && delayedCalls && timelines),
              i = a.length,
              isDC,
              tween;
          while (--i > -1) {
            tween = a[i];
            if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
              tween.paused(pause);
            }
          }
        };
        TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
          _changePause(true, tweens, delayedCalls, timelines);
        };
        TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
          _changePause(false, tweens, delayedCalls, timelines);
        };
        TweenMax.globalTimeScale = function(value) {
          var tl = Animation._rootTimeline,
              t = TweenLite.ticker.time;
          if (!arguments.length) {
            return tl._timeScale;
          }
          value = value || _tinyNum;
          tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
          tl = Animation._rootFramesTimeline;
          t = TweenLite.ticker.frame;
          tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
          tl._timeScale = Animation._rootTimeline._timeScale = value;
          return value;
        };
        p.progress = function(value) {
          return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), false);
        };
        p.totalProgress = function(value) {
          return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, false);
        };
        p.time = function(value, suppressEvents) {
          if (!arguments.length) {
            return this._time;
          }
          if (this._dirty) {
            this.totalDuration();
          }
          if (value > this._duration) {
            value = this._duration;
          }
          if (this._yoyo && (this._cycle & 1) !== 0) {
            value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
          } else if (this._repeat !== 0) {
            value += this._cycle * (this._duration + this._repeatDelay);
          }
          return this.totalTime(value, suppressEvents);
        };
        p.duration = function(value) {
          if (!arguments.length) {
            return this._duration;
          }
          return Animation.prototype.duration.call(this, value);
        };
        p.totalDuration = function(value) {
          if (!arguments.length) {
            if (this._dirty) {
              this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
              this._dirty = false;
            }
            return this._totalDuration;
          }
          return (this._repeat === -1) ? this : this.duration((value - (this._repeat * this._repeatDelay)) / (this._repeat + 1));
        };
        p.repeat = function(value) {
          if (!arguments.length) {
            return this._repeat;
          }
          this._repeat = value;
          return this._uncache(true);
        };
        p.repeatDelay = function(value) {
          if (!arguments.length) {
            return this._repeatDelay;
          }
          this._repeatDelay = value;
          return this._uncache(true);
        };
        p.yoyo = function(value) {
          if (!arguments.length) {
            return this._yoyo;
          }
          this._yoyo = value;
          return this;
        };
        return TweenMax;
      }, true);
      _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(Animation, SimpleTimeline, TweenLite) {
        var TimelineLite = function(vars) {
          SimpleTimeline.call(this, vars);
          this._labels = {};
          this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
          this.smoothChildTiming = (this.vars.smoothChildTiming === true);
          this._sortChildren = true;
          this._onUpdate = this.vars.onUpdate;
          var v = this.vars,
              val,
              p;
          for (p in v) {
            val = v[p];
            if (_isArray(val))
              if (val.join("").indexOf("{self}") !== -1) {
                v[p] = this._swapSelfInParams(val);
              }
          }
          if (_isArray(v.tweens)) {
            this.add(v.tweens, 0, v.align, v.stagger);
          }
        },
            _tinyNum = 0.0000000001,
            TweenLiteInternals = TweenLite._internals,
            _internals = TimelineLite._internals = {},
            _isSelector = TweenLiteInternals.isSelector,
            _isArray = TweenLiteInternals.isArray,
            _lazyTweens = TweenLiteInternals.lazyTweens,
            _lazyRender = TweenLiteInternals.lazyRender,
            _globals = _gsScope._gsDefine.globals,
            _copy = function(vars) {
              var copy = {},
                  p;
              for (p in vars) {
                copy[p] = vars[p];
              }
              return copy;
            },
            _applyCycle = function(vars, targets, i) {
              var alt = vars.cycle,
                  p,
                  val;
              for (p in alt) {
                val = alt[p];
                vars[p] = (typeof(val) === "function") ? val.call(targets[i], i) : val[i % val.length];
              }
              delete vars.cycle;
            },
            _pauseCallback = _internals.pauseCallback = function() {},
            _slice = function(a) {
              var b = [],
                  l = a.length,
                  i;
              for (i = 0; i !== l; b.push(a[i++]))
                ;
              return b;
            },
            p = TimelineLite.prototype = new SimpleTimeline();
        TimelineLite.version = "1.18.2";
        p.constructor = TimelineLite;
        p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
        p.to = function(target, duration, vars, position) {
          var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
          return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
        };
        p.from = function(target, duration, vars, position) {
          return this.add(((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
        };
        p.fromTo = function(target, duration, fromVars, toVars, position) {
          var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
          return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
        };
        p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
          var tl = new TimelineLite({
            onComplete: onCompleteAll,
            onCompleteParams: onCompleteAllParams,
            callbackScope: onCompleteAllScope,
            smoothChildTiming: this.smoothChildTiming
          }),
              cycle = vars.cycle,
              copy,
              i;
          if (typeof(targets) === "string") {
            targets = TweenLite.selector(targets) || targets;
          }
          targets = targets || [];
          if (_isSelector(targets)) {
            targets = _slice(targets);
          }
          stagger = stagger || 0;
          if (stagger < 0) {
            targets = _slice(targets);
            targets.reverse();
            stagger *= -1;
          }
          for (i = 0; i < targets.length; i++) {
            copy = _copy(vars);
            if (copy.startAt) {
              copy.startAt = _copy(copy.startAt);
              if (copy.startAt.cycle) {
                _applyCycle(copy.startAt, targets, i);
              }
            }
            if (cycle) {
              _applyCycle(copy, targets, i);
            }
            tl.to(targets[i], duration, copy, i * stagger);
          }
          return this.add(tl, position);
        };
        p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
          vars.immediateRender = (vars.immediateRender != false);
          vars.runBackwards = true;
          return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
          toVars.startAt = fromVars;
          toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
          return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        p.call = function(callback, params, scope, position) {
          return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
        };
        p.set = function(target, vars, position) {
          position = this._parseTimeOrLabel(position, 0, true);
          if (vars.immediateRender == null) {
            vars.immediateRender = (position === this._time && !this._paused);
          }
          return this.add(new TweenLite(target, 0, vars), position);
        };
        TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
          vars = vars || {};
          if (vars.smoothChildTiming == null) {
            vars.smoothChildTiming = true;
          }
          var tl = new TimelineLite(vars),
              root = tl._timeline,
              tween,
              next;
          if (ignoreDelayedCalls == null) {
            ignoreDelayedCalls = true;
          }
          root._remove(tl, true);
          tl._startTime = 0;
          tl._rawPrevTime = tl._time = tl._totalTime = root._time;
          tween = root._first;
          while (tween) {
            next = tween._next;
            if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
              tl.add(tween, tween._startTime - tween._delay);
            }
            tween = next;
          }
          root.add(tl, 0);
          return tl;
        };
        p.add = function(value, position, align, stagger) {
          var curTime,
              l,
              i,
              child,
              tl,
              beforeRawTime;
          if (typeof(position) !== "number") {
            position = this._parseTimeOrLabel(position, 0, true, value);
          }
          if (!(value instanceof Animation)) {
            if ((value instanceof Array) || (value && value.push && _isArray(value))) {
              align = align || "normal";
              stagger = stagger || 0;
              curTime = position;
              l = value.length;
              for (i = 0; i < l; i++) {
                if (_isArray(child = value[i])) {
                  child = new TimelineLite({tweens: child});
                }
                this.add(child, curTime);
                if (typeof(child) !== "string" && typeof(child) !== "function") {
                  if (align === "sequence") {
                    curTime = child._startTime + (child.totalDuration() / child._timeScale);
                  } else if (align === "start") {
                    child._startTime -= child.delay();
                  }
                }
                curTime += stagger;
              }
              return this._uncache(true);
            } else if (typeof(value) === "string") {
              return this.addLabel(value, position);
            } else if (typeof(value) === "function") {
              value = TweenLite.delayedCall(0, value);
            } else {
              throw ("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
            }
          }
          SimpleTimeline.prototype.add.call(this, value, position);
          if (this._gc || this._time === this._duration)
            if (!this._paused)
              if (this._duration < this.duration()) {
                tl = this;
                beforeRawTime = (tl.rawTime() > value._startTime);
                while (tl._timeline) {
                  if (beforeRawTime && tl._timeline.smoothChildTiming) {
                    tl.totalTime(tl._totalTime, true);
                  } else if (tl._gc) {
                    tl._enabled(true, false);
                  }
                  tl = tl._timeline;
                }
              }
          return this;
        };
        p.remove = function(value) {
          if (value instanceof Animation) {
            this._remove(value, false);
            var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline;
            value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale);
            return this;
          } else if (value instanceof Array || (value && value.push && _isArray(value))) {
            var i = value.length;
            while (--i > -1) {
              this.remove(value[i]);
            }
            return this;
          } else if (typeof(value) === "string") {
            return this.removeLabel(value);
          }
          return this.kill(null, value);
        };
        p._remove = function(tween, skipDisable) {
          SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
          var last = this._last;
          if (!last) {
            this._time = this._totalTime = this._duration = this._totalDuration = 0;
          } else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
            this._time = this.duration();
            this._totalTime = this._totalDuration;
          }
          return this;
        };
        p.append = function(value, offsetOrLabel) {
          return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
        };
        p.insert = p.insertMultiple = function(value, position, align, stagger) {
          return this.add(value, position || 0, align, stagger);
        };
        p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
          return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
        };
        p.addLabel = function(label, position) {
          this._labels[label] = this._parseTimeOrLabel(position);
          return this;
        };
        p.addPause = function(position, callback, params, scope) {
          var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
          t.vars.onComplete = t.vars.onReverseComplete = callback;
          t.data = "isPause";
          this._hasPause = true;
          return this.add(t, position);
        };
        p.removeLabel = function(label) {
          delete this._labels[label];
          return this;
        };
        p.getLabelTime = function(label) {
          return (this._labels[label] != null) ? this._labels[label] : -1;
        };
        p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
          var i;
          if (ignore instanceof Animation && ignore.timeline === this) {
            this.remove(ignore);
          } else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
            i = ignore.length;
            while (--i > -1) {
              if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
                this.remove(ignore[i]);
              }
            }
          }
          if (typeof(offsetOrLabel) === "string") {
            return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
          }
          offsetOrLabel = offsetOrLabel || 0;
          if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
            i = timeOrLabel.indexOf("=");
            if (i === -1) {
              if (this._labels[timeOrLabel] == null) {
                return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
              }
              return this._labels[timeOrLabel] + offsetOrLabel;
            }
            offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
            timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
          } else if (timeOrLabel == null) {
            timeOrLabel = this.duration();
          }
          return Number(timeOrLabel) + offsetOrLabel;
        };
        p.seek = function(position, suppressEvents) {
          return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
        };
        p.stop = function() {
          return this.paused(true);
        };
        p.gotoAndPlay = function(position, suppressEvents) {
          return this.play(position, suppressEvents);
        };
        p.gotoAndStop = function(position, suppressEvents) {
          return this.pause(position, suppressEvents);
        };
        p.render = function(time, suppressEvents, force) {
          if (this._gc) {
            this._enabled(true, false);
          }
          var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
              prevTime = this._time,
              prevStart = this._startTime,
              prevTimeScale = this._timeScale,
              prevPaused = this._paused,
              tween,
              isComplete,
              next,
              callback,
              internalForce,
              pauseTween,
              curTime;
          if (time >= totalDur - 0.0000001) {
            this._totalTime = this._time = totalDur;
            if (!this._reversed)
              if (!this._hasPausedChild()) {
                isComplete = true;
                callback = "onComplete";
                internalForce = !!this._timeline.autoRemoveChildren;
                if (this._duration === 0)
                  if ((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)
                    if (this._rawPrevTime !== time && this._first) {
                      internalForce = true;
                      if (this._rawPrevTime > _tinyNum) {
                        callback = "onReverseComplete";
                      }
                    }
              }
            this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
            time = totalDur + 0.0001;
          } else if (time < 0.0000001) {
            this._totalTime = this._time = 0;
            if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
              callback = "onReverseComplete";
              isComplete = this._reversed;
            }
            if (time < 0) {
              this._active = false;
              if (this._timeline.autoRemoveChildren && this._reversed) {
                internalForce = isComplete = true;
                callback = "onReverseComplete";
              } else if (this._rawPrevTime >= 0 && this._first) {
                internalForce = true;
              }
              this._rawPrevTime = time;
            } else {
              this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
              if (time === 0 && isComplete) {
                tween = this._first;
                while (tween && tween._startTime === 0) {
                  if (!tween._duration) {
                    isComplete = false;
                  }
                  tween = tween._next;
                }
              }
              time = 0;
              if (!this._initted) {
                internalForce = true;
              }
            }
          } else {
            if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
              if (time >= prevTime) {
                tween = this._first;
                while (tween && tween._startTime <= time && !pauseTween) {
                  if (!tween._duration)
                    if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                      pauseTween = tween;
                    }
                  tween = tween._next;
                }
              } else {
                tween = this._last;
                while (tween && tween._startTime >= time && !pauseTween) {
                  if (!tween._duration)
                    if (tween.data === "isPause" && tween._rawPrevTime > 0) {
                      pauseTween = tween;
                    }
                  tween = tween._prev;
                }
              }
              if (pauseTween) {
                this._time = time = pauseTween._startTime;
                this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
              }
            }
            this._totalTime = this._time = this._rawPrevTime = time;
          }
          if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
            return;
          } else if (!this._initted) {
            this._initted = true;
          }
          if (!this._active)
            if (!this._paused && this._time !== prevTime && time > 0) {
              this._active = true;
            }
          if (prevTime === 0)
            if (this.vars.onStart)
              if (this._time !== 0)
                if (!suppressEvents) {
                  this._callback("onStart");
                }
          curTime = this._time;
          if (curTime >= prevTime) {
            tween = this._first;
            while (tween) {
              next = tween._next;
              if (curTime !== this._time || (this._paused && !prevPaused)) {
                break;
              } else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
                if (pauseTween === tween) {
                  this.pause();
                }
                if (!tween._reversed) {
                  tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                } else {
                  tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                }
              }
              tween = next;
            }
          } else {
            tween = this._last;
            while (tween) {
              next = tween._prev;
              if (curTime !== this._time || (this._paused && !prevPaused)) {
                break;
              } else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
                if (pauseTween === tween) {
                  pauseTween = tween._prev;
                  while (pauseTween && pauseTween.endTime() > this._time) {
                    pauseTween.render((pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
                    pauseTween = pauseTween._prev;
                  }
                  pauseTween = null;
                  this.pause();
                }
                if (!tween._reversed) {
                  tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                } else {
                  tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                }
              }
              tween = next;
            }
          }
          if (this._onUpdate)
            if (!suppressEvents) {
              if (_lazyTweens.length) {
                _lazyRender();
              }
              this._callback("onUpdate");
            }
          if (callback)
            if (!this._gc)
              if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
                if (this._time === 0 || totalDur >= this.totalDuration()) {
                  if (isComplete) {
                    if (_lazyTweens.length) {
                      _lazyRender();
                    }
                    if (this._timeline.autoRemoveChildren) {
                      this._enabled(false, false);
                    }
                    this._active = false;
                  }
                  if (!suppressEvents && this.vars[callback]) {
                    this._callback(callback);
                  }
                }
        };
        p._hasPausedChild = function() {
          var tween = this._first;
          while (tween) {
            if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
              return true;
            }
            tween = tween._next;
          }
          return false;
        };
        p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
          ignoreBeforeTime = ignoreBeforeTime || -9999999999;
          var a = [],
              tween = this._first,
              cnt = 0;
          while (tween) {
            if (tween._startTime < ignoreBeforeTime) {} else if (tween instanceof TweenLite) {
              if (tweens !== false) {
                a[cnt++] = tween;
              }
            } else {
              if (timelines !== false) {
                a[cnt++] = tween;
              }
              if (nested !== false) {
                a = a.concat(tween.getChildren(true, tweens, timelines));
                cnt = a.length;
              }
            }
            tween = tween._next;
          }
          return a;
        };
        p.getTweensOf = function(target, nested) {
          var disabled = this._gc,
              a = [],
              cnt = 0,
              tweens,
              i;
          if (disabled) {
            this._enabled(true, true);
          }
          tweens = TweenLite.getTweensOf(target);
          i = tweens.length;
          while (--i > -1) {
            if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
              a[cnt++] = tweens[i];
            }
          }
          if (disabled) {
            this._enabled(false, true);
          }
          return a;
        };
        p.recent = function() {
          return this._recent;
        };
        p._contains = function(tween) {
          var tl = tween.timeline;
          while (tl) {
            if (tl === this) {
              return true;
            }
            tl = tl.timeline;
          }
          return false;
        };
        p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
          ignoreBeforeTime = ignoreBeforeTime || 0;
          var tween = this._first,
              labels = this._labels,
              p;
          while (tween) {
            if (tween._startTime >= ignoreBeforeTime) {
              tween._startTime += amount;
            }
            tween = tween._next;
          }
          if (adjustLabels) {
            for (p in labels) {
              if (labels[p] >= ignoreBeforeTime) {
                labels[p] += amount;
              }
            }
          }
          return this._uncache(true);
        };
        p._kill = function(vars, target) {
          if (!vars && !target) {
            return this._enabled(false, false);
          }
          var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
              i = tweens.length,
              changed = false;
          while (--i > -1) {
            if (tweens[i]._kill(vars, target)) {
              changed = true;
            }
          }
          return changed;
        };
        p.clear = function(labels) {
          var tweens = this.getChildren(false, true, true),
              i = tweens.length;
          this._time = this._totalTime = 0;
          while (--i > -1) {
            tweens[i]._enabled(false, false);
          }
          if (labels !== false) {
            this._labels = {};
          }
          return this._uncache(true);
        };
        p.invalidate = function() {
          var tween = this._first;
          while (tween) {
            tween.invalidate();
            tween = tween._next;
          }
          return Animation.prototype.invalidate.call(this);
          ;
        };
        p._enabled = function(enabled, ignoreTimeline) {
          if (enabled === this._gc) {
            var tween = this._first;
            while (tween) {
              tween._enabled(enabled, true);
              tween = tween._next;
            }
          }
          return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
        };
        p.totalTime = function(time, suppressEvents, uncapped) {
          this._forcingPlayhead = true;
          var val = Animation.prototype.totalTime.apply(this, arguments);
          this._forcingPlayhead = false;
          return val;
        };
        p.duration = function(value) {
          if (!arguments.length) {
            if (this._dirty) {
              this.totalDuration();
            }
            return this._duration;
          }
          if (this.duration() !== 0 && value !== 0) {
            this.timeScale(this._duration / value);
          }
          return this;
        };
        p.totalDuration = function(value) {
          if (!arguments.length) {
            if (this._dirty) {
              var max = 0,
                  tween = this._last,
                  prevStart = 999999999999,
                  prev,
                  end;
              while (tween) {
                prev = tween._prev;
                if (tween._dirty) {
                  tween.totalDuration();
                }
                if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
                  this.add(tween, tween._startTime - tween._delay);
                } else {
                  prevStart = tween._startTime;
                }
                if (tween._startTime < 0 && !tween._paused) {
                  max -= tween._startTime;
                  if (this._timeline.smoothChildTiming) {
                    this._startTime += tween._startTime / this._timeScale;
                  }
                  this.shiftChildren(-tween._startTime, false, -9999999999);
                  prevStart = 0;
                }
                end = tween._startTime + (tween._totalDuration / tween._timeScale);
                if (end > max) {
                  max = end;
                }
                tween = prev;
              }
              this._duration = this._totalDuration = max;
              this._dirty = false;
            }
            return this._totalDuration;
          }
          return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
        };
        p.paused = function(value) {
          if (!value) {
            var tween = this._first,
                time = this._time;
            while (tween) {
              if (tween._startTime === time && tween.data === "isPause") {
                tween._rawPrevTime = 0;
              }
              tween = tween._next;
            }
          }
          return Animation.prototype.paused.apply(this, arguments);
        };
        p.usesFrames = function() {
          var tl = this._timeline;
          while (tl._timeline) {
            tl = tl._timeline;
          }
          return (tl === Animation._rootFramesTimeline);
        };
        p.rawTime = function() {
          return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
        };
        return TimelineLite;
      }, true);
      _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(TimelineLite, TweenLite, Ease) {
        var TimelineMax = function(vars) {
          TimelineLite.call(this, vars);
          this._repeat = this.vars.repeat || 0;
          this._repeatDelay = this.vars.repeatDelay || 0;
          this._cycle = 0;
          this._yoyo = (this.vars.yoyo === true);
          this._dirty = true;
        },
            _tinyNum = 0.0000000001,
            TweenLiteInternals = TweenLite._internals,
            _lazyTweens = TweenLiteInternals.lazyTweens,
            _lazyRender = TweenLiteInternals.lazyRender,
            _easeNone = new Ease(null, null, 1, 0),
            p = TimelineMax.prototype = new TimelineLite();
        p.constructor = TimelineMax;
        p.kill()._gc = false;
        TimelineMax.version = "1.18.2";
        p.invalidate = function() {
          this._yoyo = (this.vars.yoyo === true);
          this._repeat = this.vars.repeat || 0;
          this._repeatDelay = this.vars.repeatDelay || 0;
          this._uncache(true);
          return TimelineLite.prototype.invalidate.call(this);
        };
        p.addCallback = function(callback, position, params, scope) {
          return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
        };
        p.removeCallback = function(callback, position) {
          if (callback) {
            if (position == null) {
              this._kill(null, callback);
            } else {
              var a = this.getTweensOf(callback, false),
                  i = a.length,
                  time = this._parseTimeOrLabel(position);
              while (--i > -1) {
                if (a[i]._startTime === time) {
                  a[i]._enabled(false, false);
                }
              }
            }
          }
          return this;
        };
        p.removePause = function(position) {
          return this.removeCallback(TimelineLite._internals.pauseCallback, position);
        };
        p.tweenTo = function(position, vars) {
          vars = vars || {};
          var copy = {
            ease: _easeNone,
            useFrames: this.usesFrames(),
            immediateRender: false
          },
              duration,
              p,
              t;
          for (p in vars) {
            copy[p] = vars[p];
          }
          copy.time = this._parseTimeOrLabel(position);
          duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
          t = new TweenLite(this, duration, copy);
          copy.onStart = function() {
            t.target.paused(true);
            if (t.vars.time !== t.target.time() && duration === t.duration()) {
              t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
            }
            if (vars.onStart) {
              t._callback("onStart");
            }
          };
          return t;
        };
        p.tweenFromTo = function(fromPosition, toPosition, vars) {
          vars = vars || {};
          fromPosition = this._parseTimeOrLabel(fromPosition);
          vars.startAt = {
            onComplete: this.seek,
            onCompleteParams: [fromPosition],
            callbackScope: this
          };
          vars.immediateRender = (vars.immediateRender !== false);
          var t = this.tweenTo(toPosition, vars);
          return t.duration((Math.abs(t.vars.time - fromPosition) / this._timeScale) || 0.001);
        };
        p.render = function(time, suppressEvents, force) {
          if (this._gc) {
            this._enabled(true, false);
          }
          var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
              dur = this._duration,
              prevTime = this._time,
              prevTotalTime = this._totalTime,
              prevStart = this._startTime,
              prevTimeScale = this._timeScale,
              prevRawPrevTime = this._rawPrevTime,
              prevPaused = this._paused,
              prevCycle = this._cycle,
              tween,
              isComplete,
              next,
              callback,
              internalForce,
              cycleDuration,
              pauseTween,
              curTime;
          if (time >= totalDur - 0.0000001) {
            if (!this._locked) {
              this._totalTime = totalDur;
              this._cycle = this._repeat;
            }
            if (!this._reversed)
              if (!this._hasPausedChild()) {
                isComplete = true;
                callback = "onComplete";
                internalForce = !!this._timeline.autoRemoveChildren;
                if (this._duration === 0)
                  if ((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)
                    if (prevRawPrevTime !== time && this._first) {
                      internalForce = true;
                      if (prevRawPrevTime > _tinyNum) {
                        callback = "onReverseComplete";
                      }
                    }
              }
            this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
            if (this._yoyo && (this._cycle & 1) !== 0) {
              this._time = time = 0;
            } else {
              this._time = dur;
              time = dur + 0.0001;
            }
          } else if (time < 0.0000001) {
            if (!this._locked) {
              this._totalTime = this._cycle = 0;
            }
            this._time = 0;
            if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) {
              callback = "onReverseComplete";
              isComplete = this._reversed;
            }
            if (time < 0) {
              this._active = false;
              if (this._timeline.autoRemoveChildren && this._reversed) {
                internalForce = isComplete = true;
                callback = "onReverseComplete";
              } else if (prevRawPrevTime >= 0 && this._first) {
                internalForce = true;
              }
              this._rawPrevTime = time;
            } else {
              this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
              if (time === 0 && isComplete) {
                tween = this._first;
                while (tween && tween._startTime === 0) {
                  if (!tween._duration) {
                    isComplete = false;
                  }
                  tween = tween._next;
                }
              }
              time = 0;
              if (!this._initted) {
                internalForce = true;
              }
            }
          } else {
            if (dur === 0 && prevRawPrevTime < 0) {
              internalForce = true;
            }
            this._time = this._rawPrevTime = time;
            if (!this._locked) {
              this._totalTime = time;
              if (this._repeat !== 0) {
                cycleDuration = dur + this._repeatDelay;
                this._cycle = (this._totalTime / cycleDuration) >> 0;
                if (this._cycle !== 0)
                  if (this._cycle === this._totalTime / cycleDuration) {
                    this._cycle--;
                  }
                this._time = this._totalTime - (this._cycle * cycleDuration);
                if (this._yoyo)
                  if ((this._cycle & 1) !== 0) {
                    this._time = dur - this._time;
                  }
                if (this._time > dur) {
                  this._time = dur;
                  time = dur + 0.0001;
                } else if (this._time < 0) {
                  this._time = time = 0;
                } else {
                  time = this._time;
                }
              }
            }
            if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
              time = this._time;
              if (time >= prevTime) {
                tween = this._first;
                while (tween && tween._startTime <= time && !pauseTween) {
                  if (!tween._duration)
                    if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                      pauseTween = tween;
                    }
                  tween = tween._next;
                }
              } else {
                tween = this._last;
                while (tween && tween._startTime >= time && !pauseTween) {
                  if (!tween._duration)
                    if (tween.data === "isPause" && tween._rawPrevTime > 0) {
                      pauseTween = tween;
                    }
                  tween = tween._prev;
                }
              }
              if (pauseTween) {
                this._time = time = pauseTween._startTime;
                this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
              }
            }
          }
          if (this._cycle !== prevCycle)
            if (!this._locked) {
              var backwards = (this._yoyo && (prevCycle & 1) !== 0),
                  wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
                  recTotalTime = this._totalTime,
                  recCycle = this._cycle,
                  recRawPrevTime = this._rawPrevTime,
                  recTime = this._time;
              this._totalTime = prevCycle * dur;
              if (this._cycle < prevCycle) {
                backwards = !backwards;
              } else {
                this._totalTime += dur;
              }
              this._time = prevTime;
              this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
              this._cycle = prevCycle;
              this._locked = true;
              prevTime = (backwards) ? 0 : dur;
              this.render(prevTime, suppressEvents, (dur === 0));
              if (!suppressEvents)
                if (!this._gc) {
                  if (this.vars.onRepeat) {
                    this._callback("onRepeat");
                  }
                }
              if (prevTime !== this._time) {
                return;
              }
              if (wrap) {
                prevTime = (backwards) ? dur + 0.0001 : -0.0001;
                this.render(prevTime, true, false);
              }
              this._locked = false;
              if (this._paused && !prevPaused) {
                return;
              }
              this._time = recTime;
              this._totalTime = recTotalTime;
              this._cycle = recCycle;
              this._rawPrevTime = recRawPrevTime;
            }
          if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
            if (prevTotalTime !== this._totalTime)
              if (this._onUpdate)
                if (!suppressEvents) {
                  this._callback("onUpdate");
                }
            return;
          } else if (!this._initted) {
            this._initted = true;
          }
          if (!this._active)
            if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
              this._active = true;
            }
          if (prevTotalTime === 0)
            if (this.vars.onStart)
              if (this._totalTime !== 0)
                if (!suppressEvents) {
                  this._callback("onStart");
                }
          curTime = this._time;
          if (curTime >= prevTime) {
            tween = this._first;
            while (tween) {
              next = tween._next;
              if (curTime !== this._time || (this._paused && !prevPaused)) {
                break;
              } else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
                if (pauseTween === tween) {
                  this.pause();
                }
                if (!tween._reversed) {
                  tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                } else {
                  tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                }
              }
              tween = next;
            }
          } else {
            tween = this._last;
            while (tween) {
              next = tween._prev;
              if (curTime !== this._time || (this._paused && !prevPaused)) {
                break;
              } else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
                if (pauseTween === tween) {
                  pauseTween = tween._prev;
                  while (pauseTween && pauseTween.endTime() > this._time) {
                    pauseTween.render((pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
                    pauseTween = pauseTween._prev;
                  }
                  pauseTween = null;
                  this.pause();
                }
                if (!tween._reversed) {
                  tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                } else {
                  tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                }
              }
              tween = next;
            }
          }
          if (this._onUpdate)
            if (!suppressEvents) {
              if (_lazyTweens.length) {
                _lazyRender();
              }
              this._callback("onUpdate");
            }
          if (callback)
            if (!this._locked)
              if (!this._gc)
                if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
                  if (this._time === 0 || totalDur >= this.totalDuration()) {
                    if (isComplete) {
                      if (_lazyTweens.length) {
                        _lazyRender();
                      }
                      if (this._timeline.autoRemoveChildren) {
                        this._enabled(false, false);
                      }
                      this._active = false;
                    }
                    if (!suppressEvents && this.vars[callback]) {
                      this._callback(callback);
                    }
                  }
        };
        p.getActive = function(nested, tweens, timelines) {
          if (nested == null) {
            nested = true;
          }
          if (tweens == null) {
            tweens = true;
          }
          if (timelines == null) {
            timelines = false;
          }
          var a = [],
              all = this.getChildren(nested, tweens, timelines),
              cnt = 0,
              l = all.length,
              i,
              tween;
          for (i = 0; i < l; i++) {
            tween = all[i];
            if (tween.isActive()) {
              a[cnt++] = tween;
            }
          }
          return a;
        };
        p.getLabelAfter = function(time) {
          if (!time)
            if (time !== 0) {
              time = this._time;
            }
          var labels = this.getLabelsArray(),
              l = labels.length,
              i;
          for (i = 0; i < l; i++) {
            if (labels[i].time > time) {
              return labels[i].name;
            }
          }
          return null;
        };
        p.getLabelBefore = function(time) {
          if (time == null) {
            time = this._time;
          }
          var labels = this.getLabelsArray(),
              i = labels.length;
          while (--i > -1) {
            if (labels[i].time < time) {
              return labels[i].name;
            }
          }
          return null;
        };
        p.getLabelsArray = function() {
          var a = [],
              cnt = 0,
              p;
          for (p in this._labels) {
            a[cnt++] = {
              time: this._labels[p],
              name: p
            };
          }
          a.sort(function(a, b) {
            return a.time - b.time;
          });
          return a;
        };
        p.progress = function(value, suppressEvents) {
          return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
        };
        p.totalProgress = function(value, suppressEvents) {
          return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
        };
        p.totalDuration = function(value) {
          if (!arguments.length) {
            if (this._dirty) {
              TimelineLite.prototype.totalDuration.call(this);
              this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
            }
            return this._totalDuration;
          }
          return (this._repeat === -1 || !value) ? this : this.timeScale(this.totalDuration() / value);
        };
        p.time = function(value, suppressEvents) {
          if (!arguments.length) {
            return this._time;
          }
          if (this._dirty) {
            this.totalDuration();
          }
          if (value > this._duration) {
            value = this._duration;
          }
          if (this._yoyo && (this._cycle & 1) !== 0) {
            value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
          } else if (this._repeat !== 0) {
            value += this._cycle * (this._duration + this._repeatDelay);
          }
          return this.totalTime(value, suppressEvents);
        };
        p.repeat = function(value) {
          if (!arguments.length) {
            return this._repeat;
          }
          this._repeat = value;
          return this._uncache(true);
        };
        p.repeatDelay = function(value) {
          if (!arguments.length) {
            return this._repeatDelay;
          }
          this._repeatDelay = value;
          return this._uncache(true);
        };
        p.yoyo = function(value) {
          if (!arguments.length) {
            return this._yoyo;
          }
          this._yoyo = value;
          return this;
        };
        p.currentLabel = function(value) {
          if (!arguments.length) {
            return this.getLabelBefore(this._time + 0.00000001);
          }
          return this.seek(value, true);
        };
        return TimelineMax;
      }, true);
      (function() {
        var _RAD2DEG = 180 / Math.PI,
            _r1 = [],
            _r2 = [],
            _r3 = [],
            _corProps = {},
            _globals = _gsScope._gsDefine.globals,
            Segment = function(a, b, c, d) {
              this.a = a;
              this.b = b;
              this.c = c;
              this.d = d;
              this.da = d - a;
              this.ca = c - a;
              this.ba = b - a;
            },
            _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
            cubicToQuadratic = function(a, b, c, d) {
              var q1 = {a: a},
                  q2 = {},
                  q3 = {},
                  q4 = {c: d},
                  mab = (a + b) / 2,
                  mbc = (b + c) / 2,
                  mcd = (c + d) / 2,
                  mabc = (mab + mbc) / 2,
                  mbcd = (mbc + mcd) / 2,
                  m8 = (mbcd - mabc) / 8;
              q1.b = mab + (a - mab) / 4;
              q2.b = mabc + m8;
              q1.c = q2.a = (q1.b + q2.b) / 2;
              q2.c = q3.a = (mabc + mbcd) / 2;
              q3.b = mbcd - m8;
              q4.b = mcd + (d - mcd) / 4;
              q3.c = q4.a = (q3.b + q4.b) / 2;
              return [q1, q2, q3, q4];
            },
            _calculateControlPoints = function(a, curviness, quad, basic, correlate) {
              var l = a.length - 1,
                  ii = 0,
                  cp1 = a[0].a,
                  i,
                  p1,
                  p2,
                  p3,
                  seg,
                  m1,
                  m2,
                  mm,
                  cp2,
                  qb,
                  r1,
                  r2,
                  tl;
              for (i = 0; i < l; i++) {
                seg = a[ii];
                p1 = seg.a;
                p2 = seg.d;
                p3 = a[ii + 1].d;
                if (correlate) {
                  r1 = _r1[i];
                  r2 = _r2[i];
                  tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
                  m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
                  m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
                  mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
                } else {
                  m1 = p2 - (p2 - p1) * curviness * 0.5;
                  m2 = p2 + (p3 - p2) * curviness * 0.5;
                  mm = p2 - (m1 + m2) / 2;
                }
                m1 += mm;
                m2 += mm;
                seg.c = cp2 = m1;
                if (i !== 0) {
                  seg.b = cp1;
                } else {
                  seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6;
                }
                seg.da = p2 - p1;
                seg.ca = cp2 - p1;
                seg.ba = cp1 - p1;
                if (quad) {
                  qb = cubicToQuadratic(p1, cp1, cp2, p2);
                  a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
                  ii += 4;
                } else {
                  ii++;
                }
                cp1 = m2;
              }
              seg = a[ii];
              seg.b = cp1;
              seg.c = cp1 + (seg.d - cp1) * 0.4;
              seg.da = seg.d - seg.a;
              seg.ca = seg.c - seg.a;
              seg.ba = cp1 - seg.a;
              if (quad) {
                qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
                a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
              }
            },
            _parseAnchors = function(values, p, correlate, prepend) {
              var a = [],
                  l,
                  i,
                  p1,
                  p2,
                  p3,
                  tmp;
              if (prepend) {
                values = [prepend].concat(values);
                i = values.length;
                while (--i > -1) {
                  if (typeof((tmp = values[i][p])) === "string")
                    if (tmp.charAt(1) === "=") {
                      values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2));
                    }
                }
              }
              l = values.length - 2;
              if (l < 0) {
                a[0] = new Segment(values[0][p], 0, 0, values[(l < -1) ? 0 : 1][p]);
                return a;
              }
              for (i = 0; i < l; i++) {
                p1 = values[i][p];
                p2 = values[i + 1][p];
                a[i] = new Segment(p1, 0, 0, p2);
                if (correlate) {
                  p3 = values[i + 2][p];
                  _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
                  _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
                }
              }
              a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
              return a;
            },
            bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
              var obj = {},
                  props = [],
                  first = prepend || values[0],
                  i,
                  p,
                  a,
                  j,
                  r,
                  l,
                  seamless,
                  last;
              correlate = (typeof(correlate) === "string") ? "," + correlate + "," : _correlate;
              if (curviness == null) {
                curviness = 1;
              }
              for (p in values[0]) {
                props.push(p);
              }
              if (values.length > 1) {
                last = values[values.length - 1];
                seamless = true;
                i = props.length;
                while (--i > -1) {
                  p = props[i];
                  if (Math.abs(first[p] - last[p]) > 0.05) {
                    seamless = false;
                    break;
                  }
                }
                if (seamless) {
                  values = values.concat();
                  if (prepend) {
                    values.unshift(prepend);
                  }
                  values.push(values[1]);
                  prepend = values[values.length - 3];
                }
              }
              _r1.length = _r2.length = _r3.length = 0;
              i = props.length;
              while (--i > -1) {
                p = props[i];
                _corProps[p] = (correlate.indexOf("," + p + ",") !== -1);
                obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
              }
              i = _r1.length;
              while (--i > -1) {
                _r1[i] = Math.sqrt(_r1[i]);
                _r2[i] = Math.sqrt(_r2[i]);
              }
              if (!basic) {
                i = props.length;
                while (--i > -1) {
                  if (_corProps[p]) {
                    a = obj[props[i]];
                    l = a.length - 1;
                    for (j = 0; j < l; j++) {
                      r = a[j + 1].da / _r2[j] + a[j].da / _r1[j];
                      _r3[j] = (_r3[j] || 0) + r * r;
                    }
                  }
                }
                i = _r3.length;
                while (--i > -1) {
                  _r3[i] = Math.sqrt(_r3[i]);
                }
              }
              i = props.length;
              j = quadratic ? 4 : 1;
              while (--i > -1) {
                p = props[i];
                a = obj[p];
                _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]);
                if (seamless) {
                  a.splice(0, j);
                  a.splice(a.length - j, j);
                }
              }
              return obj;
            },
            _parseBezierData = function(values, type, prepend) {
              type = type || "soft";
              var obj = {},
                  inc = (type === "cubic") ? 3 : 2,
                  soft = (type === "soft"),
                  props = [],
                  a,
                  b,
                  c,
                  d,
                  cur,
                  i,
                  j,
                  l,
                  p,
                  cnt,
                  tmp;
              if (soft && prepend) {
                values = [prepend].concat(values);
              }
              if (values == null || values.length < inc + 1) {
                throw "invalid Bezier data";
              }
              for (p in values[0]) {
                props.push(p);
              }
              i = props.length;
              while (--i > -1) {
                p = props[i];
                obj[p] = cur = [];
                cnt = 0;
                l = values.length;
                for (j = 0; j < l; j++) {
                  a = (prepend == null) ? values[j][p] : (typeof((tmp = values[j][p])) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
                  if (soft)
                    if (j > 1)
                      if (j < l - 1) {
                        cur[cnt++] = (a + cur[cnt - 2]) / 2;
                      }
                  cur[cnt++] = a;
                }
                l = cnt - inc + 1;
                cnt = 0;
                for (j = 0; j < l; j += inc) {
                  a = cur[j];
                  b = cur[j + 1];
                  c = cur[j + 2];
                  d = (inc === 2) ? 0 : cur[j + 3];
                  cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
                }
                cur.length = cnt;
              }
              return obj;
            },
            _addCubicLengths = function(a, steps, resolution) {
              var inc = 1 / resolution,
                  j = a.length,
                  d,
                  d1,
                  s,
                  da,
                  ca,
                  ba,
                  p,
                  i,
                  inv,
                  bez,
                  index;
              while (--j > -1) {
                bez = a[j];
                s = bez.a;
                da = bez.d - s;
                ca = bez.c - s;
                ba = bez.b - s;
                d = d1 = 0;
                for (i = 1; i <= resolution; i++) {
                  p = inc * i;
                  inv = 1 - p;
                  d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
                  index = j * resolution + i - 1;
                  steps[index] = (steps[index] || 0) + d * d;
                }
              }
            },
            _parseLengthData = function(obj, resolution) {
              resolution = resolution >> 0 || 6;
              var a = [],
                  lengths = [],
                  d = 0,
                  total = 0,
                  threshold = resolution - 1,
                  segments = [],
                  curLS = [],
                  p,
                  i,
                  l,
                  index;
              for (p in obj) {
                _addCubicLengths(obj[p], a, resolution);
              }
              l = a.length;
              for (i = 0; i < l; i++) {
                d += Math.sqrt(a[i]);
                index = i % resolution;
                curLS[index] = d;
                if (index === threshold) {
                  total += d;
                  index = (i / resolution) >> 0;
                  segments[index] = curLS;
                  lengths[index] = total;
                  d = 0;
                  curLS = [];
                }
              }
              return {
                length: total,
                lengths: lengths,
                segments: segments
              };
            },
            BezierPlugin = _gsScope._gsDefine.plugin({
              propName: "bezier",
              priority: -1,
              version: "1.3.4",
              API: 2,
              global: true,
              init: function(target, vars, tween) {
                this._target = target;
                if (vars instanceof Array) {
                  vars = {values: vars};
                }
                this._func = {};
                this._round = {};
                this._props = [];
                this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
                var values = vars.values || [],
                    first = {},
                    second = values[0],
                    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
                    p,
                    isFunc,
                    i,
                    j,
                    prepend;
                this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x", "y", "rotation", ((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
                for (p in second) {
                  this._props.push(p);
                }
                i = this._props.length;
                while (--i > -1) {
                  p = this._props[i];
                  this._overwriteProps.push(p);
                  isFunc = this._func[p] = (typeof(target[p]) === "function");
                  first[p] = (!isFunc) ? parseFloat(target[p]) : target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))]();
                  if (!prepend)
                    if (first[p] !== values[0][p]) {
                      prepend = first;
                    }
                }
                this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
                this._segCount = this._beziers[p].length;
                if (this._timeRes) {
                  var ld = _parseLengthData(this._beziers, this._timeRes);
                  this._length = ld.length;
                  this._lengths = ld.lengths;
                  this._segments = ld.segments;
                  this._l1 = this._li = this._s1 = this._si = 0;
                  this._l2 = this._lengths[0];
                  this._curSeg = this._segments[0];
                  this._s2 = this._curSeg[0];
                  this._prec = 1 / this._curSeg.length;
                }
                if ((autoRotate = this._autoRotate)) {
                  this._initialRotations = [];
                  if (!(autoRotate[0] instanceof Array)) {
                    this._autoRotate = autoRotate = [autoRotate];
                  }
                  i = autoRotate.length;
                  while (--i > -1) {
                    for (j = 0; j < 3; j++) {
                      p = autoRotate[i][j];
                      this._func[p] = (typeof(target[p]) === "function") ? target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))] : false;
                    }
                    p = autoRotate[i][2];
                    this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p];
                  }
                }
                this._startRatio = tween.vars.runBackwards ? 1 : 0;
                return true;
              },
              set: function(v) {
                var segments = this._segCount,
                    func = this._func,
                    target = this._target,
                    notStart = (v !== this._startRatio),
                    curIndex,
                    inv,
                    i,
                    p,
                    b,
                    t,
                    val,
                    l,
                    lengths,
                    curSeg;
                if (!this._timeRes) {
                  curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
                  t = (v - (curIndex * (1 / segments))) * segments;
                } else {
                  lengths = this._lengths;
                  curSeg = this._curSeg;
                  v *= this._length;
                  i = this._li;
                  if (v > this._l2 && i < segments - 1) {
                    l = segments - 1;
                    while (i < l && (this._l2 = lengths[++i]) <= v) {}
                    this._l1 = lengths[i - 1];
                    this._li = i;
                    this._curSeg = curSeg = this._segments[i];
                    this._s2 = curSeg[(this._s1 = this._si = 0)];
                  } else if (v < this._l1 && i > 0) {
                    while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
                    if (i === 0 && v < this._l1) {
                      this._l1 = 0;
                    } else {
                      i++;
                    }
                    this._l2 = lengths[i];
                    this._li = i;
                    this._curSeg = curSeg = this._segments[i];
                    this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
                    this._s2 = curSeg[this._si];
                  }
                  curIndex = i;
                  v -= this._l1;
                  i = this._si;
                  if (v > this._s2 && i < curSeg.length - 1) {
                    l = curSeg.length - 1;
                    while (i < l && (this._s2 = curSeg[++i]) <= v) {}
                    this._s1 = curSeg[i - 1];
                    this._si = i;
                  } else if (v < this._s1 && i > 0) {
                    while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
                    if (i === 0 && v < this._s1) {
                      this._s1 = 0;
                    } else {
                      i++;
                    }
                    this._s2 = curSeg[i];
                    this._si = i;
                  }
                  t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
                }
                inv = 1 - t;
                i = this._props.length;
                while (--i > -1) {
                  p = this._props[i];
                  b = this._beziers[p][curIndex];
                  val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
                  if (this._round[p]) {
                    val = Math.round(val);
                  }
                  if (func[p]) {
                    target[p](val);
                  } else {
                    target[p] = val;
                  }
                }
                if (this._autoRotate) {
                  var ar = this._autoRotate,
                      b2,
                      x1,
                      y1,
                      x2,
                      y2,
                      add,
                      conv;
                  i = ar.length;
                  while (--i > -1) {
                    p = ar[i][2];
                    add = ar[i][3] || 0;
                    conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
                    b = this._beziers[ar[i][0]];
                    b2 = this._beziers[ar[i][1]];
                    if (b && b2) {
                      b = b[curIndex];
                      b2 = b2[curIndex];
                      x1 = b.a + (b.b - b.a) * t;
                      x2 = b.b + (b.c - b.b) * t;
                      x1 += (x2 - x1) * t;
                      x2 += ((b.c + (b.d - b.c) * t) - x2) * t;
                      y1 = b2.a + (b2.b - b2.a) * t;
                      y2 = b2.b + (b2.c - b2.b) * t;
                      y1 += (y2 - y1) * t;
                      y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;
                      val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];
                      if (func[p]) {
                        target[p](val);
                      } else {
                        target[p] = val;
                      }
                    }
                  }
                }
              }
            }),
            p = BezierPlugin.prototype;
        BezierPlugin.bezierThrough = bezierThrough;
        BezierPlugin.cubicToQuadratic = cubicToQuadratic;
        BezierPlugin._autoCSS = true;
        BezierPlugin.quadraticToCubic = function(a, b, c) {
          return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
        };
        BezierPlugin._cssRegister = function() {
          var CSSPlugin = _globals.CSSPlugin;
          if (!CSSPlugin) {
            return;
          }
          var _internals = CSSPlugin._internals,
              _parseToProxy = _internals._parseToProxy,
              _setPluginRatio = _internals._setPluginRatio,
              CSSPropTween = _internals.CSSPropTween;
          _internals._registerComplexSpecialProp("bezier", {parser: function(t, e, prop, cssp, pt, plugin) {
              if (e instanceof Array) {
                e = {values: e};
              }
              plugin = new BezierPlugin();
              var values = e.values,
                  l = values.length - 1,
                  pluginValues = [],
                  v = {},
                  i,
                  p,
                  data;
              if (l < 0) {
                return pt;
              }
              for (i = 0; i <= l; i++) {
                data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
                pluginValues[i] = data.end;
              }
              for (p in e) {
                v[p] = e[p];
              }
              v.values = pluginValues;
              pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
              pt.data = data;
              pt.plugin = plugin;
              pt.setRatio = _setPluginRatio;
              if (v.autoRotate === 0) {
                v.autoRotate = true;
              }
              if (v.autoRotate && !(v.autoRotate instanceof Array)) {
                i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
                v.autoRotate = (data.end.left != null) ? [["left", "top", "rotation", i, false]] : (data.end.x != null) ? [["x", "y", "rotation", i, false]] : false;
              }
              if (v.autoRotate) {
                if (!cssp._transform) {
                  cssp._enableTransforms(false);
                }
                data.autoRotate = cssp._target._gsTransform;
              }
              plugin._onInitTween(data.proxy, v, cssp._tween);
              return pt;
            }});
        };
        p._roundProps = function(lookup, value) {
          var op = this._overwriteProps,
              i = op.length;
          while (--i > -1) {
            if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
              this._round[op[i]] = value;
            }
          }
        };
        p._kill = function(lookup) {
          var a = this._props,
              p,
              i;
          for (p in this._beziers) {
            if (p in lookup) {
              delete this._beziers[p];
              delete this._func[p];
              i = a.length;
              while (--i > -1) {
                if (a[i] === p) {
                  a.splice(i, 1);
                }
              }
            }
          }
          return this._super._kill.call(this, lookup);
        };
      }());
      _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(TweenPlugin, TweenLite) {
        var CSSPlugin = function() {
          TweenPlugin.call(this, "css");
          this._overwriteProps.length = 0;
          this.setRatio = CSSPlugin.prototype.setRatio;
        },
            _globals = _gsScope._gsDefine.globals,
            _hasPriority,
            _suffixMap,
            _cs,
            _overwriteProps,
            _specialProps = {},
            p = CSSPlugin.prototype = new TweenPlugin("css");
        p.constructor = CSSPlugin;
        CSSPlugin.version = "1.18.2";
        CSSPlugin.API = 2;
        CSSPlugin.defaultTransformPerspective = 0;
        CSSPlugin.defaultSkewType = "compensated";
        CSSPlugin.defaultSmoothOrigin = true;
        p = "px";
        CSSPlugin.suffixMap = {
          top: p,
          right: p,
          bottom: p,
          left: p,
          width: p,
          height: p,
          fontSize: p,
          padding: p,
          margin: p,
          perspective: p,
          lineHeight: ""
        };
        var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
            _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
            _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
            _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
            _opacityExp = /opacity *= *([^)]*)/i,
            _opacityValExp = /opacity:([^;]*)/i,
            _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
            _rgbhslExp = /^(rgb|hsl)/,
            _capsExp = /([A-Z])/g,
            _camelExp = /-([a-z])/gi,
            _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
            _camelFunc = function(s, g) {
              return g.toUpperCase();
            },
            _horizExp = /(?:Left|Right|Width)/i,
            _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
            _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
            _DEG2RAD = Math.PI / 180,
            _RAD2DEG = 180 / Math.PI,
            _forcePT = {},
            _doc = document,
            _createElement = function(type) {
              return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
            },
            _tempDiv = _createElement("div"),
            _tempImg = _createElement("img"),
            _internals = CSSPlugin._internals = {_specialProps: _specialProps},
            _agent = navigator.userAgent,
            _autoRound,
            _reqSafariFix,
            _isSafari,
            _isFirefox,
            _isSafariLT6,
            _ieVers,
            _supportsOpacity = (function() {
              var i = _agent.indexOf("Android"),
                  a = _createElement("a");
              _isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3));
              _isSafariLT6 = (_isSafari && (Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6));
              _isFirefox = (_agent.indexOf("Firefox") !== -1);
              if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
                _ieVers = parseFloat(RegExp.$1);
              }
              if (!a) {
                return false;
              }
              a.style.cssText = "top:1px;opacity:.55;";
              return /^0.55/.test(a.style.opacity);
            }()),
            _getIEOpacity = function(v) {
              return (_opacityExp.test(((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "")) ? (parseFloat(RegExp.$1) / 100) : 1);
            },
            _log = function(s) {
              if (window.console) {
                console.log(s);
              }
            },
            _prefixCSS = "",
            _prefix = "",
            _checkPropPrefix = function(p, e) {
              e = e || _tempDiv;
              var s = e.style,
                  a,
                  i;
              if (s[p] !== undefined) {
                return p;
              }
              p = p.charAt(0).toUpperCase() + p.substr(1);
              a = ["O", "Moz", "ms", "Ms", "Webkit"];
              i = 5;
              while (--i > -1 && s[a[i] + p] === undefined) {}
              if (i >= 0) {
                _prefix = (i === 3) ? "ms" : a[i];
                _prefixCSS = "-" + _prefix.toLowerCase() + "-";
                return _prefix + p;
              }
              return null;
            },
            _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},
            _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
              var rv;
              if (!_supportsOpacity)
                if (p === "opacity") {
                  return _getIEOpacity(t);
                }
              if (!calc && t.style[p]) {
                rv = t.style[p];
              } else if ((cs = cs || _getComputedStyle(t))) {
                rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
              } else if (t.currentStyle) {
                rv = t.currentStyle[p];
              }
              return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
            },
            _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
              if (sfx === "px" || !sfx) {
                return v;
              }
              if (sfx === "auto" || !v) {
                return 0;
              }
              var horiz = _horizExp.test(p),
                  node = t,
                  style = _tempDiv.style,
                  neg = (v < 0),
                  pix,
                  cache,
                  time;
              if (neg) {
                v = -v;
              }
              if (sfx === "%" && p.indexOf("border") !== -1) {
                pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
              } else {
                style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
                if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
                  node = t.parentNode || _doc.body;
                  cache = node._gsCache;
                  time = TweenLite.ticker.frame;
                  if (cache && horiz && cache.time === time) {
                    return cache.width * v / 100;
                  }
                  style[(horiz ? "width" : "height")] = v + sfx;
                } else {
                  style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
                }
                node.appendChild(_tempDiv);
                pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
                node.removeChild(_tempDiv);
                if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
                  cache = node._gsCache = node._gsCache || {};
                  cache.time = time;
                  cache.width = pix / v * 100;
                }
                if (pix === 0 && !recurse) {
                  pix = _convertToPixels(t, p, v, sfx, true);
                }
              }
              return neg ? -pix : pix;
            },
            _calculateOffset = _internals.calculateOffset = function(t, p, cs) {
              if (_getStyle(t, "position", cs) !== "absolute") {
                return 0;
              }
              var dim = ((p === "left") ? "Left" : "Top"),
                  v = _getStyle(t, "margin" + dim, cs);
              return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
            },
            _getAllStyles = function(t, cs) {
              var s = {},
                  i,
                  tr,
                  p;
              if ((cs = cs || _getComputedStyle(t, null))) {
                if ((i = cs.length)) {
                  while (--i > -1) {
                    p = cs[i];
                    if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
                      s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
                    }
                  }
                } else {
                  for (i in cs) {
                    if (i.indexOf("Transform") === -1 || _transformProp === i) {
                      s[i] = cs[i];
                    }
                  }
                }
              } else if ((cs = t.currentStyle || t.style)) {
                for (i in cs) {
                  if (typeof(i) === "string" && s[i] === undefined) {
                    s[i.replace(_camelExp, _camelFunc)] = cs[i];
                  }
                }
              }
              if (!_supportsOpacity) {
                s.opacity = _getIEOpacity(t);
              }
              tr = _getTransform(t, cs, false);
              s.rotation = tr.rotation;
              s.skewX = tr.skewX;
              s.scaleX = tr.scaleX;
              s.scaleY = tr.scaleY;
              s.x = tr.x;
              s.y = tr.y;
              if (_supports3D) {
                s.z = tr.z;
                s.rotationX = tr.rotationX;
                s.rotationY = tr.rotationY;
                s.scaleZ = tr.scaleZ;
              }
              if (s.filters) {
                delete s.filters;
              }
              return s;
            },
            _cssDif = function(t, s1, s2, vars, forceLookup) {
              var difs = {},
                  style = t.style,
                  val,
                  p,
                  mpt;
              for (p in s2) {
                if (p !== "cssText")
                  if (p !== "length")
                    if (isNaN(p))
                      if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p]))
                        if (p.indexOf("Origin") === -1)
                          if (typeof(val) === "number" || typeof(val) === "string") {
                            difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val;
                            if (style[p] !== undefined) {
                              mpt = new MiniPropTween(style, p, style[p], mpt);
                            }
                          }
              }
              if (vars) {
                for (p in vars) {
                  if (p !== "className") {
                    difs[p] = vars[p];
                  }
                }
              }
              return {
                difs: difs,
                firstMPT: mpt
              };
            },
            _dimensions = {
              width: ["Left", "Right"],
              height: ["Top", "Bottom"]
            },
            _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
            _getDimension = function(t, p, cs) {
              var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
                  a = _dimensions[p],
                  i = a.length;
              cs = cs || _getComputedStyle(t, null);
              while (--i > -1) {
                v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
                v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
              }
              return v;
            },
            _parsePosition = function(v, recObj) {
              if (v === "contain" || v === "auto" || v === "auto auto") {
                return v + " ";
              }
              if (v == null || v === "") {
                v = "0 0";
              }
              var a = v.split(" "),
                  x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
                  y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1];
              if (y == null) {
                y = (x === "center") ? "50%" : "0";
              } else if (y === "center") {
                y = "50%";
              }
              if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) {
                x = "50%";
              }
              v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
              if (recObj) {
                recObj.oxp = (x.indexOf("%") !== -1);
                recObj.oyp = (y.indexOf("%") !== -1);
                recObj.oxr = (x.charAt(1) === "=");
                recObj.oyr = (y.charAt(1) === "=");
                recObj.ox = parseFloat(x.replace(_NaNExp, ""));
                recObj.oy = parseFloat(y.replace(_NaNExp, ""));
                recObj.v = v;
              }
              return recObj || v;
            },
            _parseChange = function(e, b) {
              return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
            },
            _parseVal = function(v, d) {
              return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v);
            },
            _parseAngle = function(v, d, p, directionalEnd) {
              var min = 0.000001,
                  cap,
                  split,
                  dif,
                  result,
                  isRelative;
              if (v == null) {
                result = d;
              } else if (typeof(v) === "number") {
                result = v;
              } else {
                cap = 360;
                split = v.split("_");
                isRelative = (v.charAt(1) === "=");
                dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
                if (split.length) {
                  if (directionalEnd) {
                    directionalEnd[p] = d + dif;
                  }
                  if (v.indexOf("short") !== -1) {
                    dif = dif % cap;
                    if (dif !== dif % (cap / 2)) {
                      dif = (dif < 0) ? dif + cap : dif - cap;
                    }
                  }
                  if (v.indexOf("_cw") !== -1 && dif < 0) {
                    dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                  } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                    dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                  }
                }
                result = d + dif;
              }
              if (result < min && result > -min) {
                result = 0;
              }
              return result;
            },
            _colorLookup = {
              aqua: [0, 255, 255],
              lime: [0, 255, 0],
              silver: [192, 192, 192],
              black: [0, 0, 0],
              maroon: [128, 0, 0],
              teal: [0, 128, 128],
              blue: [0, 0, 255],
              navy: [0, 0, 128],
              white: [255, 255, 255],
              fuchsia: [255, 0, 255],
              olive: [128, 128, 0],
              yellow: [255, 255, 0],
              orange: [255, 165, 0],
              gray: [128, 128, 128],
              purple: [128, 0, 128],
              green: [0, 128, 0],
              red: [255, 0, 0],
              pink: [255, 192, 203],
              cyan: [0, 255, 255],
              transparent: [255, 255, 255, 0]
            },
            _hue = function(h, m1, m2) {
              h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
              return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
            },
            _parseColor = CSSPlugin.parseColor = function(v, toHSL) {
              var a,
                  r,
                  g,
                  b,
                  h,
                  s,
                  l,
                  max,
                  min,
                  d,
                  wasHSL;
              if (!v) {
                a = _colorLookup.black;
              } else if (typeof(v) === "number") {
                a = [v >> 16, (v >> 8) & 255, v & 255];
              } else {
                if (v.charAt(v.length - 1) === ",") {
                  v = v.substr(0, v.length - 1);
                }
                if (_colorLookup[v]) {
                  a = _colorLookup[v];
                } else if (v.charAt(0) === "#") {
                  if (v.length === 4) {
                    r = v.charAt(1);
                    g = v.charAt(2);
                    b = v.charAt(3);
                    v = "#" + r + r + g + g + b + b;
                  }
                  v = parseInt(v.substr(1), 16);
                  a = [v >> 16, (v >> 8) & 255, v & 255];
                } else if (v.substr(0, 3) === "hsl") {
                  a = wasHSL = v.match(_numExp);
                  if (!toHSL) {
                    h = (Number(a[0]) % 360) / 360;
                    s = Number(a[1]) / 100;
                    l = Number(a[2]) / 100;
                    g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
                    r = l * 2 - g;
                    if (a.length > 3) {
                      a[3] = Number(v[3]);
                    }
                    a[0] = _hue(h + 1 / 3, r, g);
                    a[1] = _hue(h, r, g);
                    a[2] = _hue(h - 1 / 3, r, g);
                  } else if (v.indexOf("=") !== -1) {
                    return v.match(_relNumExp);
                  }
                } else {
                  a = v.match(_numExp) || _colorLookup.transparent;
                }
                a[0] = Number(a[0]);
                a[1] = Number(a[1]);
                a[2] = Number(a[2]);
                if (a.length > 3) {
                  a[3] = Number(a[3]);
                }
              }
              if (toHSL && !wasHSL) {
                r = a[0] / 255;
                g = a[1] / 255;
                b = a[2] / 255;
                max = Math.max(r, g, b);
                min = Math.min(r, g, b);
                l = (max + min) / 2;
                if (max === min) {
                  h = s = 0;
                } else {
                  d = max - min;
                  s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                  h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
                  h *= 60;
                }
                a[0] = (h + 0.5) | 0;
                a[1] = (s * 100 + 0.5) | 0;
                a[2] = (l * 100 + 0.5) | 0;
              }
              return a;
            },
            _formatColors = function(s, toHSL) {
              var colors = s.match(_colorExp) || [],
                  charIndex = 0,
                  parsed = colors.length ? "" : s,
                  i,
                  color,
                  temp;
              for (i = 0; i < colors.length; i++) {
                color = colors[i];
                temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
                charIndex += temp.length + color.length;
                color = _parseColor(color, toHSL);
                if (color.length === 3) {
                  color.push(1);
                }
                parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
              }
              return parsed;
            },
            _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (p in _colorLookup) {
          _colorExp += "|" + p + "\\b";
        }
        _colorExp = new RegExp(_colorExp + ")", "gi");
        CSSPlugin.colorStringFilter = function(a) {
          var combined = a[0] + a[1],
              toHSL;
          _colorExp.lastIndex = 0;
          if (_colorExp.test(combined)) {
            toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
            a[0] = _formatColors(a[0], toHSL);
            a[1] = _formatColors(a[1], toHSL);
          }
        };
        if (!TweenLite.defaultStringFilter) {
          TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
        }
        var _getFormatter = function(dflt, clr, collapsible, multi) {
          if (dflt == null) {
            return function(v) {
              return v;
            };
          }
          var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
              dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
              pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
              sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
              delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
              numVals = dVals.length,
              dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
              formatter;
          if (!numVals) {
            return function(v) {
              return v;
            };
          }
          if (clr) {
            formatter = function(v) {
              var color,
                  vals,
                  i,
                  a;
              if (typeof(v) === "number") {
                v += dSfx;
              } else if (multi && _commasOutsideParenExp.test(v)) {
                a = v.replace(_commasOutsideParenExp, "|").split("|");
                for (i = 0; i < a.length; i++) {
                  a[i] = formatter(a[i]);
                }
                return a.join(",");
              }
              color = (v.match(_colorExp) || [dColor])[0];
              vals = v.split(color).join("").match(_valuesExp) || [];
              i = vals.length;
              if (numVals > i--) {
                while (++i < numVals) {
                  vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
                }
              }
              return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
            };
            return formatter;
          }
          formatter = function(v) {
            var vals,
                a,
                i;
            if (typeof(v) === "number") {
              v += dSfx;
            } else if (multi && _commasOutsideParenExp.test(v)) {
              a = v.replace(_commasOutsideParenExp, "|").split("|");
              for (i = 0; i < a.length; i++) {
                a[i] = formatter(a[i]);
              }
              return a.join(",");
            }
            vals = v.match(_valuesExp) || [];
            i = vals.length;
            if (numVals > i--) {
              while (++i < numVals) {
                vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
              }
            }
            return pfx + vals.join(delim) + sfx;
          };
          return formatter;
        },
            _getEdgeParser = function(props) {
              props = props.split(",");
              return function(t, e, p, cssp, pt, plugin, vars) {
                var a = (e + "").split(" "),
                    i;
                vars = {};
                for (i = 0; i < 4; i++) {
                  vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
                }
                return cssp.parse(t, vars, pt, plugin);
              };
            },
            _setPluginRatio = _internals._setPluginRatio = function(v) {
              this.plugin.setRatio(v);
              var d = this.data,
                  proxy = d.proxy,
                  mpt = d.firstMPT,
                  min = 0.000001,
                  val,
                  pt,
                  i,
                  str,
                  p;
              while (mpt) {
                val = proxy[mpt.v];
                if (mpt.r) {
                  val = Math.round(val);
                } else if (val < min && val > -min) {
                  val = 0;
                }
                mpt.t[mpt.p] = val;
                mpt = mpt._next;
              }
              if (d.autoRotate) {
                d.autoRotate.rotation = proxy.rotation;
              }
              if (v === 1 || v === 0) {
                mpt = d.firstMPT;
                p = (v === 1) ? "e" : "b";
                while (mpt) {
                  pt = mpt.t;
                  if (!pt.type) {
                    pt[p] = pt.s + pt.xs0;
                  } else if (pt.type === 1) {
                    str = pt.xs0 + pt.s + pt.xs1;
                    for (i = 1; i < pt.l; i++) {
                      str += pt["xn" + i] + pt["xs" + (i + 1)];
                    }
                    pt[p] = str;
                  }
                  mpt = mpt._next;
                }
              }
            },
            MiniPropTween = function(t, p, v, next, r) {
              this.t = t;
              this.p = p;
              this.v = v;
              this.r = r;
              if (next) {
                next._prev = this;
                this._next = next;
              }
            },
            _parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
              var bpt = pt,
                  start = {},
                  end = {},
                  transform = cssp._transform,
                  oldForce = _forcePT,
                  i,
                  p,
                  xp,
                  mpt,
                  firstPT;
              cssp._transform = null;
              _forcePT = vars;
              pt = firstPT = cssp.parse(t, vars, pt, plugin);
              _forcePT = oldForce;
              if (shallow) {
                cssp._transform = transform;
                if (bpt) {
                  bpt._prev = null;
                  if (bpt._prev) {
                    bpt._prev._next = null;
                  }
                }
              }
              while (pt && pt !== bpt) {
                if (pt.type <= 1) {
                  p = pt.p;
                  end[p] = pt.s + pt.c;
                  start[p] = pt.s;
                  if (!shallow) {
                    mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
                    pt.c = 0;
                  }
                  if (pt.type === 1) {
                    i = pt.l;
                    while (--i > 0) {
                      xp = "xn" + i;
                      p = pt.p + "_" + xp;
                      end[p] = pt.data[xp];
                      start[p] = pt[xp];
                      if (!shallow) {
                        mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
                      }
                    }
                  }
                }
                pt = pt._next;
              }
              return {
                proxy: start,
                end: end,
                firstMPT: mpt,
                pt: firstPT
              };
            },
            CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
              this.t = t;
              this.p = p;
              this.s = s;
              this.c = c;
              this.n = n || p;
              if (!(t instanceof CSSPropTween)) {
                _overwriteProps.push(this.n);
              }
              this.r = r;
              this.type = type || 0;
              if (pr) {
                this.pr = pr;
                _hasPriority = true;
              }
              this.b = (b === undefined) ? s : b;
              this.e = (e === undefined) ? s + c : e;
              if (next) {
                this._next = next;
                next._prev = this;
              }
            },
            _addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) {
              var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
              pt.b = start;
              pt.e = pt.xs0 = end;
              return pt;
            },
            _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
              b = b || dflt || "";
              pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
              e += "";
              var ba = b.split(", ").join(",").split(" "),
                  ea = e.split(", ").join(",").split(" "),
                  l = ba.length,
                  autoRound = (_autoRound !== false),
                  i,
                  xi,
                  ni,
                  bv,
                  ev,
                  bnums,
                  enums,
                  bn,
                  hasAlpha,
                  temp,
                  cv,
                  str,
                  useHSL;
              if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
                ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
                ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
                l = ba.length;
              }
              if (l !== ea.length) {
                ba = (dflt || "").split(" ");
                l = ba.length;
              }
              pt.plugin = plugin;
              pt.setRatio = setRatio;
              _colorExp.lastIndex = 0;
              for (i = 0; i < l; i++) {
                bv = ba[i];
                ev = ea[i];
                bn = parseFloat(bv);
                if (bn || bn === 0) {
                  pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);
                } else if (clrs && _colorExp.test(bv)) {
                  str = ev.charAt(ev.length - 1) === "," ? ")," : ")";
                  useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
                  bv = _parseColor(bv, useHSL);
                  ev = _parseColor(ev, useHSL);
                  hasAlpha = (bv.length + ev.length > 6);
                  if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
                    pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
                    pt.e = pt.e.split(ea[i]).join("transparent");
                  } else {
                    if (!_supportsOpacity) {
                      hasAlpha = false;
                    }
                    if (useHSL) {
                      pt.appendXtra((hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
                    } else {
                      pt.appendXtra((hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), true);
                    }
                    if (hasAlpha) {
                      bv = (bv.length < 4) ? 1 : bv[3];
                      pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
                    }
                  }
                  _colorExp.lastIndex = 0;
                } else {
                  bnums = bv.match(_numExp);
                  if (!bnums) {
                    pt["xs" + pt.l] += pt.l ? " " + ev : ev;
                  } else {
                    enums = ev.match(_relNumExp);
                    if (!enums || enums.length !== bnums.length) {
                      return pt;
                    }
                    ni = 0;
                    for (xi = 0; xi < bnums.length; xi++) {
                      cv = bnums[xi];
                      temp = bv.indexOf(cv, ni);
                      pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
                      ni = temp + cv.length;
                    }
                    pt["xs" + pt.l] += bv.substr(ni);
                  }
                }
              }
              if (e.indexOf("=") !== -1)
                if (pt.data) {
                  str = pt.xs0 + pt.data.s;
                  for (i = 1; i < pt.l; i++) {
                    str += pt["xs" + i] + pt.data["xn" + i];
                  }
                  pt.e = str + pt["xs" + i];
                }
              if (!pt.l) {
                pt.type = -1;
                pt.xs0 = pt.e;
              }
              return pt.xfirst || pt;
            },
            i = 9;
        p = CSSPropTween.prototype;
        p.l = p.pr = 0;
        while (--i > 0) {
          p["xn" + i] = 0;
          p["xs" + i] = "";
        }
        p.xs0 = "";
        p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;
        p.appendXtra = function(pfx, s, c, sfx, r, pad) {
          var pt = this,
              l = pt.l;
          pt["xs" + l] += (pad && l) ? " " + pfx : pfx || "";
          if (!c)
            if (l !== 0 && !pt.plugin) {
              pt["xs" + l] += s + (sfx || "");
              return pt;
            }
          pt.l++;
          pt.type = pt.setRatio ? 2 : 1;
          pt["xs" + pt.l] = sfx || "";
          if (l > 0) {
            pt.data["xn" + l] = s + c;
            pt.rxp["xn" + l] = r;
            pt["xn" + l] = s;
            if (!pt.plugin) {
              pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
              pt.xfirst.xs0 = 0;
            }
            return pt;
          }
          pt.data = {s: s + c};
          pt.rxp = {};
          pt.s = s;
          pt.c = c;
          pt.r = r;
          return pt;
        };
        var SpecialProp = function(p, options) {
          options = options || {};
          this.p = options.prefix ? _checkPropPrefix(p) || p : p;
          _specialProps[p] = _specialProps[this.p] = this;
          this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
          if (options.parser) {
            this.parse = options.parser;
          }
          this.clrs = options.color;
          this.multi = options.multi;
          this.keyword = options.keyword;
          this.dflt = options.defaultValue;
          this.pr = options.priority || 0;
        },
            _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
              if (typeof(options) !== "object") {
                options = {parser: defaults};
              }
              var a = p.split(","),
                  d = options.defaultValue,
                  i,
                  temp;
              defaults = defaults || [d];
              for (i = 0; i < a.length; i++) {
                options.prefix = (i === 0 && options.prefix);
                options.defaultValue = defaults[i] || d;
                temp = new SpecialProp(a[i], options);
              }
            },
            _registerPluginProp = function(p) {
              if (!_specialProps[p]) {
                var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
                _registerComplexSpecialProp(p, {parser: function(t, e, p, cssp, pt, plugin, vars) {
                    var pluginClass = _globals.com.greensock.plugins[pluginName];
                    if (!pluginClass) {
                      _log("Error: " + pluginName + " js file not loaded.");
                      return pt;
                    }
                    pluginClass._cssRegister();
                    return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
                  }});
              }
            };
        p = SpecialProp.prototype;
        p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
          var kwd = this.keyword,
              i,
              ba,
              ea,
              l,
              bi,
              ei;
          if (this.multi)
            if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
              ba = b.replace(_commasOutsideParenExp, "|").split("|");
              ea = e.replace(_commasOutsideParenExp, "|").split("|");
            } else if (kwd) {
              ba = [b];
              ea = [e];
            }
          if (ea) {
            l = (ea.length > ba.length) ? ea.length : ba.length;
            for (i = 0; i < l; i++) {
              b = ba[i] = ba[i] || this.dflt;
              e = ea[i] = ea[i] || this.dflt;
              if (kwd) {
                bi = b.indexOf(kwd);
                ei = e.indexOf(kwd);
                if (bi !== ei) {
                  if (ei === -1) {
                    ba[i] = ba[i].split(kwd).join("");
                  } else if (bi === -1) {
                    ba[i] += " " + kwd;
                  }
                }
              }
            }
            b = ba.join(", ");
            e = ea.join(", ");
          }
          return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
        };
        p.parse = function(t, e, p, cssp, pt, plugin, vars) {
          return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
        };
        CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
          _registerComplexSpecialProp(name, {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
              var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
              rv.plugin = plugin;
              rv.setRatio = onInitTween(t, e, cssp._tween, p);
              return rv;
            },
            priority: priority
          });
        };
        CSSPlugin.useSVGTransformAttr = _isSafari || _isFirefox;
        var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
            _transformProp = _checkPropPrefix("transform"),
            _transformPropCSS = _prefixCSS + "transform",
            _transformOriginProp = _checkPropPrefix("transformOrigin"),
            _supports3D = (_checkPropPrefix("perspective") !== null),
            Transform = _internals.Transform = function() {
              this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
              this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
            },
            _SVGElement = window.SVGElement,
            _useSVGTransformAttr,
            _createSVG = function(type, container, attributes) {
              var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
                  reg = /([a-z])([A-Z])/g,
                  p;
              for (p in attributes) {
                element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
              }
              container.appendChild(element);
              return element;
            },
            _docElement = _doc.documentElement,
            _forceSVGTransformAttr = (function() {
              var force = _ieVers || (/Android/i.test(_agent) && !window.chrome),
                  svg,
                  rect,
                  width;
              if (_doc.createElementNS && !force) {
                svg = _createSVG("svg", _docElement);
                rect = _createSVG("rect", svg, {
                  width: 100,
                  height: 50,
                  x: 100
                });
                width = rect.getBoundingClientRect().width;
                rect.style[_transformOriginProp] = "50% 50%";
                rect.style[_transformProp] = "scaleX(0.5)";
                force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D));
                _docElement.removeChild(svg);
              }
              return force;
            })(),
            _parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin) {
              var tm = e._gsTransform,
                  m = _getMatrix(e, true),
                  v,
                  x,
                  y,
                  xOrigin,
                  yOrigin,
                  a,
                  b,
                  c,
                  d,
                  tx,
                  ty,
                  determinant,
                  xOriginOld,
                  yOriginOld;
              if (tm) {
                xOriginOld = tm.xOrigin;
                yOriginOld = tm.yOrigin;
              }
              if (!absolute || (v = absolute.split(" ")).length < 2) {
                b = e.getBBox();
                local = _parsePosition(local).split(" ");
                v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
              }
              decoratee.xOrigin = xOrigin = parseFloat(v[0]);
              decoratee.yOrigin = yOrigin = parseFloat(v[1]);
              if (absolute && m !== _identity2DMatrix) {
                a = m[0];
                b = m[1];
                c = m[2];
                d = m[3];
                tx = m[4];
                ty = m[5];
                determinant = (a * d - b * c);
                x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
                y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
                xOrigin = decoratee.xOrigin = v[0] = x;
                yOrigin = decoratee.yOrigin = v[1] = y;
              }
              if (tm) {
                if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
                  x = xOrigin - xOriginOld;
                  y = yOrigin - yOriginOld;
                  tm.xOffset += (x * m[0] + y * m[2]) - x;
                  tm.yOffset += (x * m[1] + y * m[3]) - y;
                } else {
                  tm.xOffset = tm.yOffset = 0;
                }
              }
              e.setAttribute("data-svg-origin", v.join(" "));
            },
            _isSVG = function(e) {
              return !!(_SVGElement && typeof(e.getBBox) === "function" && e.getCTM && (!e.parentNode || (e.parentNode.getBBox && e.parentNode.getCTM)));
            },
            _identity2DMatrix = [1, 0, 0, 1, 0, 0],
            _getMatrix = function(e, force2D) {
              var tm = e._gsTransform || new Transform(),
                  rnd = 100000,
                  isDefault,
                  s,
                  m,
                  n,
                  dec;
              if (_transformProp) {
                s = _getStyle(e, _transformPropCSS, null, true);
              } else if (e.currentStyle) {
                s = e.currentStyle.filter.match(_ieGetMatrixExp);
                s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
              }
              isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
              if (tm.svg || (e.getBBox && _isSVG(e))) {
                if (isDefault && (e.style[_transformProp] + "").indexOf("matrix") !== -1) {
                  s = e.style[_transformProp];
                  isDefault = 0;
                }
                m = e.getAttribute("transform");
                if (isDefault && m) {
                  if (m.indexOf("matrix") !== -1) {
                    s = m;
                    isDefault = 0;
                  } else if (m.indexOf("translate") !== -1) {
                    s = "matrix(1,0,0,1," + m.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")";
                    isDefault = 0;
                  }
                }
              }
              if (isDefault) {
                return _identity2DMatrix;
              }
              m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [];
              i = m.length;
              while (--i > -1) {
                n = Number(m[i]);
                m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n;
              }
              return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
            },
            _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
              if (t._gsTransform && rec && !parse) {
                return t._gsTransform;
              }
              var tm = rec ? t._gsTransform || new Transform() : new Transform(),
                  invX = (tm.scaleX < 0),
                  min = 0.00002,
                  rnd = 100000,
                  zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
                  defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
                  m,
                  i,
                  scaleX,
                  scaleY,
                  rotation,
                  skewX;
              tm.svg = !!(t.getBBox && _isSVG(t));
              if (tm.svg) {
                _parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
                _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
              }
              m = _getMatrix(t);
              if (m !== _identity2DMatrix) {
                if (m.length === 16) {
                  var a11 = m[0],
                      a21 = m[1],
                      a31 = m[2],
                      a41 = m[3],
                      a12 = m[4],
                      a22 = m[5],
                      a32 = m[6],
                      a42 = m[7],
                      a13 = m[8],
                      a23 = m[9],
                      a33 = m[10],
                      a14 = m[12],
                      a24 = m[13],
                      a34 = m[14],
                      a43 = m[11],
                      angle = Math.atan2(a32, a33),
                      t1,
                      t2,
                      t3,
                      t4,
                      cos,
                      sin;
                  if (tm.zOrigin) {
                    a34 = -tm.zOrigin;
                    a14 = a13 * a34 - m[12];
                    a24 = a23 * a34 - m[13];
                    a34 = a33 * a34 + tm.zOrigin - m[14];
                  }
                  tm.rotationX = angle * _RAD2DEG;
                  if (angle) {
                    cos = Math.cos(-angle);
                    sin = Math.sin(-angle);
                    t1 = a12 * cos + a13 * sin;
                    t2 = a22 * cos + a23 * sin;
                    t3 = a32 * cos + a33 * sin;
                    a13 = a12 * -sin + a13 * cos;
                    a23 = a22 * -sin + a23 * cos;
                    a33 = a32 * -sin + a33 * cos;
                    a43 = a42 * -sin + a43 * cos;
                    a12 = t1;
                    a22 = t2;
                    a32 = t3;
                  }
                  angle = Math.atan2(-a31, a33);
                  tm.rotationY = angle * _RAD2DEG;
                  if (angle) {
                    cos = Math.cos(-angle);
                    sin = Math.sin(-angle);
                    t1 = a11 * cos - a13 * sin;
                    t2 = a21 * cos - a23 * sin;
                    t3 = a31 * cos - a33 * sin;
                    a23 = a21 * sin + a23 * cos;
                    a33 = a31 * sin + a33 * cos;
                    a43 = a41 * sin + a43 * cos;
                    a11 = t1;
                    a21 = t2;
                    a31 = t3;
                  }
                  angle = Math.atan2(a21, a11);
                  tm.rotation = angle * _RAD2DEG;
                  if (angle) {
                    cos = Math.cos(-angle);
                    sin = Math.sin(-angle);
                    a11 = a11 * cos + a12 * sin;
                    t2 = a21 * cos + a22 * sin;
                    a22 = a21 * -sin + a22 * cos;
                    a32 = a31 * -sin + a32 * cos;
                    a21 = t2;
                  }
                  if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
                    tm.rotationX = tm.rotation = 0;
                    tm.rotationY = 180 - tm.rotationY;
                  }
                  tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5) | 0) / rnd;
                  tm.scaleY = ((Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5) | 0) / rnd;
                  tm.scaleZ = ((Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5) | 0) / rnd;
                  tm.skewX = 0;
                  tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
                  tm.x = a14;
                  tm.y = a24;
                  tm.z = a34;
                  if (tm.svg) {
                    tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
                    tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
                  }
                } else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY)) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) {
                  var k = (m.length >= 6),
                      a = k ? m[0] : 1,
                      b = m[1] || 0,
                      c = m[2] || 0,
                      d = k ? m[3] : 1;
                  tm.x = m[4] || 0;
                  tm.y = m[5] || 0;
                  scaleX = Math.sqrt(a * a + b * b);
                  scaleY = Math.sqrt(d * d + c * c);
                  rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0;
                  skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
                  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
                    if (invX) {
                      scaleX *= -1;
                      skewX += (rotation <= 0) ? 180 : -180;
                      rotation += (rotation <= 0) ? 180 : -180;
                    } else {
                      scaleY *= -1;
                      skewX += (skewX <= 0) ? 180 : -180;
                    }
                  }
                  tm.scaleX = scaleX;
                  tm.scaleY = scaleY;
                  tm.rotation = rotation;
                  tm.skewX = skewX;
                  if (_supports3D) {
                    tm.rotationX = tm.rotationY = tm.z = 0;
                    tm.perspective = defaultTransformPerspective;
                    tm.scaleZ = 1;
                  }
                  if (tm.svg) {
                    tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
                    tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
                  }
                }
                tm.zOrigin = zOrigin;
                for (i in tm) {
                  if (tm[i] < min)
                    if (tm[i] > -min) {
                      tm[i] = 0;
                    }
                }
              }
              if (rec) {
                t._gsTransform = tm;
                if (tm.svg) {
                  if (_useSVGTransformAttr && t.style[_transformProp]) {
                    TweenLite.delayedCall(0.001, function() {
                      _removeProp(t.style, _transformProp);
                    });
                  } else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
                    TweenLite.delayedCall(0.001, function() {
                      t.removeAttribute("transform");
                    });
                  }
                }
              }
              return tm;
            },
            _setIETransformRatio = function(v) {
              var t = this.data,
                  ang = -t.rotation * _DEG2RAD,
                  skew = ang + t.skewX * _DEG2RAD,
                  rnd = 100000,
                  a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
                  b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
                  c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
                  d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
                  style = this.t.style,
                  cs = this.t.currentStyle,
                  filters,
                  val;
              if (!cs) {
                return;
              }
              val = b;
              b = -c;
              c = -val;
              filters = cs.filter;
              style.filter = "";
              var w = this.t.offsetWidth,
                  h = this.t.offsetHeight,
                  clip = (cs.position !== "absolute"),
                  m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
                  ox = t.x + (w * t.xPercent / 100),
                  oy = t.y + (h * t.yPercent / 100),
                  dx,
                  dy;
              if (t.ox != null) {
                dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
                dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
                ox += dx - (dx * a + dy * b);
                oy += dy - (dx * c + dy * d);
              }
              if (!clip) {
                m += ", sizingMethod='auto expand')";
              } else {
                dx = (w / 2);
                dy = (h / 2);
                m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
              }
              if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
                style.filter = filters.replace(_ieSetMatrixExp, m);
              } else {
                style.filter = m + " " + filters;
              }
              if (v === 0 || v === 1)
                if (a === 1)
                  if (b === 0)
                    if (c === 0)
                      if (d === 1)
                        if (!clip || m.indexOf("Dx=0, Dy=0") !== -1)
                          if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100)
                            if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
                              style.removeAttribute("filter");
                            }
              if (!clip) {
                var mult = (_ieVers < 8) ? 1 : -1,
                    marg,
                    prop,
                    dif;
                dx = t.ieOffsetX || 0;
                dy = t.ieOffsetY || 0;
                t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
                t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
                for (i = 0; i < 4; i++) {
                  prop = _margins[i];
                  marg = cs[prop];
                  val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
                  if (val !== t[prop]) {
                    dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY;
                  } else {
                    dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
                  }
                  style[prop] = (t[prop] = Math.round(val - dif * ((i === 0 || i === 2) ? 1 : mult))) + "px";
                }
              }
            },
            _setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
              var t = this.data,
                  style = this.t.style,
                  angle = t.rotation,
                  rotationX = t.rotationX,
                  rotationY = t.rotationY,
                  sx = t.scaleX,
                  sy = t.scaleY,
                  sz = t.scaleZ,
                  x = t.x,
                  y = t.y,
                  z = t.z,
                  isSVG = t.svg,
                  perspective = t.perspective,
                  force3D = t.force3D,
                  a11,
                  a12,
                  a13,
                  a21,
                  a22,
                  a23,
                  a31,
                  a32,
                  a33,
                  a41,
                  a42,
                  a43,
                  zOrigin,
                  min,
                  cos,
                  sin,
                  t1,
                  t2,
                  transform,
                  comma,
                  zero,
                  skew,
                  rnd;
              if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) {
                if (angle || t.skewX || isSVG) {
                  angle *= _DEG2RAD;
                  skew = t.skewX * _DEG2RAD;
                  rnd = 100000;
                  a11 = Math.cos(angle) * sx;
                  a21 = Math.sin(angle) * sx;
                  a12 = Math.sin(angle - skew) * -sy;
                  a22 = Math.cos(angle - skew) * sy;
                  if (skew && t.skewType === "simple") {
                    t1 = Math.tan(skew);
                    t1 = Math.sqrt(1 + t1 * t1);
                    a12 *= t1;
                    a22 *= t1;
                    if (t.skewY) {
                      a11 *= t1;
                      a21 *= t1;
                    }
                  }
                  if (isSVG) {
                    x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
                    y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
                    if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
                      min = this.t.getBBox();
                      x += t.xPercent * 0.01 * min.width;
                      y += t.yPercent * 0.01 * min.height;
                    }
                    min = 0.000001;
                    if (x < min)
                      if (x > -min) {
                        x = 0;
                      }
                    if (y < min)
                      if (y > -min) {
                        y = 0;
                      }
                  }
                  transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
                  if (isSVG && _useSVGTransformAttr) {
                    this.t.setAttribute("transform", "matrix(" + transform);
                  } else {
                    style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
                  }
                } else {
                  style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
                }
                return;
              }
              if (_isFirefox) {
                min = 0.0001;
                if (sx < min && sx > -min) {
                  sx = sz = 0.00002;
                }
                if (sy < min && sy > -min) {
                  sy = sz = 0.00002;
                }
                if (perspective && !t.z && !t.rotationX && !t.rotationY) {
                  perspective = 0;
                }
              }
              if (angle || t.skewX) {
                angle *= _DEG2RAD;
                cos = a11 = Math.cos(angle);
                sin = a21 = Math.sin(angle);
                if (t.skewX) {
                  angle -= t.skewX * _DEG2RAD;
                  cos = Math.cos(angle);
                  sin = Math.sin(angle);
                  if (t.skewType === "simple") {
                    t1 = Math.tan(t.skewX * _DEG2RAD);
                    t1 = Math.sqrt(1 + t1 * t1);
                    cos *= t1;
                    sin *= t1;
                    if (t.skewY) {
                      a11 *= t1;
                      a21 *= t1;
                    }
                  }
                }
                a12 = -sin;
                a22 = cos;
              } else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
                style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
                return;
              } else {
                a11 = a22 = 1;
                a12 = a21 = 0;
              }
              a33 = 1;
              a13 = a23 = a31 = a32 = a41 = a42 = 0;
              a43 = (perspective) ? -1 / perspective : 0;
              zOrigin = t.zOrigin;
              min = 0.000001;
              comma = ",";
              zero = "0";
              angle = rotationY * _DEG2RAD;
              if (angle) {
                cos = Math.cos(angle);
                sin = Math.sin(angle);
                a31 = -sin;
                a41 = a43 * -sin;
                a13 = a11 * sin;
                a23 = a21 * sin;
                a33 = cos;
                a43 *= cos;
                a11 *= cos;
                a21 *= cos;
              }
              angle = rotationX * _DEG2RAD;
              if (angle) {
                cos = Math.cos(angle);
                sin = Math.sin(angle);
                t1 = a12 * cos + a13 * sin;
                t2 = a22 * cos + a23 * sin;
                a32 = a33 * sin;
                a42 = a43 * sin;
                a13 = a12 * -sin + a13 * cos;
                a23 = a22 * -sin + a23 * cos;
                a33 = a33 * cos;
                a43 = a43 * cos;
                a12 = t1;
                a22 = t2;
              }
              if (sz !== 1) {
                a13 *= sz;
                a23 *= sz;
                a33 *= sz;
                a43 *= sz;
              }
              if (sy !== 1) {
                a12 *= sy;
                a22 *= sy;
                a32 *= sy;
                a42 *= sy;
              }
              if (sx !== 1) {
                a11 *= sx;
                a21 *= sx;
                a31 *= sx;
                a41 *= sx;
              }
              if (zOrigin || isSVG) {
                if (zOrigin) {
                  x += a13 * -zOrigin;
                  y += a23 * -zOrigin;
                  z += a33 * -zOrigin + zOrigin;
                }
                if (isSVG) {
                  x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
                  y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
                }
                if (x < min && x > -min) {
                  x = zero;
                }
                if (y < min && y > -min) {
                  y = zero;
                }
                if (z < min && z > -min) {
                  z = 0;
                }
              }
              transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
              transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
              transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
              if (rotationX || rotationY || sz !== 1) {
                transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
                transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
              } else {
                transform += ",0,0,0,0,1,0,";
              }
              transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";
              style[_transformProp] = transform;
            };
        p = Transform.prototype;
        p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
        p.scaleX = p.scaleY = p.scaleZ = 1;
        _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
          parser: function(t, e, p, cssp, pt, plugin, vars) {
            if (cssp._lastParsedTransform === vars) {
              return pt;
            }
            cssp._lastParsedTransform = vars;
            var originalGSTransform = t._gsTransform,
                style = t.style,
                min = 0.000001,
                i = _transformProps.length,
                v = vars,
                endRotations = {},
                transformOriginString = "transformOrigin",
                m1,
                m2,
                skewY,
                copy,
                orig,
                has3D,
                hasChange,
                dr,
                x,
                y;
            if (vars.display) {
              copy = _getStyle(t, "display");
              style.display = "block";
              m1 = _getTransform(t, _cs, true, vars.parseTransform);
              style.display = copy;
            } else {
              m1 = _getTransform(t, _cs, true, vars.parseTransform);
            }
            cssp._transform = m1;
            if (typeof(v.transform) === "string" && _transformProp) {
              copy = _tempDiv.style;
              copy[_transformProp] = v.transform;
              copy.display = "block";
              copy.position = "absolute";
              _doc.body.appendChild(_tempDiv);
              m2 = _getTransform(_tempDiv, null, false);
              _doc.body.removeChild(_tempDiv);
              if (!m2.perspective) {
                m2.perspective = m1.perspective;
              }
              if (v.xPercent != null) {
                m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
              }
              if (v.yPercent != null) {
                m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
              }
            } else if (typeof(v) === "object") {
              m2 = {
                scaleX: _parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
                scaleY: _parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
                scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                x: _parseVal(v.x, m1.x),
                y: _parseVal(v.y, m1.y),
                z: _parseVal(v.z, m1.z),
                xPercent: _parseVal(v.xPercent, m1.xPercent),
                yPercent: _parseVal(v.yPercent, m1.yPercent),
                perspective: _parseVal(v.transformPerspective, m1.perspective)
              };
              dr = v.directionalRotation;
              if (dr != null) {
                if (typeof(dr) === "object") {
                  for (copy in dr) {
                    v[copy] = dr[copy];
                  }
                } else {
                  v.rotation = dr;
                }
              }
              if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
                m2.x = 0;
                m2.xPercent = _parseVal(v.x, m1.xPercent);
              }
              if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
                m2.y = 0;
                m2.yPercent = _parseVal(v.y, m1.yPercent);
              }
              m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
              if (_supports3D) {
                m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
                m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
              }
              m2.skewX = (v.skewX == null) ? m1.skewX : _parseAngle(v.skewX, m1.skewX);
              m2.skewY = (v.skewY == null) ? m1.skewY : _parseAngle(v.skewY, m1.skewY);
              if ((skewY = m2.skewY - m1.skewY)) {
                m2.skewX += skewY;
                m2.rotation += skewY;
              }
            }
            if (_supports3D && v.force3D != null) {
              m1.force3D = v.force3D;
              hasChange = true;
            }
            m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
            has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
            if (!has3D && v.scale != null) {
              m2.scaleZ = 1;
            }
            while (--i > -1) {
              p = _transformProps[i];
              orig = m2[p] - m1[p];
              if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
                hasChange = true;
                pt = new CSSPropTween(m1, p, m1[p], orig, pt);
                if (p in endRotations) {
                  pt.e = endRotations[p];
                }
                pt.xs0 = 0;
                pt.plugin = plugin;
                cssp._overwriteProps.push(pt.n);
              }
            }
            orig = v.transformOrigin;
            if (m1.svg && (orig || v.svgOrigin)) {
              x = m1.xOffset;
              y = m1.yOffset;
              _parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
              pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString);
              pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
              if (x !== m1.xOffset || y !== m1.yOffset) {
                pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
                pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
              }
              orig = _useSVGTransformAttr ? null : "0px 0px";
            }
            if (orig || (_supports3D && has3D && m1.zOrigin)) {
              if (_transformProp) {
                hasChange = true;
                p = _transformOriginProp;
                orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + "";
                pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
                pt.b = style[p];
                pt.plugin = plugin;
                if (_supports3D) {
                  copy = m1.zOrigin;
                  orig = orig.split(" ");
                  m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0;
                  pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px";
                  pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n);
                  pt.b = copy;
                  pt.xs0 = pt.e = m1.zOrigin;
                } else {
                  pt.xs0 = pt.e = orig;
                }
              } else {
                _parsePosition(orig + "", m1);
              }
            }
            if (hasChange) {
              cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2;
            }
            return pt;
          },
          prefix: true
        });
        _registerComplexSpecialProp("boxShadow", {
          defaultValue: "0px 0px 0px 0px #999",
          prefix: true,
          color: true,
          multi: true,
          keyword: "inset"
        });
        _registerComplexSpecialProp("borderRadius", {
          defaultValue: "0px",
          parser: function(t, e, p, cssp, pt, plugin) {
            e = this.format(e);
            var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                style = t.style,
                ea1,
                i,
                es2,
                bs2,
                bs,
                es,
                bn,
                en,
                w,
                h,
                esfx,
                bsfx,
                rel,
                hn,
                vn,
                em;
            w = parseFloat(t.offsetWidth);
            h = parseFloat(t.offsetHeight);
            ea1 = e.split(" ");
            for (i = 0; i < props.length; i++) {
              if (this.p.indexOf("border")) {
                props[i] = _checkPropPrefix(props[i]);
              }
              bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
              if (bs.indexOf(" ") !== -1) {
                bs2 = bs.split(" ");
                bs = bs2[0];
                bs2 = bs2[1];
              }
              es = es2 = ea1[i];
              bn = parseFloat(bs);
              bsfx = bs.substr((bn + "").length);
              rel = (es.charAt(1) === "=");
              if (rel) {
                en = parseInt(es.charAt(0) + "1", 10);
                es = es.substr(2);
                en *= parseFloat(es);
                esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
              } else {
                en = parseFloat(es);
                esfx = es.substr((en + "").length);
              }
              if (esfx === "") {
                esfx = _suffixMap[p] || bsfx;
              }
              if (esfx !== bsfx) {
                hn = _convertToPixels(t, "borderLeft", bn, bsfx);
                vn = _convertToPixels(t, "borderTop", bn, bsfx);
                if (esfx === "%") {
                  bs = (hn / w * 100) + "%";
                  bs2 = (vn / h * 100) + "%";
                } else if (esfx === "em") {
                  em = _convertToPixels(t, "borderLeft", 1, "em");
                  bs = (hn / em) + "em";
                  bs2 = (vn / em) + "em";
                } else {
                  bs = hn + "px";
                  bs2 = vn + "px";
                }
                if (rel) {
                  es = (parseFloat(bs) + en) + esfx;
                  es2 = (parseFloat(bs2) + en) + esfx;
                }
              }
              pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
            }
            return pt;
          },
          prefix: true,
          formatter: _getFormatter("0px 0px 0px 0px", false, true)
        });
        _registerComplexSpecialProp("backgroundPosition", {
          defaultValue: "0 0",
          parser: function(t, e, p, cssp, pt, plugin) {
            var bp = "background-position",
                cs = (_cs || _getComputedStyle(t, null)),
                bs = this.format(((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                es = this.format(e),
                ba,
                ea,
                i,
                pct,
                overlap,
                src;
            if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1)) {
              src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
              if (src && src !== "none") {
                ba = bs.split(" ");
                ea = es.split(" ");
                _tempImg.setAttribute("src", src);
                i = 2;
                while (--i > -1) {
                  bs = ba[i];
                  pct = (bs.indexOf("%") !== -1);
                  if (pct !== (ea[i].indexOf("%") !== -1)) {
                    overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
                    ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
                  }
                }
                bs = ba.join(" ");
              }
            }
            return this.parseComplex(t.style, bs, es, pt, plugin);
          },
          formatter: _parsePosition
        });
        _registerComplexSpecialProp("backgroundSize", {
          defaultValue: "0 0",
          formatter: _parsePosition
        });
        _registerComplexSpecialProp("perspective", {
          defaultValue: "0px",
          prefix: true
        });
        _registerComplexSpecialProp("perspectiveOrigin", {
          defaultValue: "50% 50%",
          prefix: true
        });
        _registerComplexSpecialProp("transformStyle", {prefix: true});
        _registerComplexSpecialProp("backfaceVisibility", {prefix: true});
        _registerComplexSpecialProp("userSelect", {prefix: true});
        _registerComplexSpecialProp("margin", {parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
        _registerComplexSpecialProp("padding", {parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
        _registerComplexSpecialProp("clip", {
          defaultValue: "rect(0px,0px,0px,0px)",
          parser: function(t, e, p, cssp, pt, plugin) {
            var b,
                cs,
                delim;
            if (_ieVers < 9) {
              cs = t.currentStyle;
              delim = _ieVers < 8 ? " " : ",";
              b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
              e = this.format(e).split(",").join(delim);
            } else {
              b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
              e = this.format(e);
            }
            return this.parseComplex(t.style, b, e, pt, plugin);
          }
        });
        _registerComplexSpecialProp("textShadow", {
          defaultValue: "0px 0px 0px #999",
          color: true,
          multi: true
        });
        _registerComplexSpecialProp("autoRound,strictUnits", {parser: function(t, e, p, cssp, pt) {
            return pt;
          }});
        _registerComplexSpecialProp("border", {
          defaultValue: "0px solid #000",
          parser: function(t, e, p, cssp, pt, plugin) {
            return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
          },
          color: true,
          formatter: function(v) {
            var a = v.split(" ");
            return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
          }
        });
        _registerComplexSpecialProp("borderWidth", {parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")});
        _registerComplexSpecialProp("float,cssFloat,styleFloat", {parser: function(t, e, p, cssp, pt, plugin) {
            var s = t.style,
                prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
            return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
          }});
        var _setIEOpacityRatio = function(v) {
          var t = this.t,
              filters = t.filter || _getStyle(this.data, "filter") || "",
              val = (this.s + this.c * v) | 0,
              skip;
          if (val === 100) {
            if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
              t.removeAttribute("filter");
              skip = (!_getStyle(this.data, "filter"));
            } else {
              t.filter = filters.replace(_alphaFilterExp, "");
              skip = true;
            }
          }
          if (!skip) {
            if (this.xn1) {
              t.filter = filters = filters || ("alpha(opacity=" + val + ")");
            }
            if (filters.indexOf("pacity") === -1) {
              if (val !== 0 || !this.xn1) {
                t.filter = filters + " alpha(opacity=" + val + ")";
              }
            } else {
              t.filter = filters.replace(_opacityExp, "opacity=" + val);
            }
          }
        };
        _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
          defaultValue: "1",
          parser: function(t, e, p, cssp, pt, plugin) {
            var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
                style = t.style,
                isAutoAlpha = (p === "autoAlpha");
            if (typeof(e) === "string" && e.charAt(1) === "=") {
              e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
            }
            if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
              b = 0;
            }
            if (_supportsOpacity) {
              pt = new CSSPropTween(style, "opacity", b, e - b, pt);
            } else {
              pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
              pt.xn1 = isAutoAlpha ? 1 : 0;
              style.zoom = 1;
              pt.type = 2;
              pt.b = "alpha(opacity=" + pt.s + ")";
              pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
              pt.data = t;
              pt.plugin = plugin;
              pt.setRatio = _setIEOpacityRatio;
            }
            if (isAutoAlpha) {
              pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
              pt.xs0 = "inherit";
              cssp._overwriteProps.push(pt.n);
              cssp._overwriteProps.push(p);
            }
            return pt;
          }
        });
        var _removeProp = function(s, p) {
          if (p) {
            if (s.removeProperty) {
              if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
                p = "-" + p;
              }
              s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
            } else {
              s.removeAttribute(p);
            }
          }
        },
            _setClassNameRatio = function(v) {
              this.t._gsClassPT = this;
              if (v === 1 || v === 0) {
                this.t.setAttribute("class", (v === 0) ? this.b : this.e);
                var mpt = this.data,
                    s = this.t.style;
                while (mpt) {
                  if (!mpt.v) {
                    _removeProp(s, mpt.p);
                  } else {
                    s[mpt.p] = mpt.v;
                  }
                  mpt = mpt._next;
                }
                if (v === 1 && this.t._gsClassPT === this) {
                  this.t._gsClassPT = null;
                }
              } else if (this.t.getAttribute("class") !== this.e) {
                this.t.setAttribute("class", this.e);
              }
            };
        _registerComplexSpecialProp("className", {parser: function(t, e, p, cssp, pt, plugin, vars) {
            var b = t.getAttribute("class") || "",
                cssText = t.style.cssText,
                difData,
                bs,
                cnpt,
                cnptLookup,
                mpt;
            pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
            pt.setRatio = _setClassNameRatio;
            pt.pr = -11;
            _hasPriority = true;
            pt.b = b;
            bs = _getAllStyles(t, _cs);
            cnpt = t._gsClassPT;
            if (cnpt) {
              cnptLookup = {};
              mpt = cnpt.data;
              while (mpt) {
                cnptLookup[mpt.p] = 1;
                mpt = mpt._next;
              }
              cnpt.setRatio(1);
            }
            t._gsClassPT = pt;
            pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
            t.setAttribute("class", pt.e);
            difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
            t.setAttribute("class", b);
            pt.data = difData.firstMPT;
            t.style.cssText = cssText;
            pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin);
            return pt;
          }});
        var _setClearPropsRatio = function(v) {
          if (v === 1 || v === 0)
            if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
              var s = this.t.style,
                  transformParse = _specialProps.transform.parse,
                  a,
                  p,
                  i,
                  clearTransform,
                  transform;
              if (this.e === "all") {
                s.cssText = "";
                clearTransform = true;
              } else {
                a = this.e.split(" ").join("").split(",");
                i = a.length;
                while (--i > -1) {
                  p = a[i];
                  if (_specialProps[p]) {
                    if (_specialProps[p].parse === transformParse) {
                      clearTransform = true;
                    } else {
                      p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p;
                    }
                  }
                  _removeProp(s, p);
                }
              }
              if (clearTransform) {
                _removeProp(s, _transformProp);
                transform = this.t._gsTransform;
                if (transform) {
                  if (transform.svg) {
                    this.t.removeAttribute("data-svg-origin");
                    this.t.removeAttribute("transform");
                  }
                  delete this.t._gsTransform;
                }
              }
            }
        };
        _registerComplexSpecialProp("clearProps", {parser: function(t, e, p, cssp, pt) {
            pt = new CSSPropTween(t, p, 0, 0, pt, 2);
            pt.setRatio = _setClearPropsRatio;
            pt.e = e;
            pt.pr = -10;
            pt.data = cssp._tween;
            _hasPriority = true;
            return pt;
          }});
        p = "bezier,throwProps,physicsProps,physics2D".split(",");
        i = p.length;
        while (i--) {
          _registerPluginProp(p[i]);
        }
        p = CSSPlugin.prototype;
        p._firstPT = p._lastParsedTransform = p._transform = null;
        p._onInitTween = function(target, vars, tween) {
          if (!target.nodeType) {
            return false;
          }
          this._target = target;
          this._tween = tween;
          this._vars = vars;
          _autoRound = vars.autoRound;
          _hasPriority = false;
          _suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
          _cs = _getComputedStyle(target, "");
          _overwriteProps = this._overwriteProps;
          var style = target.style,
              v,
              pt,
              pt2,
              first,
              last,
              next,
              zIndex,
              tpt,
              threeD;
          if (_reqSafariFix)
            if (style.zIndex === "") {
              v = _getStyle(target, "zIndex", _cs);
              if (v === "auto" || v === "") {
                this._addLazySet(style, "zIndex", 0);
              }
            }
          if (typeof(vars) === "string") {
            first = style.cssText;
            v = _getAllStyles(target, _cs);
            style.cssText = first + ";" + vars;
            v = _cssDif(target, v, _getAllStyles(target)).difs;
            if (!_supportsOpacity && _opacityValExp.test(vars)) {
              v.opacity = parseFloat(RegExp.$1);
            }
            vars = v;
            style.cssText = first;
          }
          if (vars.className) {
            this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
          } else {
            this._firstPT = pt = this.parse(target, vars, null);
          }
          if (this._transformType) {
            threeD = (this._transformType === 3);
            if (!_transformProp) {
              style.zoom = 1;
            } else if (_isSafari) {
              _reqSafariFix = true;
              if (style.zIndex === "") {
                zIndex = _getStyle(target, "zIndex", _cs);
                if (zIndex === "auto" || zIndex === "") {
                  this._addLazySet(style, "zIndex", 0);
                }
              }
              if (_isSafariLT6) {
                this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
              }
            }
            pt2 = pt;
            while (pt2 && pt2._next) {
              pt2 = pt2._next;
            }
            tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
            this._linkCSSP(tpt, null, pt2);
            tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
            tpt.data = this._transform || _getTransform(target, _cs, true);
            tpt.tween = tween;
            tpt.pr = -1;
            _overwriteProps.pop();
          }
          if (_hasPriority) {
            while (pt) {
              next = pt._next;
              pt2 = first;
              while (pt2 && pt2.pr > pt.pr) {
                pt2 = pt2._next;
              }
              if ((pt._prev = pt2 ? pt2._prev : last)) {
                pt._prev._next = pt;
              } else {
                first = pt;
              }
              if ((pt._next = pt2)) {
                pt2._prev = pt;
              } else {
                last = pt;
              }
              pt = next;
            }
            this._firstPT = first;
          }
          return true;
        };
        p.parse = function(target, vars, pt, plugin) {
          var style = target.style,
              p,
              sp,
              bn,
              en,
              bs,
              es,
              bsfx,
              esfx,
              isStr,
              rel;
          for (p in vars) {
            es = vars[p];
            sp = _specialProps[p];
            if (sp) {
              pt = sp.parse(target, es, p, this, pt, plugin, vars);
            } else {
              bs = _getStyle(target, p, _cs) + "";
              isStr = (typeof(es) === "string");
              if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) {
                if (!isStr) {
                  es = _parseColor(es);
                  es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
                }
                pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
              } else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {
                pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
              } else {
                bn = parseFloat(bs);
                bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : "";
                if (bs === "" || bs === "auto") {
                  if (p === "width" || p === "height") {
                    bn = _getDimension(target, p, _cs);
                    bsfx = "px";
                  } else if (p === "left" || p === "top") {
                    bn = _calculateOffset(target, p, _cs);
                    bsfx = "px";
                  } else {
                    bn = (p !== "opacity") ? 0 : 1;
                    bsfx = "";
                  }
                }
                rel = (isStr && es.charAt(1) === "=");
                if (rel) {
                  en = parseInt(es.charAt(0) + "1", 10);
                  es = es.substr(2);
                  en *= parseFloat(es);
                  esfx = es.replace(_suffixExp, "");
                } else {
                  en = parseFloat(es);
                  esfx = isStr ? es.replace(_suffixExp, "") : "";
                }
                if (esfx === "") {
                  esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx;
                }
                es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p];
                if (bsfx !== esfx)
                  if (esfx !== "")
                    if (en || en === 0)
                      if (bn) {
                        bn = _convertToPixels(target, p, bn, bsfx);
                        if (esfx === "%") {
                          bn /= _convertToPixels(target, p, 100, "%") / 100;
                          if (vars.strictUnits !== true) {
                            bs = bn + "%";
                          }
                        } else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
                          bn /= _convertToPixels(target, p, 1, esfx);
                        } else if (esfx !== "px") {
                          en = _convertToPixels(target, p, en, esfx);
                          esfx = "px";
                        }
                        if (rel)
                          if (en || en === 0) {
                            es = (en + bn) + esfx;
                          }
                      }
                if (rel) {
                  en += bn;
                }
                if ((bn || bn === 0) && (en || en === 0)) {
                  pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
                  pt.xs0 = esfx;
                } else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
                  _log("invalid " + p + " tween value: " + vars[p]);
                } else {
                  pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
                  pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es;
                }
              }
            }
            if (plugin)
              if (pt && !pt.plugin) {
                pt.plugin = plugin;
              }
          }
          return pt;
        };
        p.setRatio = function(v) {
          var pt = this._firstPT,
              min = 0.000001,
              val,
              str,
              i;
          if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
            while (pt) {
              if (pt.type !== 2) {
                if (pt.r && pt.type !== -1) {
                  val = Math.round(pt.s + pt.c);
                  if (!pt.type) {
                    pt.t[pt.p] = val + pt.xs0;
                  } else if (pt.type === 1) {
                    i = pt.l;
                    str = pt.xs0 + val + pt.xs1;
                    for (i = 1; i < pt.l; i++) {
                      str += pt["xn" + i] + pt["xs" + (i + 1)];
                    }
                    pt.t[pt.p] = str;
                  }
                } else {
                  pt.t[pt.p] = pt.e;
                }
              } else {
                pt.setRatio(v);
              }
              pt = pt._next;
            }
          } else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
            while (pt) {
              val = pt.c * v + pt.s;
              if (pt.r) {
                val = Math.round(val);
              } else if (val < min)
                if (val > -min) {
                  val = 0;
                }
              if (!pt.type) {
                pt.t[pt.p] = val + pt.xs0;
              } else if (pt.type === 1) {
                i = pt.l;
                if (i === 2) {
                  pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
                } else if (i === 3) {
                  pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
                } else if (i === 4) {
                  pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
                } else if (i === 5) {
                  pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
                } else {
                  str = pt.xs0 + val + pt.xs1;
                  for (i = 1; i < pt.l; i++) {
                    str += pt["xn" + i] + pt["xs" + (i + 1)];
                  }
                  pt.t[pt.p] = str;
                }
              } else if (pt.type === -1) {
                pt.t[pt.p] = pt.xs0;
              } else if (pt.setRatio) {
                pt.setRatio(v);
              }
              pt = pt._next;
            }
          } else {
            while (pt) {
              if (pt.type !== 2) {
                pt.t[pt.p] = pt.b;
              } else {
                pt.setRatio(v);
              }
              pt = pt._next;
            }
          }
        };
        p._enableTransforms = function(threeD) {
          this._transform = this._transform || _getTransform(this._target, _cs, true);
          this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
        };
        var lazySet = function(v) {
          this.t[this.p] = this.e;
          this.data._linkCSSP(this, this._next, null, true);
        };
        p._addLazySet = function(t, p, v) {
          var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
          pt.e = v;
          pt.setRatio = lazySet;
          pt.data = this;
        };
        p._linkCSSP = function(pt, next, prev, remove) {
          if (pt) {
            if (next) {
              next._prev = pt;
            }
            if (pt._next) {
              pt._next._prev = pt._prev;
            }
            if (pt._prev) {
              pt._prev._next = pt._next;
            } else if (this._firstPT === pt) {
              this._firstPT = pt._next;
              remove = true;
            }
            if (prev) {
              prev._next = pt;
            } else if (!remove && this._firstPT === null) {
              this._firstPT = pt;
            }
            pt._next = next;
            pt._prev = prev;
          }
          return pt;
        };
        p._kill = function(lookup) {
          var copy = lookup,
              pt,
              p,
              xfirst;
          if (lookup.autoAlpha || lookup.alpha) {
            copy = {};
            for (p in lookup) {
              copy[p] = lookup[p];
            }
            copy.opacity = 1;
            if (copy.autoAlpha) {
              copy.visibility = 1;
            }
          }
          if (lookup.className && (pt = this._classNamePT)) {
            xfirst = pt.xfirst;
            if (xfirst && xfirst._prev) {
              this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev);
            } else if (xfirst === this._firstPT) {
              this._firstPT = pt._next;
            }
            if (pt._next) {
              this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
            }
            this._classNamePT = null;
          }
          return TweenPlugin.prototype._kill.call(this, copy);
        };
        var _getChildStyles = function(e, props, targets) {
          var children,
              i,
              child,
              type;
          if (e.slice) {
            i = e.length;
            while (--i > -1) {
              _getChildStyles(e[i], props, targets);
            }
            return;
          }
          children = e.childNodes;
          i = children.length;
          while (--i > -1) {
            child = children[i];
            type = child.type;
            if (child.style) {
              props.push(_getAllStyles(child));
              if (targets) {
                targets.push(child);
              }
            }
            if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
              _getChildStyles(child, props, targets);
            }
          }
        };
        CSSPlugin.cascadeTo = function(target, duration, vars) {
          var tween = TweenLite.to(target, duration, vars),
              results = [tween],
              b = [],
              e = [],
              targets = [],
              _reservedProps = TweenLite._internals.reservedProps,
              i,
              difs,
              p,
              from;
          target = tween._targets || tween.target;
          _getChildStyles(target, b, targets);
          tween.render(duration, true, true);
          _getChildStyles(target, e);
          tween.render(0, true, true);
          tween._enabled(true);
          i = targets.length;
          while (--i > -1) {
            difs = _cssDif(targets[i], b[i], e[i]);
            if (difs.firstMPT) {
              difs = difs.difs;
              for (p in vars) {
                if (_reservedProps[p]) {
                  difs[p] = vars[p];
                }
              }
              from = {};
              for (p in difs) {
                from[p] = b[i][p];
              }
              results.push(TweenLite.fromTo(targets[i], duration, from, difs));
            }
          }
          return results;
        };
        TweenPlugin.activate([CSSPlugin]);
        return CSSPlugin;
      }, true);
      (function() {
        var RoundPropsPlugin = _gsScope._gsDefine.plugin({
          propName: "roundProps",
          version: "1.5",
          priority: -1,
          API: 2,
          init: function(target, value, tween) {
            this._tween = tween;
            return true;
          }
        }),
            _roundLinkedList = function(node) {
              while (node) {
                if (!node.f && !node.blob) {
                  node.r = 1;
                }
                node = node._next;
              }
            },
            p = RoundPropsPlugin.prototype;
        p._onInitAllProps = function() {
          var tween = this._tween,
              rp = (tween.vars.roundProps.join) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
              i = rp.length,
              lookup = {},
              rpt = tween._propLookup.roundProps,
              prop,
              pt,
              next;
          while (--i > -1) {
            lookup[rp[i]] = 1;
          }
          i = rp.length;
          while (--i > -1) {
            prop = rp[i];
            pt = tween._firstPT;
            while (pt) {
              next = pt._next;
              if (pt.pg) {
                pt.t._roundProps(lookup, true);
              } else if (pt.n === prop) {
                if (pt.f === 2 && pt.t) {
                  _roundLinkedList(pt.t._firstPT);
                } else {
                  this._add(pt.t, prop, pt.s, pt.c);
                  if (next) {
                    next._prev = pt._prev;
                  }
                  if (pt._prev) {
                    pt._prev._next = next;
                  } else if (tween._firstPT === pt) {
                    tween._firstPT = next;
                  }
                  pt._next = pt._prev = null;
                  tween._propLookup[prop] = rpt;
                }
              }
              pt = next;
            }
          }
          return false;
        };
        p._add = function(target, p, s, c) {
          this._addTween(target, p, s, s + c, p, true);
          this._overwriteProps.push(p);
        };
      }());
      (function() {
        _gsScope._gsDefine.plugin({
          propName: "attr",
          API: 2,
          version: "0.5.0",
          init: function(target, value, tween) {
            var p;
            if (typeof(target.setAttribute) !== "function") {
              return false;
            }
            for (p in value) {
              this._addTween(target, "setAttribute", target.getAttribute(p) + "", value[p] + "", p, false, p);
              this._overwriteProps.push(p);
            }
            return true;
          }
        });
      }());
      _gsScope._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.2.1",
        API: 2,
        init: function(target, value, tween) {
          if (typeof(value) !== "object") {
            value = {rotation: value};
          }
          this.finals = {};
          var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
              min = 0.000001,
              p,
              v,
              start,
              end,
              dif,
              split;
          for (p in value) {
            if (p !== "useRadians") {
              split = (value[p] + "").split("_");
              v = split[0];
              start = parseFloat((typeof(target[p]) !== "function") ? target[p] : target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))]());
              end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
              dif = end - start;
              if (split.length) {
                v = split.join("_");
                if (v.indexOf("short") !== -1) {
                  dif = dif % cap;
                  if (dif !== dif % (cap / 2)) {
                    dif = (dif < 0) ? dif + cap : dif - cap;
                  }
                }
                if (v.indexOf("_cw") !== -1 && dif < 0) {
                  dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                  dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                }
              }
              if (dif > min || dif < -min) {
                this._addTween(target, p, start, start + dif, p);
                this._overwriteProps.push(p);
              }
            }
          }
          return true;
        },
        set: function(ratio) {
          var pt;
          if (ratio !== 1) {
            this._super.setRatio.call(this, ratio);
          } else {
            pt = this._firstPT;
            while (pt) {
              if (pt.f) {
                pt.t[pt.p](this.finals[pt.p]);
              } else {
                pt.t[pt.p] = this.finals[pt.p];
              }
              pt = pt._next;
            }
          }
        }
      })._autoCSS = true;
      _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
        var w = (_gsScope.GreenSockGlobals || _gsScope),
            gs = w.com.greensock,
            _2PI = Math.PI * 2,
            _HALF_PI = Math.PI / 2,
            _class = gs._class,
            _create = function(n, f) {
              var C = _class("easing." + n, function() {}, true),
                  p = C.prototype = new Ease();
              p.constructor = C;
              p.getRatio = f;
              return C;
            },
            _easeReg = Ease.register || function() {},
            _wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
              var C = _class("easing." + name, {
                easeOut: new EaseOut(),
                easeIn: new EaseIn(),
                easeInOut: new EaseInOut()
              }, true);
              _easeReg(C, name);
              return C;
            },
            EasePoint = function(time, value, next) {
              this.t = time;
              this.v = value;
              if (next) {
                this.next = next;
                next.prev = this;
                this.c = next.v - value;
                this.gap = next.t - time;
              }
            },
            _createBack = function(n, f) {
              var C = _class("easing." + n, function(overshoot) {
                this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
                this._p2 = this._p1 * 1.525;
              }, true),
                  p = C.prototype = new Ease();
              p.constructor = C;
              p.getRatio = f;
              p.config = function(overshoot) {
                return new C(overshoot);
              };
              return C;
            },
            Back = _wrap("Back", _createBack("BackOut", function(p) {
              return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
            }), _createBack("BackIn", function(p) {
              return p * p * ((this._p1 + 1) * p - this._p1);
            }), _createBack("BackInOut", function(p) {
              return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
            })),
            SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
              power = (power || power === 0) ? power : 0.7;
              if (linearRatio == null) {
                linearRatio = 0.7;
              } else if (linearRatio > 1) {
                linearRatio = 1;
              }
              this._p = (linearRatio !== 1) ? power : 0;
              this._p1 = (1 - linearRatio) / 2;
              this._p2 = linearRatio;
              this._p3 = this._p1 + this._p2;
              this._calcEnd = (yoyoMode === true);
            }, true),
            p = SlowMo.prototype = new Ease(),
            SteppedEase,
            RoughEase,
            _createElastic;
        p.constructor = SlowMo;
        p.getRatio = function(p) {
          var r = p + (0.5 - p) * this._p;
          if (p < this._p1) {
            return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
          } else if (p > this._p3) {
            return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
          }
          return this._calcEnd ? 1 : r;
        };
        SlowMo.ease = new SlowMo(0.7, 0.7);
        p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
          return new SlowMo(linearRatio, power, yoyoMode);
        };
        SteppedEase = _class("easing.SteppedEase", function(steps) {
          steps = steps || 1;
          this._p1 = 1 / steps;
          this._p2 = steps + 1;
        }, true);
        p = SteppedEase.prototype = new Ease();
        p.constructor = SteppedEase;
        p.getRatio = function(p) {
          if (p < 0) {
            p = 0;
          } else if (p >= 1) {
            p = 0.999999999;
          }
          return ((this._p2 * p) >> 0) * this._p1;
        };
        p.config = SteppedEase.config = function(steps) {
          return new SteppedEase(steps);
        };
        RoughEase = _class("easing.RoughEase", function(vars) {
          vars = vars || {};
          var taper = vars.taper || "none",
              a = [],
              cnt = 0,
              points = (vars.points || 20) | 0,
              i = points,
              randomize = (vars.randomize !== false),
              clamp = (vars.clamp === true),
              template = (vars.template instanceof Ease) ? vars.template : null,
              strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
              x,
              y,
              bump,
              invX,
              obj,
              pnt;
          while (--i > -1) {
            x = randomize ? Math.random() : (1 / points) * i;
            y = template ? template.getRatio(x) : x;
            if (taper === "none") {
              bump = strength;
            } else if (taper === "out") {
              invX = 1 - x;
              bump = invX * invX * strength;
            } else if (taper === "in") {
              bump = x * x * strength;
            } else if (x < 0.5) {
              invX = x * 2;
              bump = invX * invX * 0.5 * strength;
            } else {
              invX = (1 - x) * 2;
              bump = invX * invX * 0.5 * strength;
            }
            if (randomize) {
              y += (Math.random() * bump) - (bump * 0.5);
            } else if (i % 2) {
              y += bump * 0.5;
            } else {
              y -= bump * 0.5;
            }
            if (clamp) {
              if (y > 1) {
                y = 1;
              } else if (y < 0) {
                y = 0;
              }
            }
            a[cnt++] = {
              x: x,
              y: y
            };
          }
          a.sort(function(a, b) {
            return a.x - b.x;
          });
          pnt = new EasePoint(1, 1, null);
          i = points;
          while (--i > -1) {
            obj = a[i];
            pnt = new EasePoint(obj.x, obj.y, pnt);
          }
          this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
        }, true);
        p = RoughEase.prototype = new Ease();
        p.constructor = RoughEase;
        p.getRatio = function(p) {
          var pnt = this._prev;
          if (p > pnt.t) {
            while (pnt.next && p >= pnt.t) {
              pnt = pnt.next;
            }
            pnt = pnt.prev;
          } else {
            while (pnt.prev && p <= pnt.t) {
              pnt = pnt.prev;
            }
          }
          this._prev = pnt;
          return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
        };
        p.config = function(vars) {
          return new RoughEase(vars);
        };
        RoughEase.ease = new RoughEase();
        _wrap("Bounce", _create("BounceOut", function(p) {
          if (p < 1 / 2.75) {
            return 7.5625 * p * p;
          } else if (p < 2 / 2.75) {
            return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
          } else if (p < 2.5 / 2.75) {
            return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
          }
          return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
        }), _create("BounceIn", function(p) {
          if ((p = 1 - p) < 1 / 2.75) {
            return 1 - (7.5625 * p * p);
          } else if (p < 2 / 2.75) {
            return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
          } else if (p < 2.5 / 2.75) {
            return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
          }
          return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
        }), _create("BounceInOut", function(p) {
          var invert = (p < 0.5);
          if (invert) {
            p = 1 - (p * 2);
          } else {
            p = (p * 2) - 1;
          }
          if (p < 1 / 2.75) {
            p = 7.5625 * p * p;
          } else if (p < 2 / 2.75) {
            p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
          } else if (p < 2.5 / 2.75) {
            p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
          } else {
            p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
          }
          return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
        }));
        _wrap("Circ", _create("CircOut", function(p) {
          return Math.sqrt(1 - (p = p - 1) * p);
        }), _create("CircIn", function(p) {
          return -(Math.sqrt(1 - (p * p)) - 1);
        }), _create("CircInOut", function(p) {
          return ((p *= 2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
        }));
        _createElastic = function(n, f, def) {
          var C = _class("easing." + n, function(amplitude, period) {
            this._p1 = (amplitude >= 1) ? amplitude : 1;
            this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
            this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
            this._p2 = _2PI / this._p2;
          }, true),
              p = C.prototype = new Ease();
          p.constructor = C;
          p.getRatio = f;
          p.config = function(amplitude, period) {
            return new C(amplitude, period);
          };
          return C;
        };
        _wrap("Elastic", _createElastic("ElasticOut", function(p) {
          return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
        }, 0.3), _createElastic("ElasticIn", function(p) {
          return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
        }, 0.3), _createElastic("ElasticInOut", function(p) {
          return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
        }, 0.45));
        _wrap("Expo", _create("ExpoOut", function(p) {
          return 1 - Math.pow(2, -10 * p);
        }), _create("ExpoIn", function(p) {
          return Math.pow(2, 10 * (p - 1)) - 0.001;
        }), _create("ExpoInOut", function(p) {
          return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
        }));
        _wrap("Sine", _create("SineOut", function(p) {
          return Math.sin(p * _HALF_PI);
        }), _create("SineIn", function(p) {
          return -Math.cos(p * _HALF_PI) + 1;
        }), _create("SineInOut", function(p) {
          return -0.5 * (Math.cos(Math.PI * p) - 1);
        }));
        _class("easing.EaseLookup", {find: function(s) {
            return Ease.map[s];
          }}, true);
        _easeReg(w.SlowMo, "SlowMo", "ease,");
        _easeReg(RoughEase, "RoughEase", "ease,");
        _easeReg(SteppedEase, "SteppedEase", "ease,");
        return Back;
      }, true);
    });
    if (_gsScope._gsDefine) {
      _gsScope._gsQueue.pop()();
    }
    (function(window, moduleName) {
      "use strict";
      var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
      if (_globals.TweenLite) {
        return;
      }
      var _namespace = function(ns) {
        var a = ns.split("."),
            p = _globals,
            i;
        for (i = 0; i < a.length; i++) {
          p[a[i]] = p = p[a[i]] || {};
        }
        return p;
      },
          gs = _namespace("com.greensock"),
          _tinyNum = 0.0000000001,
          _slice = function(a) {
            var b = [],
                l = a.length,
                i;
            for (i = 0; i !== l; b.push(a[i++])) {}
            return b;
          },
          _emptyFunc = function() {},
          _isArray = (function() {
            var toString = Object.prototype.toString,
                array = toString.call([]);
            return function(obj) {
              return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
            };
          }()),
          a,
          i,
          p,
          _ticker,
          _tickerActive,
          _defLookup = {},
          Definition = function(ns, dependencies, func, global) {
            this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : [];
            _defLookup[ns] = this;
            this.gsClass = null;
            this.func = func;
            var _classes = [];
            this.check = function(init) {
              var i = dependencies.length,
                  missing = i,
                  cur,
                  a,
                  n,
                  cl,
                  hasModule;
              while (--i > -1) {
                if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
                  _classes[i] = cur.gsClass;
                  missing--;
                } else if (init) {
                  cur.sc.push(this);
                }
              }
              if (missing === 0 && func) {
                a = ("com.greensock." + ns).split(".");
                n = a.pop();
                cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);
                if (global) {
                  _globals[n] = cl;
                  hasModule = (typeof(module) !== "undefined" && module.exports);
                  if (!hasModule && typeof(define) === "function" && define.amd) {
                    define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() {
                      return cl;
                    });
                  } else if (ns === moduleName && hasModule) {
                    module.exports = cl;
                  }
                }
                for (i = 0; i < this.sc.length; i++) {
                  this.sc[i].check();
                }
              }
            };
            this.check(true);
          },
          _gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
            return new Definition(ns, dependencies, func, global);
          },
          _class = gs._class = function(ns, func, global) {
            func = func || function() {};
            _gsDefine(ns, [], function() {
              return func;
            }, global);
            return func;
          };
      _gsDefine.globals = _globals;
      var _baseParams = [0, 0, 1, 1],
          _blankArray = [],
          Ease = _class("easing.Ease", function(func, extraParams, type, power) {
            this._func = func;
            this._type = type || 0;
            this._power = power || 0;
            this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
          }, true),
          _easeMap = Ease.map = {},
          _easeReg = Ease.register = function(ease, names, types, create) {
            var na = names.split(","),
                i = na.length,
                ta = (types || "easeIn,easeOut,easeInOut").split(","),
                e,
                name,
                j,
                type;
            while (--i > -1) {
              name = na[i];
              e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
              j = ta.length;
              while (--j > -1) {
                type = ta[j];
                _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
              }
            }
          };
      p = Ease.prototype;
      p._calcEnd = false;
      p.getRatio = function(p) {
        if (this._func) {
          this._params[0] = p;
          return this._func.apply(null, this._params);
        }
        var t = this._type,
            pw = this._power,
            r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
        if (pw === 1) {
          r *= r;
        } else if (pw === 2) {
          r *= r * r;
        } else if (pw === 3) {
          r *= r * r * r;
        } else if (pw === 4) {
          r *= r * r * r * r;
        }
        return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
      };
      a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
      i = a.length;
      while (--i > -1) {
        p = a[i] + ",Power" + i;
        _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
        _easeReg(new Ease(null, null, 2, i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
        _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
      }
      _easeMap.linear = gs.easing.Linear.easeIn;
      _easeMap.swing = gs.easing.Quad.easeInOut;
      var EventDispatcher = _class("events.EventDispatcher", function(target) {
        this._listeners = {};
        this._eventTarget = target || this;
      });
      p = EventDispatcher.prototype;
      p.addEventListener = function(type, callback, scope, useParam, priority) {
        priority = priority || 0;
        var list = this._listeners[type],
            index = 0,
            listener,
            i;
        if (list == null) {
          this._listeners[type] = list = [];
        }
        i = list.length;
        while (--i > -1) {
          listener = list[i];
          if (listener.c === callback && listener.s === scope) {
            list.splice(i, 1);
          } else if (index === 0 && listener.pr < priority) {
            index = i + 1;
          }
        }
        list.splice(index, 0, {
          c: callback,
          s: scope,
          up: useParam,
          pr: priority
        });
        if (this === _ticker && !_tickerActive) {
          _ticker.wake();
        }
      };
      p.removeEventListener = function(type, callback) {
        var list = this._listeners[type],
            i;
        if (list) {
          i = list.length;
          while (--i > -1) {
            if (list[i].c === callback) {
              list.splice(i, 1);
              return;
            }
          }
        }
      };
      p.dispatchEvent = function(type) {
        var list = this._listeners[type],
            i,
            t,
            listener;
        if (list) {
          i = list.length;
          t = this._eventTarget;
          while (--i > -1) {
            listener = list[i];
            if (listener) {
              if (listener.up) {
                listener.c.call(listener.s || t, {
                  type: type,
                  target: t
                });
              } else {
                listener.c.call(listener.s || t);
              }
            }
          }
        }
      };
      var _reqAnimFrame = window.requestAnimationFrame,
          _cancelAnimFrame = window.cancelAnimationFrame,
          _getTime = Date.now || function() {
            return new Date().getTime();
          },
          _lastUpdate = _getTime();
      a = ["ms", "moz", "webkit", "o"];
      i = a.length;
      while (--i > -1 && !_reqAnimFrame) {
        _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
        _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
      }
      _class("Ticker", function(fps, useRAF) {
        var _self = this,
            _startTime = _getTime(),
            _useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
            _lagThreshold = 500,
            _adjustedLag = 33,
            _tickWord = "tick",
            _fps,
            _req,
            _id,
            _gap,
            _nextTime,
            _tick = function(manual) {
              var elapsed = _getTime() - _lastUpdate,
                  overlap,
                  dispatch;
              if (elapsed > _lagThreshold) {
                _startTime += elapsed - _adjustedLag;
              }
              _lastUpdate += elapsed;
              _self.time = (_lastUpdate - _startTime) / 1000;
              overlap = _self.time - _nextTime;
              if (!_fps || overlap > 0 || manual === true) {
                _self.frame++;
                _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
                dispatch = true;
              }
              if (manual !== true) {
                _id = _req(_tick);
              }
              if (dispatch) {
                _self.dispatchEvent(_tickWord);
              }
            };
        EventDispatcher.call(_self);
        _self.time = _self.frame = 0;
        _self.tick = function() {
          _tick(true);
        };
        _self.lagSmoothing = function(threshold, adjustedLag) {
          _lagThreshold = threshold || (1 / _tinyNum);
          _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
        };
        _self.sleep = function() {
          if (_id == null) {
            return;
          }
          if (!_useRAF || !_cancelAnimFrame) {
            clearTimeout(_id);
          } else {
            _cancelAnimFrame(_id);
          }
          _req = _emptyFunc;
          _id = null;
          if (_self === _ticker) {
            _tickerActive = false;
          }
        };
        _self.wake = function(seamless) {
          if (_id !== null) {
            _self.sleep();
          } else if (seamless) {
            _startTime += -_lastUpdate + (_lastUpdate = _getTime());
          } else if (_self.frame > 10) {
            _lastUpdate = _getTime() - _lagThreshold + 5;
          }
          _req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) {
            return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0);
          } : _reqAnimFrame;
          if (_self === _ticker) {
            _tickerActive = true;
          }
          _tick(2);
        };
        _self.fps = function(value) {
          if (!arguments.length) {
            return _fps;
          }
          _fps = value;
          _gap = 1 / (_fps || 60);
          _nextTime = this.time + _gap;
          _self.wake();
        };
        _self.useRAF = function(value) {
          if (!arguments.length) {
            return _useRAF;
          }
          _self.sleep();
          _useRAF = value;
          _self.fps(_fps);
        };
        _self.fps(fps);
        setTimeout(function() {
          if (_useRAF === "auto" && _self.frame < 5 && document.visibilityState !== "hidden") {
            _self.useRAF(false);
          }
        }, 1500);
      });
      p = gs.Ticker.prototype = new gs.events.EventDispatcher();
      p.constructor = gs.Ticker;
      var Animation = _class("core.Animation", function(duration, vars) {
        this.vars = vars = vars || {};
        this._duration = this._totalDuration = duration || 0;
        this._delay = Number(vars.delay) || 0;
        this._timeScale = 1;
        this._active = (vars.immediateRender === true);
        this.data = vars.data;
        this._reversed = (vars.reversed === true);
        if (!_rootTimeline) {
          return;
        }
        if (!_tickerActive) {
          _ticker.wake();
        }
        var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
        tl.add(this, tl._time);
        if (this.vars.paused) {
          this.paused(true);
        }
      });
      _ticker = Animation.ticker = new gs.Ticker();
      p = Animation.prototype;
      p._dirty = p._gc = p._initted = p._paused = false;
      p._totalTime = p._time = 0;
      p._rawPrevTime = -1;
      p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
      p._paused = false;
      var _checkTimeout = function() {
        if (_tickerActive && _getTime() - _lastUpdate > 2000) {
          _ticker.wake();
        }
        setTimeout(_checkTimeout, 2000);
      };
      _checkTimeout();
      p.play = function(from, suppressEvents) {
        if (from != null) {
          this.seek(from, suppressEvents);
        }
        return this.reversed(false).paused(false);
      };
      p.pause = function(atTime, suppressEvents) {
        if (atTime != null) {
          this.seek(atTime, suppressEvents);
        }
        return this.paused(true);
      };
      p.resume = function(from, suppressEvents) {
        if (from != null) {
          this.seek(from, suppressEvents);
        }
        return this.paused(false);
      };
      p.seek = function(time, suppressEvents) {
        return this.totalTime(Number(time), suppressEvents !== false);
      };
      p.restart = function(includeDelay, suppressEvents) {
        return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
      };
      p.reverse = function(from, suppressEvents) {
        if (from != null) {
          this.seek((from || this.totalDuration()), suppressEvents);
        }
        return this.reversed(true).paused(false);
      };
      p.render = function(time, suppressEvents, force) {};
      p.invalidate = function() {
        this._time = this._totalTime = 0;
        this._initted = this._gc = false;
        this._rawPrevTime = -1;
        if (this._gc || !this.timeline) {
          this._enabled(true);
        }
        return this;
      };
      p.isActive = function() {
        var tl = this._timeline,
            startTime = this._startTime,
            rawTime;
        return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale));
      };
      p._enabled = function(enabled, ignoreTimeline) {
        if (!_tickerActive) {
          _ticker.wake();
        }
        this._gc = !enabled;
        this._active = this.isActive();
        if (ignoreTimeline !== true) {
          if (enabled && !this.timeline) {
            this._timeline.add(this, this._startTime - this._delay);
          } else if (!enabled && this.timeline) {
            this._timeline._remove(this, true);
          }
        }
        return false;
      };
      p._kill = function(vars, target) {
        return this._enabled(false, false);
      };
      p.kill = function(vars, target) {
        this._kill(vars, target);
        return this;
      };
      p._uncache = function(includeSelf) {
        var tween = includeSelf ? this : this.timeline;
        while (tween) {
          tween._dirty = true;
          tween = tween.timeline;
        }
        return this;
      };
      p._swapSelfInParams = function(params) {
        var i = params.length,
            copy = params.concat();
        while (--i > -1) {
          if (params[i] === "{self}") {
            copy[i] = this;
          }
        }
        return copy;
      };
      p._callback = function(type) {
        var v = this.vars;
        v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
      };
      p.eventCallback = function(type, callback, params, scope) {
        if ((type || "").substr(0, 2) === "on") {
          var v = this.vars;
          if (arguments.length === 1) {
            return v[type];
          }
          if (callback == null) {
            delete v[type];
          } else {
            v[type] = callback;
            v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
            v[type + "Scope"] = scope;
          }
          if (type === "onUpdate") {
            this._onUpdate = callback;
          }
        }
        return this;
      };
      p.delay = function(value) {
        if (!arguments.length) {
          return this._delay;
        }
        if (this._timeline.smoothChildTiming) {
          this.startTime(this._startTime + value - this._delay);
        }
        this._delay = value;
        return this;
      };
      p.duration = function(value) {
        if (!arguments.length) {
          this._dirty = false;
          return this._duration;
        }
        this._duration = this._totalDuration = value;
        this._uncache(true);
        if (this._timeline.smoothChildTiming)
          if (this._time > 0)
            if (this._time < this._duration)
              if (value !== 0) {
                this.totalTime(this._totalTime * (value / this._duration), true);
              }
        return this;
      };
      p.totalDuration = function(value) {
        this._dirty = false;
        return (!arguments.length) ? this._totalDuration : this.duration(value);
      };
      p.time = function(value, suppressEvents) {
        if (!arguments.length) {
          return this._time;
        }
        if (this._dirty) {
          this.totalDuration();
        }
        return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
      };
      p.totalTime = function(time, suppressEvents, uncapped) {
        if (!_tickerActive) {
          _ticker.wake();
        }
        if (!arguments.length) {
          return this._totalTime;
        }
        if (this._timeline) {
          if (time < 0 && !uncapped) {
            time += this.totalDuration();
          }
          if (this._timeline.smoothChildTiming) {
            if (this._dirty) {
              this.totalDuration();
            }
            var totalDuration = this._totalDuration,
                tl = this._timeline;
            if (time > totalDuration && !uncapped) {
              time = totalDuration;
            }
            this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
            if (!tl._dirty) {
              this._uncache(false);
            }
            if (tl._timeline) {
              while (tl._timeline) {
                if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
                  tl.totalTime(tl._totalTime, true);
                }
                tl = tl._timeline;
              }
            }
          }
          if (this._gc) {
            this._enabled(true, false);
          }
          if (this._totalTime !== time || this._duration === 0) {
            if (_lazyTweens.length) {
              _lazyRender();
            }
            this.render(time, suppressEvents, false);
            if (_lazyTweens.length) {
              _lazyRender();
            }
          }
        }
        return this;
      };
      p.progress = p.totalProgress = function(value, suppressEvents) {
        var duration = this.duration();
        return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
      };
      p.startTime = function(value) {
        if (!arguments.length) {
          return this._startTime;
        }
        if (value !== this._startTime) {
          this._startTime = value;
          if (this.timeline)
            if (this.timeline._sortChildren) {
              this.timeline.add(this, value - this._delay);
            }
        }
        return this;
      };
      p.endTime = function(includeRepeats) {
        return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
      };
      p.timeScale = function(value) {
        if (!arguments.length) {
          return this._timeScale;
        }
        value = value || _tinyNum;
        if (this._timeline && this._timeline.smoothChildTiming) {
          var pauseTime = this._pauseTime,
              t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
          this._startTime = t - ((t - this._startTime) * this._timeScale / value);
        }
        this._timeScale = value;
        return this._uncache(false);
      };
      p.reversed = function(value) {
        if (!arguments.length) {
          return this._reversed;
        }
        if (value != this._reversed) {
          this._reversed = value;
          this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
        }
        return this;
      };
      p.paused = function(value) {
        if (!arguments.length) {
          return this._paused;
        }
        var tl = this._timeline,
            raw,
            elapsed;
        if (value != this._paused)
          if (tl) {
            if (!_tickerActive && !value) {
              _ticker.wake();
            }
            raw = tl.rawTime();
            elapsed = raw - this._pauseTime;
            if (!value && tl.smoothChildTiming) {
              this._startTime += elapsed;
              this._uncache(false);
            }
            this._pauseTime = value ? raw : null;
            this._paused = value;
            this._active = this.isActive();
            if (!value && elapsed !== 0 && this._initted && this.duration()) {
              raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
              this.render(raw, (raw === this._totalTime), true);
            }
          }
        if (this._gc && !value) {
          this._enabled(true, false);
        }
        return this;
      };
      var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
        Animation.call(this, 0, vars);
        this.autoRemoveChildren = this.smoothChildTiming = true;
      });
      p = SimpleTimeline.prototype = new Animation();
      p.constructor = SimpleTimeline;
      p.kill()._gc = false;
      p._first = p._last = p._recent = null;
      p._sortChildren = false;
      p.add = p.insert = function(child, position, align, stagger) {
        var prevTween,
            st;
        child._startTime = Number(position || 0) + child._delay;
        if (child._paused)
          if (this !== child._timeline) {
            child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
          }
        if (child.timeline) {
          child.timeline._remove(child, true);
        }
        child.timeline = child._timeline = this;
        if (child._gc) {
          child._enabled(true, true);
        }
        prevTween = this._last;
        if (this._sortChildren) {
          st = child._startTime;
          while (prevTween && prevTween._startTime > st) {
            prevTween = prevTween._prev;
          }
        }
        if (prevTween) {
          child._next = prevTween._next;
          prevTween._next = child;
        } else {
          child._next = this._first;
          this._first = child;
        }
        if (child._next) {
          child._next._prev = child;
        } else {
          this._last = child;
        }
        child._prev = prevTween;
        this._recent = child;
        if (this._timeline) {
          this._uncache(true);
        }
        return this;
      };
      p._remove = function(tween, skipDisable) {
        if (tween.timeline === this) {
          if (!skipDisable) {
            tween._enabled(false, true);
          }
          if (tween._prev) {
            tween._prev._next = tween._next;
          } else if (this._first === tween) {
            this._first = tween._next;
          }
          if (tween._next) {
            tween._next._prev = tween._prev;
          } else if (this._last === tween) {
            this._last = tween._prev;
          }
          tween._next = tween._prev = tween.timeline = null;
          if (tween === this._recent) {
            this._recent = this._last;
          }
          if (this._timeline) {
            this._uncache(true);
          }
        }
        return this;
      };
      p.render = function(time, suppressEvents, force) {
        var tween = this._first,
            next;
        this._totalTime = this._time = this._rawPrevTime = time;
        while (tween) {
          next = tween._next;
          if (tween._active || (time >= tween._startTime && !tween._paused)) {
            if (!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
            }
          }
          tween = next;
        }
      };
      p.rawTime = function() {
        if (!_tickerActive) {
          _ticker.wake();
        }
        return this._totalTime;
      };
      var TweenLite = _class("TweenLite", function(target, duration, vars) {
        Animation.call(this, duration, vars);
        this.render = TweenLite.prototype.render;
        if (target == null) {
          throw "Cannot tween a null target.";
        }
        this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
        var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
            overwrite = this.vars.overwrite,
            i,
            targ,
            targets;
        this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];
        if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
          this._targets = targets = _slice(target);
          this._propLookup = [];
          this._siblings = [];
          for (i = 0; i < targets.length; i++) {
            targ = targets[i];
            if (!targ) {
              targets.splice(i--, 1);
              continue;
            } else if (typeof(targ) === "string") {
              targ = targets[i--] = TweenLite.selector(targ);
              if (typeof(targ) === "string") {
                targets.splice(i + 1, 1);
              }
              continue;
            } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) {
              targets.splice(i--, 1);
              this._targets = targets = targets.concat(_slice(targ));
              continue;
            }
            this._siblings[i] = _register(targ, this, false);
            if (overwrite === 1)
              if (this._siblings[i].length > 1) {
                _applyOverwrite(targ, this, null, 1, this._siblings[i]);
              }
          }
        } else {
          this._propLookup = {};
          this._siblings = _register(target, this, false);
          if (overwrite === 1)
            if (this._siblings.length > 1) {
              _applyOverwrite(target, this, null, 1, this._siblings);
            }
        }
        if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
          this._time = -_tinyNum;
          this.render(-this._delay);
        }
      }, true),
          _isSelector = function(v) {
            return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType)));
          },
          _autoCSS = function(vars, target) {
            var css = {},
                p;
            for (p in vars) {
              if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) {
                css[p] = vars[p];
                delete vars[p];
              }
            }
            vars.css = css;
          };
      p = TweenLite.prototype = new Animation();
      p.constructor = TweenLite;
      p.kill()._gc = false;
      p.ratio = 0;
      p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
      p._notifyPluginsOfEnabled = p._lazy = false;
      TweenLite.version = "1.18.2";
      TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
      TweenLite.defaultOverwrite = "auto";
      TweenLite.ticker = _ticker;
      TweenLite.autoSleep = 120;
      TweenLite.lagSmoothing = function(threshold, adjustedLag) {
        _ticker.lagSmoothing(threshold, adjustedLag);
      };
      TweenLite.selector = window.$ || window.jQuery || function(e) {
        var selector = window.$ || window.jQuery;
        if (selector) {
          TweenLite.selector = selector;
          return selector(e);
        }
        return (typeof(document) === "undefined") ? e : (document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
      };
      var _lazyTweens = [],
          _lazyLookup = {},
          _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
          _setRatio = function(v) {
            var pt = this._firstPT,
                min = 0.000001,
                val;
            while (pt) {
              val = !pt.blob ? pt.c * v + pt.s : v ? this.join("") : this.start;
              if (pt.r) {
                val = Math.round(val);
              } else if (val < min)
                if (val > -min) {
                  val = 0;
                }
              if (!pt.f) {
                pt.t[pt.p] = val;
              } else if (pt.fp) {
                pt.t[pt.p](pt.fp, val);
              } else {
                pt.t[pt.p](val);
              }
              pt = pt._next;
            }
          },
          _blobDif = function(start, end, filter, pt) {
            var a = [start, end],
                charIndex = 0,
                s = "",
                color = 0,
                startNums,
                endNums,
                num,
                i,
                l,
                nonNumbers,
                currentNum;
            a.start = start;
            if (filter) {
              filter(a);
              start = a[0];
              end = a[1];
            }
            a.length = 0;
            startNums = start.match(_numbersExp) || [];
            endNums = end.match(_numbersExp) || [];
            if (pt) {
              pt._next = null;
              pt.blob = 1;
              a._firstPT = pt;
            }
            l = endNums.length;
            for (i = 0; i < l; i++) {
              currentNum = endNums[i];
              nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
              s += (nonNumbers || !i) ? nonNumbers : ",";
              charIndex += nonNumbers.length;
              if (color) {
                color = (color + 1) % 5;
              } else if (nonNumbers.substr(-5) === "rgba(") {
                color = 1;
              }
              if (currentNum === startNums[i] || startNums.length <= i) {
                s += currentNum;
              } else {
                if (s) {
                  a.push(s);
                  s = "";
                }
                num = parseFloat(startNums[i]);
                a.push(num);
                a._firstPT = {
                  _next: a._firstPT,
                  t: a,
                  p: a.length - 1,
                  s: num,
                  c: ((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0,
                  f: 0,
                  r: (color && color < 4)
                };
              }
              charIndex += currentNum.length;
            }
            s += end.substr(charIndex);
            if (s) {
              a.push(s);
            }
            a.setRatio = _setRatio;
            return a;
          },
          _addPropTween = function(target, prop, start, end, overwriteProp, round, funcParam, stringFilter) {
            var s = (start === "get") ? target[prop] : start,
                type = typeof(target[prop]),
                isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
                pt = {
                  t: target,
                  p: prop,
                  s: s,
                  f: (type === "function"),
                  pg: 0,
                  n: overwriteProp || prop,
                  r: round,
                  pr: 0,
                  c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0
                },
                blob,
                getterName;
            if (type !== "number") {
              if (type === "function" && start === "get") {
                getterName = ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3));
                pt.s = s = funcParam ? target[getterName](funcParam) : target[getterName]();
              }
              if (typeof(s) === "string" && (funcParam || isNaN(s))) {
                pt.fp = funcParam;
                blob = _blobDif(s, end, stringFilter || TweenLite.defaultStringFilter, pt);
                pt = {
                  t: blob,
                  p: "setRatio",
                  s: 0,
                  c: 1,
                  f: 2,
                  pg: 0,
                  n: overwriteProp || prop,
                  pr: 0
                };
              } else if (!isRelative) {
                pt.s = parseFloat(s);
                pt.c = (parseFloat(end) - pt.s) || 0;
              }
            }
            if (pt.c) {
              if ((pt._next = this._firstPT)) {
                pt._next._prev = pt;
              }
              this._firstPT = pt;
              return pt;
            }
          },
          _internals = TweenLite._internals = {
            isArray: _isArray,
            isSelector: _isSelector,
            lazyTweens: _lazyTweens,
            blobDif: _blobDif
          },
          _plugins = TweenLite._plugins = {},
          _tweenLookup = _internals.tweenLookup = {},
          _tweenLookupNum = 0,
          _reservedProps = _internals.reservedProps = {
            ease: 1,
            delay: 1,
            overwrite: 1,
            onComplete: 1,
            onCompleteParams: 1,
            onCompleteScope: 1,
            useFrames: 1,
            runBackwards: 1,
            startAt: 1,
            onUpdate: 1,
            onUpdateParams: 1,
            onUpdateScope: 1,
            onStart: 1,
            onStartParams: 1,
            onStartScope: 1,
            onReverseComplete: 1,
            onReverseCompleteParams: 1,
            onReverseCompleteScope: 1,
            onRepeat: 1,
            onRepeatParams: 1,
            onRepeatScope: 1,
            easeParams: 1,
            yoyo: 1,
            immediateRender: 1,
            repeat: 1,
            repeatDelay: 1,
            data: 1,
            paused: 1,
            reversed: 1,
            autoCSS: 1,
            lazy: 1,
            onOverwrite: 1,
            callbackScope: 1,
            stringFilter: 1
          },
          _overwriteLookup = {
            none: 0,
            all: 1,
            auto: 2,
            concurrent: 3,
            allOnStart: 4,
            preexisting: 5,
            "true": 1,
            "false": 0
          },
          _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
          _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
          _nextGCFrame = 30,
          _lazyRender = _internals.lazyRender = function() {
            var i = _lazyTweens.length,
                tween;
            _lazyLookup = {};
            while (--i > -1) {
              tween = _lazyTweens[i];
              if (tween && tween._lazy !== false) {
                tween.render(tween._lazy[0], tween._lazy[1], true);
                tween._lazy = false;
              }
            }
            _lazyTweens.length = 0;
          };
      _rootTimeline._startTime = _ticker.time;
      _rootFramesTimeline._startTime = _ticker.frame;
      _rootTimeline._active = _rootFramesTimeline._active = true;
      setTimeout(_lazyRender, 1);
      Animation._updateRoot = TweenLite.render = function() {
        var i,
            a,
            p;
        if (_lazyTweens.length) {
          _lazyRender();
        }
        _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
        _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
        if (_lazyTweens.length) {
          _lazyRender();
        }
        if (_ticker.frame >= _nextGCFrame) {
          _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
          for (p in _tweenLookup) {
            a = _tweenLookup[p].tweens;
            i = a.length;
            while (--i > -1) {
              if (a[i]._gc) {
                a.splice(i, 1);
              }
            }
            if (a.length === 0) {
              delete _tweenLookup[p];
            }
          }
          p = _rootTimeline._first;
          if (!p || p._paused)
            if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
              while (p && p._paused) {
                p = p._next;
              }
              if (!p) {
                _ticker.sleep();
              }
            }
        }
      };
      _ticker.addEventListener("tick", Animation._updateRoot);
      var _register = function(target, tween, scrub) {
        var id = target._gsTweenID,
            a,
            i;
        if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
          _tweenLookup[id] = {
            target: target,
            tweens: []
          };
        }
        if (tween) {
          a = _tweenLookup[id].tweens;
          a[(i = a.length)] = tween;
          if (scrub) {
            while (--i > -1) {
              if (a[i] === tween) {
                a.splice(i, 1);
              }
            }
          }
        }
        return _tweenLookup[id].tweens;
      },
          _onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
            var func = overwrittenTween.vars.onOverwrite,
                r1,
                r2;
            if (func) {
              r1 = func(overwrittenTween, overwritingTween, target, killedProps);
            }
            func = TweenLite.onOverwrite;
            if (func) {
              r2 = func(overwrittenTween, overwritingTween, target, killedProps);
            }
            return (r1 !== false && r2 !== false);
          },
          _applyOverwrite = function(target, tween, props, mode, siblings) {
            var i,
                changed,
                curTween,
                l;
            if (mode === 1 || mode >= 4) {
              l = siblings.length;
              for (i = 0; i < l; i++) {
                if ((curTween = siblings[i]) !== tween) {
                  if (!curTween._gc) {
                    if (curTween._kill(null, target, tween)) {
                      changed = true;
                    }
                  }
                } else if (mode === 5) {
                  break;
                }
              }
              return changed;
            }
            var startTime = tween._startTime + _tinyNum,
                overlaps = [],
                oCount = 0,
                zeroDur = (tween._duration === 0),
                globalStart;
            i = siblings.length;
            while (--i > -1) {
              if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {} else if (curTween._timeline !== tween._timeline) {
                globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
                if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
                  overlaps[oCount++] = curTween;
                }
              } else if (curTween._startTime <= startTime)
                if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
                  if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
                    overlaps[oCount++] = curTween;
                  }
            }
            i = oCount;
            while (--i > -1) {
              curTween = overlaps[i];
              if (mode === 2)
                if (curTween._kill(props, target, tween)) {
                  changed = true;
                }
              if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
                if (mode !== 2 && !_onOverwrite(curTween, tween)) {
                  continue;
                }
                if (curTween._enabled(false, false)) {
                  changed = true;
                }
              }
            }
            return changed;
          },
          _checkOverlap = function(tween, reference, zeroDur) {
            var tl = tween._timeline,
                ts = tl._timeScale,
                t = tween._startTime;
            while (tl._timeline) {
              t += tl._startTime;
              ts *= tl._timeScale;
              if (tl._paused) {
                return -100;
              }
              tl = tl._timeline;
            }
            t /= ts;
            return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
          };
      p._init = function() {
        var v = this.vars,
            op = this._overwrittenProps,
            dur = this._duration,
            immediate = !!v.immediateRender,
            ease = v.ease,
            i,
            initPlugins,
            pt,
            p,
            startVars;
        if (v.startAt) {
          if (this._startAt) {
            this._startAt.render(-1, true);
            this._startAt.kill();
          }
          startVars = {};
          for (p in v.startAt) {
            startVars[p] = v.startAt[p];
          }
          startVars.overwrite = false;
          startVars.immediateRender = true;
          startVars.lazy = (immediate && v.lazy !== false);
          startVars.startAt = startVars.delay = null;
          this._startAt = TweenLite.to(this.target, 0, startVars);
          if (immediate) {
            if (this._time > 0) {
              this._startAt = null;
            } else if (dur !== 0) {
              return;
            }
          }
        } else if (v.runBackwards && dur !== 0) {
          if (this._startAt) {
            this._startAt.render(-1, true);
            this._startAt.kill();
            this._startAt = null;
          } else {
            if (this._time !== 0) {
              immediate = false;
            }
            pt = {};
            for (p in v) {
              if (!_reservedProps[p] || p === "autoCSS") {
                pt[p] = v[p];
              }
            }
            pt.overwrite = 0;
            pt.data = "isFromStart";
            pt.lazy = (immediate && v.lazy !== false);
            pt.immediateRender = immediate;
            this._startAt = TweenLite.to(this.target, 0, pt);
            if (!immediate) {
              this._startAt._init();
              this._startAt._enabled(false);
              if (this.vars.immediateRender) {
                this._startAt = null;
              }
            } else if (this._time === 0) {
              return;
            }
          }
        }
        this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
        if (v.easeParams instanceof Array && ease.config) {
          this._ease = ease.config.apply(ease, v.easeParams);
        }
        this._easeType = this._ease._type;
        this._easePower = this._ease._power;
        this._firstPT = null;
        if (this._targets) {
          i = this._targets.length;
          while (--i > -1) {
            if (this._initProps(this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null))) {
              initPlugins = true;
            }
          }
        } else {
          initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
        }
        if (initPlugins) {
          TweenLite._onPluginEvent("_onInitAllProps", this);
        }
        if (op)
          if (!this._firstPT)
            if (typeof(this.target) !== "function") {
              this._enabled(false, false);
            }
        if (v.runBackwards) {
          pt = this._firstPT;
          while (pt) {
            pt.s += pt.c;
            pt.c = -pt.c;
            pt = pt._next;
          }
        }
        this._onUpdate = v.onUpdate;
        this._initted = true;
      };
      p._initProps = function(target, propLookup, siblings, overwrittenProps) {
        var p,
            i,
            initPlugins,
            plugin,
            pt,
            v;
        if (target == null) {
          return false;
        }
        if (_lazyLookup[target._gsTweenID]) {
          _lazyRender();
        }
        if (!this.vars.css)
          if (target.style)
            if (target !== window && target.nodeType)
              if (_plugins.css)
                if (this.vars.autoCSS !== false) {
                  _autoCSS(this.vars, target);
                }
        for (p in this.vars) {
          v = this.vars[p];
          if (_reservedProps[p]) {
            if (v)
              if ((v instanceof Array) || (v.push && _isArray(v)))
                if (v.join("").indexOf("{self}") !== -1) {
                  this.vars[p] = v = this._swapSelfInParams(v, this);
                }
          } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {
            this._firstPT = pt = {
              _next: this._firstPT,
              t: plugin,
              p: "setRatio",
              s: 0,
              c: 1,
              f: 1,
              n: p,
              pg: 1,
              pr: plugin._priority
            };
            i = plugin._overwriteProps.length;
            while (--i > -1) {
              propLookup[plugin._overwriteProps[i]] = this._firstPT;
            }
            if (plugin._priority || plugin._onInitAllProps) {
              initPlugins = true;
            }
            if (plugin._onDisable || plugin._onEnable) {
              this._notifyPluginsOfEnabled = true;
            }
            if (pt._next) {
              pt._next._prev = pt;
            }
          } else {
            propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter);
          }
        }
        if (overwrittenProps)
          if (this._kill(overwrittenProps, target)) {
            return this._initProps(target, propLookup, siblings, overwrittenProps);
          }
        if (this._overwrite > 1)
          if (this._firstPT)
            if (siblings.length > 1)
              if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
                this._kill(propLookup, target);
                return this._initProps(target, propLookup, siblings, overwrittenProps);
              }
        if (this._firstPT)
          if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) {
            _lazyLookup[target._gsTweenID] = true;
          }
        return initPlugins;
      };
      p.render = function(time, suppressEvents, force) {
        var prevTime = this._time,
            duration = this._duration,
            prevRawPrevTime = this._rawPrevTime,
            isComplete,
            callback,
            pt,
            rawPrevTime;
        if (time >= duration - 0.0000001) {
          this._totalTime = this._time = duration;
          this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
          if (!this._reversed) {
            isComplete = true;
            callback = "onComplete";
            force = (force || this._timeline.autoRemoveChildren);
          }
          if (duration === 0)
            if (this._initted || !this.vars.lazy || force) {
              if (this._startTime === this._timeline._duration) {
                time = 0;
              }
              if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause"))
                if (prevRawPrevTime !== time) {
                  force = true;
                  if (prevRawPrevTime > _tinyNum) {
                    callback = "onReverseComplete";
                  }
                }
              this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
            }
        } else if (time < 0.0000001) {
          this._totalTime = this._time = 0;
          this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
          if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
            callback = "onReverseComplete";
            isComplete = this._reversed;
          }
          if (time < 0) {
            this._active = false;
            if (duration === 0)
              if (this._initted || !this.vars.lazy || force) {
                if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
                  force = true;
                }
                this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
              }
          }
          if (!this._initted) {
            force = true;
          }
        } else {
          this._totalTime = this._time = time;
          if (this._easeType) {
            var r = time / duration,
                type = this._easeType,
                pow = this._easePower;
            if (type === 1 || (type === 3 && r >= 0.5)) {
              r = 1 - r;
            }
            if (type === 3) {
              r *= 2;
            }
            if (pow === 1) {
              r *= r;
            } else if (pow === 2) {
              r *= r * r;
            } else if (pow === 3) {
              r *= r * r * r;
            } else if (pow === 4) {
              r *= r * r * r * r;
            }
            if (type === 1) {
              this.ratio = 1 - r;
            } else if (type === 2) {
              this.ratio = r;
            } else if (time / duration < 0.5) {
              this.ratio = r / 2;
            } else {
              this.ratio = 1 - (r / 2);
            }
          } else {
            this.ratio = this._ease.getRatio(time / duration);
          }
        }
        if (this._time === prevTime && !force) {
          return;
        } else if (!this._initted) {
          this._init();
          if (!this._initted || this._gc) {
            return;
          } else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
            this._time = this._totalTime = prevTime;
            this._rawPrevTime = prevRawPrevTime;
            _lazyTweens.push(this);
            this._lazy = [time, suppressEvents];
            return;
          }
          if (this._time && !isComplete) {
            this.ratio = this._ease.getRatio(this._time / duration);
          } else if (isComplete && this._ease._calcEnd) {
            this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
          }
        }
        if (this._lazy !== false) {
          this._lazy = false;
        }
        if (!this._active)
          if (!this._paused && this._time !== prevTime && time >= 0) {
            this._active = true;
          }
        if (prevTime === 0) {
          if (this._startAt) {
            if (time >= 0) {
              this._startAt.render(time, suppressEvents, force);
            } else if (!callback) {
              callback = "_dummyGS";
            }
          }
          if (this.vars.onStart)
            if (this._time !== 0 || duration === 0)
              if (!suppressEvents) {
                this._callback("onStart");
              }
        }
        pt = this._firstPT;
        while (pt) {
          if (pt.f) {
            pt.t[pt.p](pt.c * this.ratio + pt.s);
          } else {
            pt.t[pt.p] = pt.c * this.ratio + pt.s;
          }
          pt = pt._next;
        }
        if (this._onUpdate) {
          if (time < 0)
            if (this._startAt && time !== -0.0001) {
              this._startAt.render(time, suppressEvents, force);
            }
          if (!suppressEvents)
            if (this._time !== prevTime || isComplete) {
              this._callback("onUpdate");
            }
        }
        if (callback)
          if (!this._gc || force) {
            if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
              this._startAt.render(time, suppressEvents, force);
            }
            if (isComplete) {
              if (this._timeline.autoRemoveChildren) {
                this._enabled(false, false);
              }
              this._active = false;
            }
            if (!suppressEvents && this.vars[callback]) {
              this._callback(callback);
            }
            if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
              this._rawPrevTime = 0;
            }
          }
      };
      p._kill = function(vars, target, overwritingTween) {
        if (vars === "all") {
          vars = null;
        }
        if (vars == null)
          if (target == null || target === this.target) {
            this._lazy = false;
            return this._enabled(false, false);
          }
        target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
        var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
            i,
            overwrittenProps,
            p,
            pt,
            propLookup,
            changed,
            killProps,
            record,
            killed;
        if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
          i = target.length;
          while (--i > -1) {
            if (this._kill(vars, target[i], overwritingTween)) {
              changed = true;
            }
          }
        } else {
          if (this._targets) {
            i = this._targets.length;
            while (--i > -1) {
              if (target === this._targets[i]) {
                propLookup = this._propLookup[i] || {};
                this._overwrittenProps = this._overwrittenProps || [];
                overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
                break;
              }
            }
          } else if (target !== this.target) {
            return false;
          } else {
            propLookup = this._propLookup;
            overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
          }
          if (propLookup) {
            killProps = vars || propLookup;
            record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill));
            if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
              for (p in killProps) {
                if (propLookup[p]) {
                  if (!killed) {
                    killed = [];
                  }
                  killed.push(p);
                }
              }
              if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
                return false;
              }
            }
            for (p in killProps) {
              if ((pt = propLookup[p])) {
                if (simultaneousOverwrite) {
                  if (pt.f) {
                    pt.t[pt.p](pt.s);
                  } else {
                    pt.t[pt.p] = pt.s;
                  }
                  changed = true;
                }
                if (pt.pg && pt.t._kill(killProps)) {
                  changed = true;
                }
                if (!pt.pg || pt.t._overwriteProps.length === 0) {
                  if (pt._prev) {
                    pt._prev._next = pt._next;
                  } else if (pt === this._firstPT) {
                    this._firstPT = pt._next;
                  }
                  if (pt._next) {
                    pt._next._prev = pt._prev;
                  }
                  pt._next = pt._prev = null;
                }
                delete propLookup[p];
              }
              if (record) {
                overwrittenProps[p] = 1;
              }
            }
            if (!this._firstPT && this._initted) {
              this._enabled(false, false);
            }
          }
        }
        return changed;
      };
      p.invalidate = function() {
        if (this._notifyPluginsOfEnabled) {
          TweenLite._onPluginEvent("_onDisable", this);
        }
        this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
        this._notifyPluginsOfEnabled = this._active = this._lazy = false;
        this._propLookup = (this._targets) ? {} : [];
        Animation.prototype.invalidate.call(this);
        if (this.vars.immediateRender) {
          this._time = -_tinyNum;
          this.render(-this._delay);
        }
        return this;
      };
      p._enabled = function(enabled, ignoreTimeline) {
        if (!_tickerActive) {
          _ticker.wake();
        }
        if (enabled && this._gc) {
          var targets = this._targets,
              i;
          if (targets) {
            i = targets.length;
            while (--i > -1) {
              this._siblings[i] = _register(targets[i], this, true);
            }
          } else {
            this._siblings = _register(this.target, this, true);
          }
        }
        Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
        if (this._notifyPluginsOfEnabled)
          if (this._firstPT) {
            return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
          }
        return false;
      };
      TweenLite.to = function(target, duration, vars) {
        return new TweenLite(target, duration, vars);
      };
      TweenLite.from = function(target, duration, vars) {
        vars.runBackwards = true;
        vars.immediateRender = (vars.immediateRender != false);
        return new TweenLite(target, duration, vars);
      };
      TweenLite.fromTo = function(target, duration, fromVars, toVars) {
        toVars.startAt = fromVars;
        toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
        return new TweenLite(target, duration, toVars);
      };
      TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
        return new TweenLite(callback, 0, {
          delay: delay,
          onComplete: callback,
          onCompleteParams: params,
          callbackScope: scope,
          onReverseComplete: callback,
          onReverseCompleteParams: params,
          immediateRender: false,
          lazy: false,
          useFrames: useFrames,
          overwrite: 0
        });
      };
      TweenLite.set = function(target, vars) {
        return new TweenLite(target, 0, vars);
      };
      TweenLite.getTweensOf = function(target, onlyActive) {
        if (target == null) {
          return [];
        }
        target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
        var i,
            a,
            j,
            t;
        if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
          i = target.length;
          a = [];
          while (--i > -1) {
            a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
          }
          i = a.length;
          while (--i > -1) {
            t = a[i];
            j = i;
            while (--j > -1) {
              if (t === a[j]) {
                a.splice(i, 1);
              }
            }
          }
        } else {
          a = _register(target).concat();
          i = a.length;
          while (--i > -1) {
            if (a[i]._gc || (onlyActive && !a[i].isActive())) {
              a.splice(i, 1);
            }
          }
        }
        return a;
      };
      TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
        if (typeof(onlyActive) === "object") {
          vars = onlyActive;
          onlyActive = false;
        }
        var a = TweenLite.getTweensOf(target, onlyActive),
            i = a.length;
        while (--i > -1) {
          a[i]._kill(vars, target);
        }
      };
      var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
        this._overwriteProps = (props || "").split(",");
        this._propName = this._overwriteProps[0];
        this._priority = priority || 0;
        this._super = TweenPlugin.prototype;
      }, true);
      p = TweenPlugin.prototype;
      TweenPlugin.version = "1.18.0";
      TweenPlugin.API = 2;
      p._firstPT = null;
      p._addTween = _addPropTween;
      p.setRatio = _setRatio;
      p._kill = function(lookup) {
        var a = this._overwriteProps,
            pt = this._firstPT,
            i;
        if (lookup[this._propName] != null) {
          this._overwriteProps = [];
        } else {
          i = a.length;
          while (--i > -1) {
            if (lookup[a[i]] != null) {
              a.splice(i, 1);
            }
          }
        }
        while (pt) {
          if (lookup[pt.n] != null) {
            if (pt._next) {
              pt._next._prev = pt._prev;
            }
            if (pt._prev) {
              pt._prev._next = pt._next;
              pt._prev = null;
            } else if (this._firstPT === pt) {
              this._firstPT = pt._next;
            }
          }
          pt = pt._next;
        }
        return false;
      };
      p._roundProps = function(lookup, value) {
        var pt = this._firstPT;
        while (pt) {
          if (lookup[this._propName] || (pt.n != null && lookup[pt.n.split(this._propName + "_").join("")])) {
            pt.r = value;
          }
          pt = pt._next;
        }
      };
      TweenLite._onPluginEvent = function(type, tween) {
        var pt = tween._firstPT,
            changed,
            pt2,
            first,
            last,
            next;
        if (type === "_onInitAllProps") {
          while (pt) {
            next = pt._next;
            pt2 = first;
            while (pt2 && pt2.pr > pt.pr) {
              pt2 = pt2._next;
            }
            if ((pt._prev = pt2 ? pt2._prev : last)) {
              pt._prev._next = pt;
            } else {
              first = pt;
            }
            if ((pt._next = pt2)) {
              pt2._prev = pt;
            } else {
              last = pt;
            }
            pt = next;
          }
          pt = tween._firstPT = first;
        }
        while (pt) {
          if (pt.pg)
            if (typeof(pt.t[type]) === "function")
              if (pt.t[type]()) {
                changed = true;
              }
          pt = pt._next;
        }
        return changed;
      };
      TweenPlugin.activate = function(plugins) {
        var i = plugins.length;
        while (--i > -1) {
          if (plugins[i].API === TweenPlugin.API) {
            _plugins[(new plugins[i]())._propName] = plugins[i];
          }
        }
        return true;
      };
      _gsDefine.plugin = function(config) {
        if (!config || !config.propName || !config.init || !config.API) {
          throw "illegal plugin definition.";
        }
        var propName = config.propName,
            priority = config.priority || 0,
            overwriteProps = config.overwriteProps,
            map = {
              init: "_onInitTween",
              set: "setRatio",
              kill: "_kill",
              round: "_roundProps",
              initAll: "_onInitAllProps"
            },
            Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function() {
              TweenPlugin.call(this, propName, priority);
              this._overwriteProps = overwriteProps || [];
            }, (config.global === true)),
            p = Plugin.prototype = new TweenPlugin(propName),
            prop;
        p.constructor = Plugin;
        Plugin.API = config.API;
        for (prop in map) {
          if (typeof(config[prop]) === "function") {
            p[map[prop]] = config[prop];
          }
        }
        Plugin.version = config.version;
        TweenPlugin.activate([Plugin]);
        return Plugin;
      };
      a = window._gsQueue;
      if (a) {
        for (i = 0; i < a.length; i++) {
          a[i]();
        }
        for (p in _defLookup) {
          if (!_defLookup[p].func) {
            window.console.log("GSAP encountered missing dependency: com.greensock." + p);
          }
        }
      }
      _tickerActive = false;
    })((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
  })($__require('f'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10", ["e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11", ["12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      $export = $__require('13'),
      DESCRIPTORS = $__require('14'),
      createDesc = $__require('15'),
      html = $__require('16'),
      cel = $__require('17'),
      has = $__require('18'),
      cof = $__require('19'),
      invoke = $__require('1a'),
      fails = $__require('1b'),
      anObject = $__require('1c'),
      aFunction = $__require('1d'),
      isObject = $__require('1e'),
      toObject = $__require('1f'),
      toIObject = $__require('20'),
      toInteger = $__require('21'),
      toIndex = $__require('22'),
      toLength = $__require('23'),
      IObject = $__require('24'),
      IE_PROTO = $__require('25')('__proto__'),
      createArrayMethod = $__require('26'),
      arrayIndexOf = $__require('27')(false),
      ObjectProto = Object.prototype,
      ArrayProto = Array.prototype,
      arraySlice = ArrayProto.slice,
      arrayJoin = ArrayProto.join,
      defineProperty = $.setDesc,
      getOwnDescriptor = $.getDesc,
      defineProperties = $.setDescs,
      factories = {},
      IE8_DOM_DEFINE;
  if (!DESCRIPTORS) {
    IE8_DOM_DEFINE = !fails(function() {
      return defineProperty(cel('div'), 'a', {get: function() {
          return 7;
        }}).a != 7;
    });
    $.setDesc = function(O, P, Attributes) {
      if (IE8_DOM_DEFINE)
        try {
          return defineProperty(O, P, Attributes);
        } catch (e) {}
      if ('get' in Attributes || 'set' in Attributes)
        throw TypeError('Accessors not supported!');
      if ('value' in Attributes)
        anObject(O)[P] = Attributes.value;
      return O;
    };
    $.getDesc = function(O, P) {
      if (IE8_DOM_DEFINE)
        try {
          return getOwnDescriptor(O, P);
        } catch (e) {}
      if (has(O, P))
        return createDesc(!ObjectProto.propertyIsEnumerable.call(O, P), O[P]);
    };
    $.setDescs = defineProperties = function(O, Properties) {
      anObject(O);
      var keys = $.getKeys(Properties),
          length = keys.length,
          i = 0,
          P;
      while (length > i)
        $.setDesc(O, P = keys[i++], Properties[P]);
      return O;
    };
  }
  $export($export.S + $export.F * !DESCRIPTORS, 'Object', {
    getOwnPropertyDescriptor: $.getDesc,
    defineProperty: $.setDesc,
    defineProperties: defineProperties
  });
  var keys1 = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,' + 'toLocaleString,toString,valueOf').split(','),
      keys2 = keys1.concat('length', 'prototype'),
      keysLen1 = keys1.length;
  var createDict = function() {
    var iframe = cel('iframe'),
        i = keysLen1,
        gt = '>',
        iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write('<script>document.F=Object</script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--)
      delete createDict.prototype[keys1[i]];
    return createDict();
  };
  var createGetKeys = function(names, length) {
    return function(object) {
      var O = toIObject(object),
          i = 0,
          result = [],
          key;
      for (key in O)
        if (key != IE_PROTO)
          has(O, key) && result.push(key);
      while (length > i)
        if (has(O, key = names[i++])) {
          ~arrayIndexOf(result, key) || result.push(key);
        }
      return result;
    };
  };
  var Empty = function() {};
  $export($export.S, 'Object', {
    getPrototypeOf: $.getProto = $.getProto || function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO))
        return O[IE_PROTO];
      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    },
    getOwnPropertyNames: $.getNames = $.getNames || createGetKeys(keys2, keys2.length, true),
    create: $.create = $.create || function(O, Properties) {
      var result;
      if (O !== null) {
        Empty.prototype = anObject(O);
        result = new Empty();
        Empty.prototype = null;
        result[IE_PROTO] = O;
      } else
        result = createDict();
      return Properties === undefined ? result : defineProperties(result, Properties);
    },
    keys: $.getKeys = $.getKeys || createGetKeys(keys1, keysLen1, false)
  });
  var construct = function(F, len, args) {
    if (!(len in factories)) {
      for (var n = [],
          i = 0; i < len; i++)
        n[i] = 'a[' + i + ']';
      factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
    }
    return factories[len](F, args);
  };
  $export($export.P, 'Function', {bind: function bind(that) {
      var fn = aFunction(this),
          partArgs = arraySlice.call(arguments, 1);
      var bound = function() {
        var args = partArgs.concat(arraySlice.call(arguments));
        return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
      };
      if (isObject(fn.prototype))
        bound.prototype = fn.prototype;
      return bound;
    }});
  $export($export.P + $export.F * fails(function() {
    if (html)
      arraySlice.call(html);
  }), 'Array', {slice: function(begin, end) {
      var len = toLength(this.length),
          klass = cof(this);
      end = end === undefined ? len : end;
      if (klass == 'Array')
        return arraySlice.call(this, begin, end);
      var start = toIndex(begin, len),
          upTo = toIndex(end, len),
          size = toLength(upTo - start),
          cloned = Array(size),
          i = 0;
      for (; i < size; i++)
        cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
      return cloned;
    }});
  $export($export.P + $export.F * (IObject != Object), 'Array', {join: function join(separator) {
      return arrayJoin.call(IObject(this), separator === undefined ? ',' : separator);
    }});
  $export($export.S, 'Array', {isArray: $__require('28')});
  var createArrayReduce = function(isRight) {
    return function(callbackfn, memo) {
      aFunction(callbackfn);
      var O = IObject(this),
          length = toLength(O.length),
          index = isRight ? length - 1 : 0,
          i = isRight ? -1 : 1;
      if (arguments.length < 2)
        for (; ; ) {
          if (index in O) {
            memo = O[index];
            index += i;
            break;
          }
          index += i;
          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }
      for (; isRight ? index >= 0 : length > index; index += i)
        if (index in O) {
          memo = callbackfn(memo, O[index], index, this);
        }
      return memo;
    };
  };
  var methodize = function($fn) {
    return function(arg1) {
      return $fn(this, arg1, arguments[1]);
    };
  };
  $export($export.P, 'Array', {
    forEach: $.each = $.each || methodize(createArrayMethod(0)),
    map: methodize(createArrayMethod(1)),
    filter: methodize(createArrayMethod(2)),
    some: methodize(createArrayMethod(3)),
    every: methodize(createArrayMethod(4)),
    reduce: createArrayReduce(false),
    reduceRight: createArrayReduce(true),
    indexOf: methodize(arrayIndexOf),
    lastIndexOf: function(el, fromIndex) {
      var O = toIObject(this),
          length = toLength(O.length),
          index = length - 1;
      if (arguments.length > 1)
        index = Math.min(index, toInteger(fromIndex));
      if (index < 0)
        index = toLength(length + index);
      for (; index >= 0; index--)
        if (index in O)
          if (O[index] === el)
            return index;
      return -1;
    }
  });
  $export($export.S, 'Date', {now: function() {
      return +new Date;
    }});
  var lz = function(num) {
    return num > 9 ? num : '0' + num;
  };
  $export($export.P + $export.F * (fails(function() {
    return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
  }) || !fails(function() {
    new Date(NaN).toISOString();
  })), 'Date', {toISOString: function toISOString() {
      if (!isFinite(this))
        throw RangeError('Invalid time value');
      var d = this,
          y = d.getUTCFullYear(),
          m = d.getUTCMilliseconds(),
          s = y < 0 ? '-' : y > 9999 ? '+' : '';
      return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("29", ["12"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2a", ["12", "2b", "18", "14", "13", "2c", "1b", "2d", "2e", "25", "2f", "30", "31", "29", "28", "1c", "20", "15", "32"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      global = $__require('2b'),
      has = $__require('18'),
      DESCRIPTORS = $__require('14'),
      $export = $__require('13'),
      redefine = $__require('2c'),
      $fails = $__require('1b'),
      shared = $__require('2d'),
      setToStringTag = $__require('2e'),
      uid = $__require('25'),
      wks = $__require('2f'),
      keyOf = $__require('30'),
      $names = $__require('31'),
      enumKeys = $__require('29'),
      isArray = $__require('28'),
      anObject = $__require('1c'),
      toIObject = $__require('20'),
      createDesc = $__require('15'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    if (it === undefined || isSymbol(it))
      return;
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    redefine($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (DESCRIPTORS && !$__require('32')) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $export($export.G + $export.W, {Symbol: $Symbol});
  $export($export.S, 'Symbol', symbolStatics);
  $export($export.S + $export.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setToStringTag($Symbol, 'Symbol');
  setToStringTag(Math, 'Math', true);
  setToStringTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("33", ["13", "34"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S + $export.F, 'Object', {assign: $__require('34')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("35", ["13", "36"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Object', {is: $__require('36')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("37", ["13", "38"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Object', {setPrototypeOf: $__require('38').set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("39", ["3a", "2f", "2c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('3a'),
      test = {};
  test[$__require('2f')('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    $__require('2c')(Object.prototype, 'toString', function toString() {
      return '[object ' + classof(this) + ']';
    }, true);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3b", ["1e", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  $__require('3c')('freeze', function($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3d", ["1e", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  $__require('3c')('seal', function($seal) {
    return function seal(it) {
      return $seal && isObject(it) ? $seal(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3e", ["1e", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  $__require('3c')('preventExtensions', function($preventExtensions) {
    return function preventExtensions(it) {
      return $preventExtensions && isObject(it) ? $preventExtensions(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3f", ["1e", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  $__require('3c')('isFrozen', function($isFrozen) {
    return function isFrozen(it) {
      return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("40", ["1e", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  $__require('3c')('isSealed', function($isSealed) {
    return function isSealed(it) {
      return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("41", ["1e", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  $__require('3c')('isExtensible', function($isExtensible) {
    return function isExtensible(it) {
      return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("42", ["20", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('20');
  $__require('3c')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("43", ["1f", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('1f');
  $__require('3c')('getPrototypeOf', function($getPrototypeOf) {
    return function getPrototypeOf(it) {
      return $getPrototypeOf(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("44", ["1f", "3c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('1f');
  $__require('3c')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3c", ["13", "45", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      core = $__require('45'),
      fails = $__require('1b');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("31", ["20", "12"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('20'),
      getNames = $__require('12').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("46", ["3c", "31"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('3c')('getOwnPropertyNames', function() {
    return $__require('31').get;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("47", ["12", "15", "18", "14"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var setDesc = $__require('12').setDesc,
      createDesc = $__require('15'),
      has = $__require('18'),
      FProto = Function.prototype,
      nameRE = /^\s*function ([^ (]*)/,
      NAME = 'name';
  NAME in FProto || $__require('14') && setDesc(FProto, NAME, {
    configurable: true,
    get: function() {
      var match = ('' + this).match(nameRE),
          name = match ? match[1] : '';
      has(this, NAME) || setDesc(this, NAME, createDesc(5, name));
      return name;
    }
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("48", ["12", "1e", "2f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      isObject = $__require('1e'),
      HAS_INSTANCE = $__require('2f')('hasInstance'),
      FunctionProto = Function.prototype;
  if (!(HAS_INSTANCE in FunctionProto))
    $.setDesc(FunctionProto, HAS_INSTANCE, {value: function(O) {
        if (typeof this != 'function' || !isObject(O))
          return false;
        if (!isObject(this.prototype))
          return O instanceof this;
        while (O = $.getProto(O))
          if (this.prototype === O)
            return true;
        return false;
      }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("49", ["1e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  module.exports = function(it, S) {
    if (!isObject(it))
      return it;
    var fn,
        val;
    if (S && typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
      return val;
    if (typeof(fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))
      return val;
    if (!S && typeof(fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
      return val;
    throw TypeError("Can't convert object to primitive value");
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4a", ["12", "2b", "18", "19", "49", "1b", "4b", "14", "2c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      global = $__require('2b'),
      has = $__require('18'),
      cof = $__require('19'),
      toPrimitive = $__require('49'),
      fails = $__require('1b'),
      $trim = $__require('4b').trim,
      NUMBER = 'Number',
      $Number = global[NUMBER],
      Base = $Number,
      proto = $Number.prototype,
      BROKEN_COF = cof($.create(proto)) == NUMBER,
      TRIM = 'trim' in String.prototype;
  var toNumber = function(argument) {
    var it = toPrimitive(argument, false);
    if (typeof it == 'string' && it.length > 2) {
      it = TRIM ? it.trim() : $trim(it, 3);
      var first = it.charCodeAt(0),
          third,
          radix,
          maxCode;
      if (first === 43 || first === 45) {
        third = it.charCodeAt(2);
        if (third === 88 || third === 120)
          return NaN;
      } else if (first === 48) {
        switch (it.charCodeAt(1)) {
          case 66:
          case 98:
            radix = 2;
            maxCode = 49;
            break;
          case 79:
          case 111:
            radix = 8;
            maxCode = 55;
            break;
          default:
            return +it;
        }
        for (var digits = it.slice(2),
            i = 0,
            l = digits.length,
            code; i < l; i++) {
          code = digits.charCodeAt(i);
          if (code < 48 || code > maxCode)
            return NaN;
        }
        return parseInt(digits, radix);
      }
    }
    return +it;
  };
  if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
    $Number = function Number(value) {
      var it = arguments.length < 1 ? 0 : value,
          that = this;
      return that instanceof $Number && (BROKEN_COF ? fails(function() {
        proto.valueOf.call(that);
      }) : cof(that) != NUMBER) ? new Base(toNumber(it)) : toNumber(it);
    };
    $.each.call($__require('14') ? $.getNames(Base) : ('MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), function(key) {
      if (has(Base, key) && !has($Number, key)) {
        $.setDesc($Number, key, $.getDesc(Base, key));
      }
    });
    $Number.prototype = proto;
    proto.constructor = $Number;
    $__require('2c')(global, NUMBER, $Number);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4c", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4d", ["13", "2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      _isFinite = $__require('2b').isFinite;
  $export($export.S, 'Number', {isFinite: function isFinite(it) {
      return typeof it == 'number' && _isFinite(it);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4e", ["13", "4f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {isInteger: $__require('4f')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("50", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {isNaN: function isNaN(number) {
      return number != number;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4f", ["1e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e'),
      floor = Math.floor;
  module.exports = function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor(it) === it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("51", ["13", "4f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      isInteger = $__require('4f'),
      abs = Math.abs;
  $export($export.S, 'Number', {isSafeInteger: function isSafeInteger(number) {
      return isInteger(number) && abs(number) <= 0x1fffffffffffff;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("52", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("53", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("54", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {parseFloat: parseFloat});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("55", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Number', {parseInt: parseInt});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("56", ["13", "57"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      log1p = $__require('57'),
      sqrt = Math.sqrt,
      $acosh = Math.acosh;
  $export($export.S + $export.F * !($acosh && Math.floor($acosh(Number.MAX_VALUE)) == 710), 'Math', {acosh: function acosh(x) {
      return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("58", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  function asinh(x) {
    return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
  }
  $export($export.S, 'Math', {asinh: asinh});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("59", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {atanh: function atanh(x) {
      return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5a", ["13", "5b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      sign = $__require('5b');
  $export($export.S, 'Math', {cbrt: function cbrt(x) {
      return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5c", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {clz32: function clz32(x) {
      return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5d", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      exp = Math.exp;
  $export($export.S, 'Math', {cosh: function cosh(x) {
      return (exp(x = +x) + exp(-x)) / 2;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5e", ["13", "5f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {expm1: $__require('5f')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("60", ["13", "5b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      sign = $__require('5b'),
      pow = Math.pow,
      EPSILON = pow(2, -52),
      EPSILON32 = pow(2, -23),
      MAX32 = pow(2, 127) * (2 - EPSILON32),
      MIN32 = pow(2, -126);
  var roundTiesToEven = function(n) {
    return n + 1 / EPSILON - 1 / EPSILON;
  };
  $export($export.S, 'Math', {fround: function fround(x) {
      var $abs = Math.abs(x),
          $sign = sign(x),
          a,
          result;
      if ($abs < MIN32)
        return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs);
      if (result > MAX32 || result != result)
        return $sign * Infinity;
      return $sign * result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("61", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      abs = Math.abs;
  $export($export.S, 'Math', {hypot: function hypot(value1, value2) {
      var sum = 0,
          i = 0,
          $$ = arguments,
          $$len = $$.length,
          larg = 0,
          arg,
          div;
      while (i < $$len) {
        arg = abs($$[i++]);
        if (larg < arg) {
          div = larg / arg;
          sum = sum * div * div + 1;
          larg = arg;
        } else if (arg > 0) {
          div = arg / larg;
          sum += div * div;
        } else
          sum += arg;
      }
      return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("62", ["13", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $imul = Math.imul;
  $export($export.S + $export.F * $__require('1b')(function() {
    return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
  }), 'Math', {imul: function imul(x, y) {
      var UINT16 = 0xffff,
          xn = +x,
          yn = +y,
          xl = UINT16 & xn,
          yl = UINT16 & yn;
      return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("63", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {log10: function log10(x) {
      return Math.log(x) / Math.LN10;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("57", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.log1p || function log1p(x) {
    return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("64", ["13", "57"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {log1p: $__require('57')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("65", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {log2: function log2(x) {
      return Math.log(x) / Math.LN2;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.sign || function sign(x) {
    return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("66", ["13", "5b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {sign: $__require('5b')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("67", ["13", "5f", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      expm1 = $__require('5f'),
      exp = Math.exp;
  $export($export.S + $export.F * $__require('1b')(function() {
    return !Math.sinh(-2e-17) != -2e-17;
  }), 'Math', {sinh: function sinh(x) {
      return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5f", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Math.expm1 || function expm1(x) {
    return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("68", ["13", "5f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      expm1 = $__require('5f'),
      exp = Math.exp;
  $export($export.S, 'Math', {tanh: function tanh(x) {
      var a = expm1(x = +x),
          b = expm1(-x);
      return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("69", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Math', {trunc: function trunc(it) {
      return (it > 0 ? Math.floor : Math.ceil)(it);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6a", ["13", "22"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      toIndex = $__require('22'),
      fromCharCode = String.fromCharCode,
      $fromCodePoint = String.fromCodePoint;
  $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {fromCodePoint: function fromCodePoint(x) {
      var res = [],
          $$ = arguments,
          $$len = $$.length,
          i = 0,
          code;
      while ($$len > i) {
        code = +$$[i++];
        if (toIndex(code, 0x10ffff) !== code)
          throw RangeError(code + ' is not a valid code point');
        res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
      }
      return res.join('');
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6b", ["13", "20", "23"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      toIObject = $__require('20'),
      toLength = $__require('23');
  $export($export.S, 'String', {raw: function raw(callSite) {
      var tpl = toIObject(callSite.raw),
          len = toLength(tpl.length),
          $$ = arguments,
          $$len = $$.length,
          res = [],
          i = 0;
      while (len > i) {
        res.push(String(tpl[i++]));
        if (i < $$len)
          res.push(String($$[i]));
      }
      return res.join('');
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6c", ["4b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('4b')('trim', function($trim) {
    return function trim() {
      return $trim(this, 3);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6d", ["6e", "6f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('6e')(true);
  $__require('6f')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("70", ["13", "6e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $at = $__require('6e')(false);
  $export($export.P, 'String', {codePointAt: function codePointAt(pos) {
      return $at(this, pos);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("71", ["13", "23", "72", "73"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      toLength = $__require('23'),
      context = $__require('72'),
      ENDS_WITH = 'endsWith',
      $endsWith = ''[ENDS_WITH];
  $export($export.P + $export.F * $__require('73')(ENDS_WITH), 'String', {endsWith: function endsWith(searchString) {
      var that = context(this, searchString, ENDS_WITH),
          $$ = arguments,
          endPosition = $$.length > 1 ? $$[1] : undefined,
          len = toLength(that.length),
          end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
          search = String(searchString);
      return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("74", ["13", "72", "73"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      context = $__require('72'),
      INCLUDES = 'includes';
  $export($export.P + $export.F * $__require('73')(INCLUDES), 'String', {includes: function includes(searchString) {
      return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("75", ["13", "76"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.P, 'String', {repeat: $__require('76')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("72", ["77", "78"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isRegExp = $__require('77'),
      defined = $__require('78');
  module.exports = function(that, searchString, NAME) {
    if (isRegExp(searchString))
      throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("73", ["2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var MATCH = $__require('2f')('match');
  module.exports = function(KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) {}
    }
    return true;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("79", ["13", "23", "72", "73"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      toLength = $__require('23'),
      context = $__require('72'),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];
  $export($export.P + $export.F * $__require('73')(STARTS_WITH), 'String', {startsWith: function startsWith(searchString) {
      var that = context(this, searchString, STARTS_WITH),
          $$ = arguments,
          index = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7a", ["7b", "13", "1f", "7c", "7d", "23", "7e", "7f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('7b'),
      $export = $__require('13'),
      toObject = $__require('1f'),
      call = $__require('7c'),
      isArrayIter = $__require('7d'),
      toLength = $__require('23'),
      getIterFn = $__require('7e');
  $export($export.S + $export.F * !$__require('7f')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("80", ["13", "1b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S + $export.F * $__require('1b')(function() {
    function F() {}
    return !(Array.of.call(F) instanceof F);
  }), 'Array', {of: function of() {
      var index = 0,
          $$ = arguments,
          $$len = $$.length,
          result = new (typeof this == 'function' ? this : Array)($$len);
      while ($$len > index)
        result[index] = $$[index++];
      result.length = $$len;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("81", ["82"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('82')('Array');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("83", ["1f", "22", "23"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('1f'),
      toIndex = $__require('22'),
      toLength = $__require('23');
  module.exports = [].copyWithin || function copyWithin(target, start) {
    var O = toObject(this),
        len = toLength(O.length),
        to = toIndex(target, len),
        from = toIndex(start, len),
        $$ = arguments,
        end = $$.length > 2 ? $$[2] : undefined,
        count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to),
        inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O)
        O[to] = O[from];
      else
        delete O[to];
      to += inc;
      from += inc;
    }
    return O;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("84", ["13", "83", "85"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.P, 'Array', {copyWithin: $__require('83')});
  $__require('85')('copyWithin');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("86", ["1f", "22", "23"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('1f'),
      toIndex = $__require('22'),
      toLength = $__require('23');
  module.exports = [].fill || function fill(value) {
    var O = toObject(this),
        length = toLength(O.length),
        $$ = arguments,
        $$len = $$.length,
        index = toIndex($$len > 1 ? $$[1] : undefined, length),
        end = $$len > 2 ? $$[2] : undefined,
        endPos = end === undefined ? length : toIndex(end, length);
    while (endPos > index)
      O[index++] = value;
    return O;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("87", ["13", "86", "85"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.P, 'Array', {fill: $__require('86')});
  $__require('85')('fill');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("88", ["13", "26", "85"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $find = $__require('26')(5),
      KEY = 'find',
      forced = true;
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $export($export.P + $export.F * forced, 'Array', {find: function find(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('85')(KEY);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("89", ["13", "26", "85"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $find = $__require('26')(6),
      KEY = 'findIndex',
      forced = true;
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $export($export.P + $export.F * forced, 'Array', {findIndex: function findIndex(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('85')(KEY);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("77", ["1e", "19", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e'),
      cof = $__require('19'),
      MATCH = $__require('2f')('match');
  module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8a", ["12", "2b", "77", "8b", "14", "1b", "2f", "2c", "82"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      global = $__require('2b'),
      isRegExp = $__require('77'),
      $flags = $__require('8b'),
      $RegExp = global.RegExp,
      Base = $RegExp,
      proto = $RegExp.prototype,
      re1 = /a/g,
      re2 = /a/g,
      CORRECT_NEW = new $RegExp(re1) !== re1;
  if ($__require('14') && (!CORRECT_NEW || $__require('1b')(function() {
    re2[$__require('2f')('match')] = false;
    return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
  }))) {
    $RegExp = function RegExp(p, f) {
      var piRE = isRegExp(p),
          fiU = f === undefined;
      return !(this instanceof $RegExp) && piRE && p.constructor === $RegExp && fiU ? p : CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f);
    };
    $.each.call($.getNames(Base), function(key) {
      key in $RegExp || $.setDesc($RegExp, key, {
        configurable: true,
        get: function() {
          return Base[key];
        },
        set: function(it) {
          Base[key] = it;
        }
      });
    });
    proto.constructor = $RegExp;
    $RegExp.prototype = proto;
    $__require('2c')(global, 'RegExp', $RegExp);
  }
  $__require('82')('RegExp');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8b", ["1c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('1c');
  module.exports = function() {
    var that = anObject(this),
        result = '';
    if (that.global)
      result += 'g';
    if (that.ignoreCase)
      result += 'i';
    if (that.multiline)
      result += 'm';
    if (that.unicode)
      result += 'u';
    if (that.sticky)
      result += 'y';
    return result;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8c", ["12", "14", "8b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12');
  if ($__require('14') && /./g.flags != 'g')
    $.setDesc(RegExp.prototype, 'flags', {
      configurable: true,
      get: $__require('8b')
    });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8d", ["8e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('8e')('match', 1, function(defined, MATCH) {
    return function match(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8f", ["8e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('8e')('replace', 2, function(defined, REPLACE, $replace) {
    return function replace(searchValue, replaceValue) {
      'use strict';
      var O = defined(this),
          fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("90", ["8e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('8e')('search', 1, function(defined, SEARCH) {
    return function search(regexp) {
      'use strict';
      var O = defined(this),
          fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8e", ["91", "2c", "1b", "78", "2f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hide = $__require('91'),
      redefine = $__require('2c'),
      fails = $__require('1b'),
      defined = $__require('78'),
      wks = $__require('2f');
  module.exports = function(KEY, length, exec) {
    var SYMBOL = wks(KEY),
        original = ''[KEY];
    if (fails(function() {
      var O = {};
      O[SYMBOL] = function() {
        return 7;
      };
      return ''[KEY](O) != 7;
    })) {
      redefine(String.prototype, KEY, exec(defined, SYMBOL, original));
      hide(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {
        return original.call(string, this, arg);
      } : function(string) {
        return original.call(string, this);
      });
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("92", ["8e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('8e')('split', 2, function(defined, SPLIT, $split) {
    return function split(separator, limit) {
      'use strict';
      var O = defined(this),
          fn = separator == undefined ? undefined : separator[SPLIT];
      return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("36", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("93", ["1c", "1d", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('1c'),
      aFunction = $__require('1d'),
      SPECIES = $__require('2f')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("94", ["2b", "95", "19", "f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('2b'),
        macrotask = $__require('95').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('19')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('f'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("96", ["12", "32", "2b", "7b", "3a", "13", "1e", "1c", "1d", "97", "98", "38", "36", "2f", "93", "94", "14", "99", "2e", "82", "45", "7f", "f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('12'),
        LIBRARY = $__require('32'),
        global = $__require('2b'),
        ctx = $__require('7b'),
        classof = $__require('3a'),
        $export = $__require('13'),
        isObject = $__require('1e'),
        anObject = $__require('1c'),
        aFunction = $__require('1d'),
        strictNew = $__require('97'),
        forOf = $__require('98'),
        setProto = $__require('38').set,
        same = $__require('36'),
        SPECIES = $__require('2f')('species'),
        speciesConstructor = $__require('93'),
        asap = $__require('94'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('14')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('99')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('2e')(P, PROMISE);
    $__require('82')(PROMISE);
    Wrapper = $__require('45')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('7f')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('f'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9a", ["9b", "9c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var strong = $__require('9b');
  $__require('9c')('Map', function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("82", ["2b", "12", "14", "2f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      $ = $__require('12'),
      DESCRIPTORS = $__require('14'),
      SPECIES = $__require('2f')('species');
  module.exports = function(KEY) {
    var C = global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9b", ["12", "91", "99", "7b", "97", "78", "98", "6f", "9d", "25", "18", "1e", "82", "14"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      hide = $__require('91'),
      redefineAll = $__require('99'),
      ctx = $__require('7b'),
      strictNew = $__require('97'),
      defined = $__require('78'),
      forOf = $__require('98'),
      $iterDefine = $__require('6f'),
      step = $__require('9d'),
      ID = $__require('25')('id'),
      $has = $__require('18'),
      isObject = $__require('1e'),
      setSpecies = $__require('82'),
      DESCRIPTORS = $__require('14'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9e", ["9b", "9c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var strong = $__require('9b');
  $__require('9c')('Set', function(get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    }}, strong);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9f", ["12", "2c", "a0", "1e", "18", "9c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      redefine = $__require('2c'),
      weak = $__require('a0'),
      isObject = $__require('1e'),
      has = $__require('18'),
      frozenStore = weak.frozenStore,
      WEAK = weak.WEAK,
      isExtensible = Object.isExtensible || isObject,
      tmp = {};
  var $WeakMap = $__require('9c')('WeakMap', function(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      if (isObject(key)) {
        if (!isExtensible(key))
          return frozenStore(this).get(key);
        if (has(key, WEAK))
          return key[WEAK][this._i];
      }
    },
    set: function set(key, value) {
      return weak.def(this, key, value);
    }
  }, weak, true, true);
  if (new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7) {
    $.each.call(['delete', 'has', 'get', 'set'], function(key) {
      var proto = $WeakMap.prototype,
          method = proto[key];
      redefine(proto, key, function(a, b) {
        if (isObject(a) && !isExtensible(a)) {
          var result = frozenStore(this)[key](a, b);
          return key == 'set' ? this : result;
        }
        return method.call(this, a, b);
      });
    });
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("28", ["19"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('19');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a1", ["1e", "28", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e'),
      isArray = $__require('28'),
      SPECIES = $__require('2f')('species');
  module.exports = function(original, length) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || isArray(C.prototype)))
        C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null)
          C = undefined;
      }
    }
    return new (C === undefined ? Array : C)(length);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26", ["7b", "24", "1f", "23", "a1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('7b'),
      IObject = $__require('24'),
      toObject = $__require('1f'),
      toLength = $__require('23'),
      asc = $__require('a1');
  module.exports = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a0", ["91", "99", "1c", "1e", "97", "98", "26", "18", "25"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hide = $__require('91'),
      redefineAll = $__require('99'),
      anObject = $__require('1c'),
      isObject = $__require('1e'),
      strictNew = $__require('97'),
      forOf = $__require('98'),
      createArrayMethod = $__require('26'),
      $has = $__require('18'),
      WEAK = $__require('25')('weak'),
      isExtensible = Object.isExtensible || isObject,
      arrayFind = createArrayMethod(5),
      arrayFindIndex = createArrayMethod(6),
      id = 0;
  var frozenStore = function(that) {
    return that._l || (that._l = new FrozenStore);
  };
  var FrozenStore = function() {
    this.a = [];
  };
  var findFrozen = function(store, key) {
    return arrayFind(store.a, function(it) {
      return it[0] === key;
    });
  };
  FrozenStore.prototype = {
    get: function(key) {
      var entry = findFrozen(this, key);
      if (entry)
        return entry[1];
    },
    has: function(key) {
      return !!findFrozen(this, key);
    },
    set: function(key, value) {
      var entry = findFrozen(this, key);
      if (entry)
        entry[1] = value;
      else
        this.a.push([key, value]);
    },
    'delete': function(key) {
      var index = arrayFindIndex(this.a, function(it) {
        return it[0] === key;
      });
      if (~index)
        this.a.splice(index, 1);
      return !!~index;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = id++;
        that._l = undefined;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        'delete': function(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this)['delete'](key);
          return $has(key, WEAK) && $has(key[WEAK], this._i) && delete key[WEAK][this._i];
        },
        has: function has(key) {
          if (!isObject(key))
            return false;
          if (!isExtensible(key))
            return frozenStore(this).has(key);
          return $has(key, WEAK) && $has(key[WEAK], this._i);
        }
      });
      return C;
    },
    def: function(that, key, value) {
      if (!isExtensible(anObject(key))) {
        frozenStore(that).set(key, value);
      } else {
        $has(key, WEAK) || hide(key, WEAK, {});
        key[WEAK][that._i] = value;
      }
      return that;
    },
    frozenStore: frozenStore,
    WEAK: WEAK
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("99", ["2c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = $__require('2c');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("97", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7f", ["2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = $__require('2f')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9c", ["2b", "13", "2c", "99", "98", "97", "1e", "1b", "7f", "2e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      $export = $__require('13'),
      redefine = $__require('2c'),
      redefineAll = $__require('99'),
      forOf = $__require('98'),
      strictNew = $__require('97'),
      isObject = $__require('1e'),
      fails = $__require('1b'),
      $iterDetect = $__require('7f'),
      setToStringTag = $__require('2e');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    var fixMethod = function(KEY) {
      var fn = proto[KEY];
      redefine(proto, KEY, KEY == 'delete' ? function(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) {
        fn.call(this, a === 0 ? 0 : a);
        return this;
      } : function set(a, b) {
        fn.call(this, a === 0 ? 0 : a, b);
        return this;
      });
    };
    if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      var instance = new C,
          HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance,
          THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
          }),
          ACCEPT_ITERABLES = $iterDetect(function(iter) {
            new C(iter);
          }),
          BUGGY_ZERO;
      if (!ACCEPT_ITERABLES) {
        C = wrapper(function(target, iterable) {
          strictNew(target, C, NAME);
          var that = new Base;
          if (iterable != undefined)
            forOf(iterable, IS_MAP, that[ADDER], that);
          return that;
        });
        C.prototype = proto;
        proto.constructor = C;
      }
      IS_WEAK || instance.forEach(function(val, key) {
        BUGGY_ZERO = 1 / key === -Infinity;
      });
      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }
      if (BUGGY_ZERO || HASNT_CHAINING)
        fixMethod(ADDER);
      if (IS_WEAK && proto.clear)
        delete proto.clear;
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F * (C != Base), O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a2", ["a0", "9c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var weak = $__require('a0');
  $__require('9c')('WeakSet', function(get) {
    return function WeakSet() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return weak.def(this, value, true);
    }}, weak, false, true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a3", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      _apply = Function.apply;
  $export($export.S, 'Reflect', {apply: function apply(target, thisArgument, argumentsList) {
      return _apply.call(target, thisArgument, argumentsList);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a4", ["12", "13", "1d", "1c", "1e", "45", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      $export = $__require('13'),
      aFunction = $__require('1d'),
      anObject = $__require('1c'),
      isObject = $__require('1e'),
      bind = Function.bind || $__require('45').Function.prototype.bind;
  $export($export.S + $export.F * $__require('1b')(function() {
    function F() {}
    return !(Reflect.construct(function() {}, [], F) instanceof F);
  }), 'Reflect', {construct: function construct(Target, args) {
      aFunction(Target);
      var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
      if (Target == newTarget) {
        if (args != undefined)
          switch (anObject(args).length) {
            case 0:
              return new Target;
            case 1:
              return new Target(args[0]);
            case 2:
              return new Target(args[0], args[1]);
            case 3:
              return new Target(args[0], args[1], args[2]);
            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          }
        var $args = [null];
        $args.push.apply($args, args);
        return new (bind.apply(Target, $args));
      }
      var proto = newTarget.prototype,
          instance = $.create(isObject(proto) ? proto : Object.prototype),
          result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a5", ["12", "13", "1c", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      $export = $__require('13'),
      anObject = $__require('1c');
  $export($export.S + $export.F * $__require('1b')(function() {
    Reflect.defineProperty($.setDesc({}, 1, {value: 1}), 1, {value: 2});
  }), 'Reflect', {defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      try {
        $.setDesc(target, propertyKey, attributes);
        return true;
      } catch (e) {
        return false;
      }
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a6", ["13", "12", "1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      getDesc = $__require('12').getDesc,
      anObject = $__require('1c');
  $export($export.S, 'Reflect', {deleteProperty: function deleteProperty(target, propertyKey) {
      var desc = getDesc(anObject(target), propertyKey);
      return desc && !desc.configurable ? false : delete target[propertyKey];
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a7", ["13", "1c", "a8"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      anObject = $__require('1c');
  var Enumerate = function(iterated) {
    this._t = anObject(iterated);
    this._i = 0;
    var keys = this._k = [],
        key;
    for (key in iterated)
      keys.push(key);
  };
  $__require('a8')(Enumerate, 'Object', function() {
    var that = this,
        keys = that._k,
        key;
    do {
      if (that._i >= keys.length)
        return {
          value: undefined,
          done: true
        };
    } while (!((key = keys[that._i++]) in that._t));
    return {
      value: key,
      done: false
    };
  });
  $export($export.S, 'Reflect', {enumerate: function enumerate(target) {
      return new Enumerate(target);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a9", ["12", "18", "13", "1e", "1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      has = $__require('18'),
      $export = $__require('13'),
      isObject = $__require('1e'),
      anObject = $__require('1c');
  function get(target, propertyKey) {
    var receiver = arguments.length < 3 ? target : arguments[2],
        desc,
        proto;
    if (anObject(target) === receiver)
      return target[propertyKey];
    if (desc = $.getDesc(target, propertyKey))
      return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
    if (isObject(proto = $.getProto(target)))
      return get(proto, propertyKey, receiver);
  }
  $export($export.S, 'Reflect', {get: get});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("aa", ["12", "13", "1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      $export = $__require('13'),
      anObject = $__require('1c');
  $export($export.S, 'Reflect', {getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return $.getDesc(anObject(target), propertyKey);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ab", ["13", "12", "1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      getProto = $__require('12').getProto,
      anObject = $__require('1c');
  $export($export.S, 'Reflect', {getPrototypeOf: function getPrototypeOf(target) {
      return getProto(anObject(target));
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ac", ["13"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Reflect', {has: function has(target, propertyKey) {
      return propertyKey in target;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ad", ["13", "1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      anObject = $__require('1c'),
      $isExtensible = Object.isExtensible;
  $export($export.S, 'Reflect', {isExtensible: function isExtensible(target) {
      anObject(target);
      return $isExtensible ? $isExtensible(target) : true;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ae", ["13", "af"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S, 'Reflect', {ownKeys: $__require('af')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b0", ["13", "1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      anObject = $__require('1c'),
      $preventExtensions = Object.preventExtensions;
  $export($export.S, 'Reflect', {preventExtensions: function preventExtensions(target) {
      anObject(target);
      try {
        if ($preventExtensions)
          $preventExtensions(target);
        return true;
      } catch (e) {
        return false;
      }
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b1", ["12", "18", "13", "15", "1c", "1e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      has = $__require('18'),
      $export = $__require('13'),
      createDesc = $__require('15'),
      anObject = $__require('1c'),
      isObject = $__require('1e');
  function set(target, propertyKey, V) {
    var receiver = arguments.length < 4 ? target : arguments[3],
        ownDesc = $.getDesc(anObject(target), propertyKey),
        existingDescriptor,
        proto;
    if (!ownDesc) {
      if (isObject(proto = $.getProto(target))) {
        return set(proto, propertyKey, V, receiver);
      }
      ownDesc = createDesc(0);
    }
    if (has(ownDesc, 'value')) {
      if (ownDesc.writable === false || !isObject(receiver))
        return false;
      existingDescriptor = $.getDesc(receiver, propertyKey) || createDesc(0);
      existingDescriptor.value = V;
      $.setDesc(receiver, propertyKey, existingDescriptor);
      return true;
    }
    return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
  }
  $export($export.S, 'Reflect', {set: set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("38", ["12", "1e", "1c", "7b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('12').getDesc,
      isObject = $__require('1e'),
      anObject = $__require('1c');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('7b')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b2", ["13", "38"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      setProto = $__require('38');
  if (setProto)
    $export($export.S, 'Reflect', {setPrototypeOf: function setPrototypeOf(target, proto) {
        setProto.check(target, proto);
        try {
          setProto.set(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22", ["21"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('21'),
      max = Math.max,
      min = Math.min;
  module.exports = function(index, length) {
    index = toInteger(index);
    return index < 0 ? max(index + length, 0) : min(index, length);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27", ["20", "23", "22"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('20'),
      toLength = $__require('23'),
      toIndex = $__require('22');
  module.exports = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIObject($this),
          length = toLength(O.length),
          index = toIndex(fromIndex, length),
          value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value)
            return true;
        }
      else
        for (; length > index; index++)
          if (IS_INCLUDES || index in O) {
            if (O[index] === el)
              return IS_INCLUDES || index;
          }
      return !IS_INCLUDES && -1;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b3", ["13", "27", "85"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $includes = $__require('27')(true);
  $export($export.P, 'Array', {includes: function includes(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }});
  $__require('85')('includes');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6e", ["21", "78"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('21'),
      defined = $__require('78');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b4", ["13", "6e"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $at = $__require('6e')(true);
  $export($export.P, 'String', {at: function at(pos) {
      return $at(this, pos);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b5", ["13", "b6"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $pad = $__require('b6');
  $export($export.P, 'String', {padLeft: function padLeft(maxLength) {
      return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("76", ["21", "78"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('21'),
      defined = $__require('78');
  module.exports = function repeat(count) {
    var str = String(defined(this)),
        res = '',
        n = toInteger(count);
    if (n < 0 || n == Infinity)
      throw RangeError("Count can't be negative");
    for (; n > 0; (n >>>= 1) && (str += str))
      if (n & 1)
        res += str;
    return res;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b6", ["23", "76", "78"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toLength = $__require('23'),
      repeat = $__require('76'),
      defined = $__require('78');
  module.exports = function(that, maxLength, fillString, left) {
    var S = String(defined(that)),
        stringLength = S.length,
        fillStr = fillString === undefined ? ' ' : String(fillString),
        intMaxLength = toLength(maxLength);
    if (intMaxLength <= stringLength)
      return S;
    if (fillStr == '')
      fillStr = ' ';
    var fillLen = intMaxLength - stringLength,
        stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen)
      stringFiller = stringFiller.slice(0, fillLen);
    return left ? stringFiller + S : S + stringFiller;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b7", ["13", "b6"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $pad = $__require('b6');
  $export($export.P, 'String', {padRight: function padRight(maxLength) {
      return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b8", ["4b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('4b')('trimLeft', function($trim) {
    return function trimLeft() {
      return $trim(this, 1);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4b", ["13", "78", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      defined = $__require('78'),
      fails = $__require('1b'),
      spaces = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF',
      space = '[' + spaces + ']',
      non = '\u200b\u0085',
      ltrim = RegExp('^' + space + space + '*'),
      rtrim = RegExp(space + space + '*$');
  var exporter = function(KEY, exec) {
    var exp = {};
    exp[KEY] = exec(trim);
    $export($export.P + $export.F * fails(function() {
      return !!spaces[KEY]() || non[KEY]() != non;
    }), 'String', exp);
  };
  var trim = exporter.trim = function(string, TYPE) {
    string = String(defined(string));
    if (TYPE & 1)
      string = string.replace(ltrim, '');
    if (TYPE & 2)
      string = string.replace(rtrim, '');
    return string;
  };
  module.exports = exporter;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b9", ["4b"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('4b')('trimRight', function($trim) {
    return function trimRight() {
      return $trim(this, 2);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ba", ["13", "bb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $re = $__require('bb')(/[\\^$*+?.()|[\]{}]/g, '\\$&');
  $export($export.S, 'RegExp', {escape: function escape(it) {
      return $re(it);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bc", ["12", "13", "af", "20", "15"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      $export = $__require('13'),
      ownKeys = $__require('af'),
      toIObject = $__require('20'),
      createDesc = $__require('15');
  $export($export.S, 'Object', {getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
      var O = toIObject(object),
          setDesc = $.setDesc,
          getDesc = $.getDesc,
          keys = ownKeys(O),
          result = {},
          i = 0,
          key,
          D;
      while (keys.length > i) {
        D = getDesc(O, key = keys[i++]);
        if (key in result)
          setDesc(result, key, createDesc(0, D));
        else
          result[key] = D;
      }
      return result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bd", ["13", "be"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $values = $__require('be')(false);
  $export($export.S, 'Object', {values: function values(it) {
      return $values(it);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("be", ["12", "20"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      toIObject = $__require('20'),
      isEnum = $.isEnum;
  module.exports = function(isEntries) {
    return function(it) {
      var O = toIObject(it),
          keys = $.getKeys(O),
          length = keys.length,
          i = 0,
          result = [],
          key;
      while (length > i)
        if (isEnum.call(O, key = keys[i++])) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      return result;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bf", ["13", "be"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $entries = $__require('be')(true);
  $export($export.S, 'Object', {entries: function entries(it) {
      return $entries(it);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c0", ["13", "c1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.P, 'Map', {toJSON: $__require('c1')('Map')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c1", ["98", "3a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forOf = $__require('98'),
      classof = $__require('3a');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c2", ["13", "c1"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.P, 'Set', {toJSON: $__require('c1')('Set')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c3", ["12", "13", "7b", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      $export = $__require('13'),
      $ctx = $__require('7b'),
      $Array = $__require('45').Array || Array,
      statics = {};
  var setStatics = function(keys, length) {
    $.each.call(keys.split(','), function(key) {
      if (length == undefined && key in $Array)
        statics[key] = $Array[key];
      else if (key in [])
        statics[key] = $ctx(Function.call, [][key], length);
    });
  };
  setStatics('pop,reverse,shift,keys,values,entries', 1);
  setStatics('indexOf,every,some,forEach,map,filter,find,findIndex,includes', 3);
  setStatics('join,slice,concat,push,splice,unshift,sort,lastIndexOf,' + 'reduce,reduceRight,copyWithin,fill');
  $export($export.S, 'Array', statics);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c4", ["2b", "13", "1a", "c5"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      $export = $__require('13'),
      invoke = $__require('1a'),
      partial = $__require('c5'),
      navigator = global.navigator,
      MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent);
  var wrap = function(set) {
    return MSIE ? function(fn, time) {
      return set(invoke(partial, [].slice.call(arguments, 2), typeof fn == 'function' ? fn : Function(fn)), time);
    } : set;
  };
  $export($export.G + $export.B + $export.F * MSIE, {
    setTimeout: wrap(global.setTimeout),
    setInterval: wrap(global.setInterval)
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16", ["2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('2b').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17", ["1e", "2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e'),
      document = $__require('2b').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c6", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c7", ["c6"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('c6');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c8", ["c7"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : $__require('c7');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f", ["c8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('c8');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("95", ["7b", "1a", "16", "17", "2b", "19", "f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = $__require('7b'),
        invoke = $__require('1a'),
        html = $__require('16'),
        cel = $__require('17'),
        global = $__require('2b'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('19')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('f'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c9", ["13", "95"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      $task = $__require('95');
  $export($export.G + $export.B, {
    setImmediate: $task.set,
    clearImmediate: $task.clear
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("85", ["2f", "91"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNSCOPABLES = $__require('2f')('unscopables'),
      ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined)
    $__require('91')(ArrayProto, UNSCOPABLES, {});
  module.exports = function(key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ca", ["85", "9d", "cb", "20", "6f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('85'),
      step = $__require('9d'),
      Iterators = $__require('cb'),
      toIObject = $__require('20');
  module.exports = $__require('6f')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cc", ["ca", "2b", "91", "cb", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('ca');
  var global = $__require('2b'),
      hide = $__require('91'),
      Iterators = $__require('cb'),
      ITERATOR = $__require('2f')('iterator'),
      NL = global.NodeList,
      HTC = global.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype,
      ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  if (NLProto && !NLProto[ITERATOR])
    hide(NLProto, ITERATOR, ArrayValues);
  if (HTCProto && !HTCProto[ITERATOR])
    hide(HTCProto, ITERATOR, ArrayValues);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cd", ["11", "2a", "33", "35", "37", "39", "3b", "3d", "3e", "3f", "40", "41", "42", "43", "44", "46", "47", "48", "4a", "4c", "4d", "4e", "50", "51", "52", "53", "54", "55", "56", "58", "59", "5a", "5c", "5d", "5e", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "70", "71", "74", "75", "79", "7a", "80", "ca", "81", "84", "87", "88", "89", "8a", "8c", "8d", "8f", "90", "92", "96", "9a", "9e", "9f", "a2", "a3", "a4", "a5", "a6", "a7", "a9", "aa", "ab", "ac", "ad", "ae", "b0", "b1", "b2", "b3", "b4", "b5", "b7", "b8", "b9", "ba", "bc", "bd", "bf", "c0", "c2", "c3", "c4", "c9", "cc", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('11');
  $__require('2a');
  $__require('33');
  $__require('35');
  $__require('37');
  $__require('39');
  $__require('3b');
  $__require('3d');
  $__require('3e');
  $__require('3f');
  $__require('40');
  $__require('41');
  $__require('42');
  $__require('43');
  $__require('44');
  $__require('46');
  $__require('47');
  $__require('48');
  $__require('4a');
  $__require('4c');
  $__require('4d');
  $__require('4e');
  $__require('50');
  $__require('51');
  $__require('52');
  $__require('53');
  $__require('54');
  $__require('55');
  $__require('56');
  $__require('58');
  $__require('59');
  $__require('5a');
  $__require('5c');
  $__require('5d');
  $__require('5e');
  $__require('60');
  $__require('61');
  $__require('62');
  $__require('63');
  $__require('64');
  $__require('65');
  $__require('66');
  $__require('67');
  $__require('68');
  $__require('69');
  $__require('6a');
  $__require('6b');
  $__require('6c');
  $__require('6d');
  $__require('70');
  $__require('71');
  $__require('74');
  $__require('75');
  $__require('79');
  $__require('7a');
  $__require('80');
  $__require('ca');
  $__require('81');
  $__require('84');
  $__require('87');
  $__require('88');
  $__require('89');
  $__require('8a');
  $__require('8c');
  $__require('8d');
  $__require('8f');
  $__require('90');
  $__require('92');
  $__require('96');
  $__require('9a');
  $__require('9e');
  $__require('9f');
  $__require('a2');
  $__require('a3');
  $__require('a4');
  $__require('a5');
  $__require('a6');
  $__require('a7');
  $__require('a9');
  $__require('aa');
  $__require('ab');
  $__require('ac');
  $__require('ad');
  $__require('ae');
  $__require('b0');
  $__require('b1');
  $__require('b2');
  $__require('b3');
  $__require('b4');
  $__require('b5');
  $__require('b7');
  $__require('b8');
  $__require('b9');
  $__require('ba');
  $__require('bc');
  $__require('bd');
  $__require('bf');
  $__require('c0');
  $__require('c2');
  $__require('c3');
  $__require('c4');
  $__require('c9');
  $__require('cc');
  module.exports = $__require('45');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("30", ["12", "20"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      toIObject = $__require('20');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7c", ["1c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('1c');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7d", ["cb", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('cb'),
      ITERATOR = $__require('2f')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23", ["21"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('21'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("98", ["7b", "7c", "7d", "1c", "23", "7e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('7b'),
      call = $__require('7c'),
      isArrayIter = $__require('7d'),
      anObject = $__require('1c'),
      toLength = $__require('23'),
      getIterFn = $__require('7e');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9d", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ce", ["12", "7b", "13", "15", "34", "30", "1d", "98", "cf", "a8", "9d", "1e", "20", "14", "18"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      ctx = $__require('7b'),
      $export = $__require('13'),
      createDesc = $__require('15'),
      assign = $__require('34'),
      keyOf = $__require('30'),
      aFunction = $__require('1d'),
      forOf = $__require('98'),
      isIterable = $__require('cf'),
      $iterCreate = $__require('a8'),
      step = $__require('9d'),
      isObject = $__require('1e'),
      toIObject = $__require('20'),
      DESCRIPTORS = $__require('14'),
      has = $__require('18'),
      getKeys = $.getKeys;
  var createDictMethod = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_EVERY = TYPE == 4;
    return function(object, callbackfn, that) {
      var f = ctx(callbackfn, that, 3),
          O = toIObject(object),
          result = IS_MAP || TYPE == 7 || TYPE == 2 ? new (typeof this == 'function' ? this : Dict) : undefined,
          key,
          val,
          res;
      for (key in O)
        if (has(O, key)) {
          val = O[key];
          res = f(val, key, object);
          if (TYPE) {
            if (IS_MAP)
              result[key] = res;
            else if (res)
              switch (TYPE) {
                case 2:
                  result[key] = val;
                  break;
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return key;
                case 7:
                  result[res[0]] = res[1];
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return TYPE == 3 || IS_EVERY ? IS_EVERY : result;
    };
  };
  var findKey = createDictMethod(6);
  var createDictIter = function(kind) {
    return function(it) {
      return new DictIterator(it, kind);
    };
  };
  var DictIterator = function(iterated, kind) {
    this._t = toIObject(iterated);
    this._a = getKeys(iterated);
    this._i = 0;
    this._k = kind;
  };
  $iterCreate(DictIterator, 'Dict', function() {
    var that = this,
        O = that._t,
        keys = that._a,
        kind = that._k,
        key;
    do {
      if (that._i >= keys.length) {
        that._t = undefined;
        return step(1);
      }
    } while (!has(O, key = keys[that._i++]));
    if (kind == 'keys')
      return step(0, key);
    if (kind == 'values')
      return step(0, O[key]);
    return step(0, [key, O[key]]);
  });
  function Dict(iterable) {
    var dict = $.create(null);
    if (iterable != undefined) {
      if (isIterable(iterable)) {
        forOf(iterable, true, function(key, value) {
          dict[key] = value;
        });
      } else
        assign(dict, iterable);
    }
    return dict;
  }
  Dict.prototype = null;
  function reduce(object, mapfn, init) {
    aFunction(mapfn);
    var O = toIObject(object),
        keys = getKeys(O),
        length = keys.length,
        i = 0,
        memo,
        key;
    if (arguments.length < 3) {
      if (!length)
        throw TypeError('Reduce of empty object with no initial value');
      memo = O[keys[i++]];
    } else
      memo = Object(init);
    while (length > i)
      if (has(O, key = keys[i++])) {
        memo = mapfn(memo, O[key], key, object);
      }
    return memo;
  }
  function includes(object, el) {
    return (el == el ? keyOf(object, el) : findKey(object, function(it) {
      return it != it;
    })) !== undefined;
  }
  function get(object, key) {
    if (has(object, key))
      return object[key];
  }
  function set(object, key, value) {
    if (DESCRIPTORS && key in Object)
      $.setDesc(object, key, createDesc(0, value));
    else
      object[key] = value;
    return object;
  }
  function isDict(it) {
    return isObject(it) && $.getProto(it) === Dict.prototype;
  }
  $export($export.G + $export.F, {Dict: Dict});
  $export($export.S, 'Dict', {
    keys: createDictIter('keys'),
    values: createDictIter('values'),
    entries: createDictIter('entries'),
    forEach: createDictMethod(0),
    map: createDictMethod(1),
    filter: createDictMethod(2),
    some: createDictMethod(3),
    every: createDictMethod(4),
    find: createDictMethod(5),
    findKey: findKey,
    mapPairs: createDictMethod(7),
    reduce: reduce,
    keyOf: keyOf,
    includes: includes,
    has: has,
    get: get,
    set: set,
    isDict: isDict
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7e", ["3a", "2f", "cb", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('3a'),
      ITERATOR = $__require('2f')('iterator'),
      Iterators = $__require('cb');
  module.exports = $__require('45').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d0", ["1c", "7e", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('1c'),
      get = $__require('7e');
  module.exports = $__require('45').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cf", ["3a", "2f", "cb", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('3a'),
      ITERATOR = $__require('2f')('iterator'),
      Iterators = $__require('cb');
  module.exports = $__require('45').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d1", ["2b", "45", "13", "c5"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      core = $__require('45'),
      $export = $__require('13'),
      partial = $__require('c5');
  $export($export.G + $export.F, {delay: function delay(time) {
      return new (core.Promise || global.Promise)(function(resolve) {
        setTimeout(partial.call(resolve, true), time);
      });
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d2", ["2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('2b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c5", ["d2", "1a", "1d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var path = $__require('d2'),
      invoke = $__require('1a'),
      aFunction = $__require('1d');
  module.exports = function() {
    var fn = aFunction(this),
        length = arguments.length,
        pargs = Array(length),
        i = 0,
        _ = path._,
        holder = false;
    while (length > i)
      if ((pargs[i] = arguments[i++]) === _)
        holder = true;
    return function() {
      var that = this,
          $$ = arguments,
          $$len = $$.length,
          j = 0,
          k = 0,
          args;
      if (!holder && !$$len)
        return invoke(fn, pargs, that);
      args = pargs.slice();
      if (holder)
        for (; length > j; j++)
          if (args[j] === _)
            args[j] = $$[k++];
      while ($$len > k)
        args.push($$[k++]);
      return invoke(fn, args, that);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d3", ["d2", "13", "45", "c5"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var path = $__require('d2'),
      $export = $__require('13');
  $__require('45')._ = path._ = path._ || {};
  $export($export.P + $export.F, 'Function', {part: $__require('c5')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d4", ["13", "1e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S + $export.F, 'Object', {isObject: $__require('1e')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3a", ["19", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('19'),
      TAG = $__require('2f')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d5", ["13", "3a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  $export($export.S + $export.F, 'Object', {classof: $__require('3a')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d6", ["13", "d7"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      define = $__require('d7');
  $export($export.S + $export.F, 'Object', {define: define});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1c", ["1e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('1e');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("af", ["12", "1c", "2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      anObject = $__require('1c'),
      Reflect = $__require('2b').Reflect;
  module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
    var keys = $.getNames(anObject(it)),
        getSymbols = $.getSymbols;
    return getSymbols ? keys.concat(getSymbols(it)) : keys;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20", ["24", "78"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('24'),
      defined = $__require('78');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d7", ["12", "af", "20"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      ownKeys = $__require('af'),
      toIObject = $__require('20');
  module.exports = function define(target, mixin) {
    var keys = ownKeys(toIObject(mixin)),
        length = keys.length,
        i = 0,
        key;
    while (length > i)
      $.setDesc(target, key = keys[i++], $.getDesc(mixin, key));
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d8", ["13", "d7", "12"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13'),
      define = $__require('d7'),
      create = $__require('12').create;
  $export($export.S + $export.F, 'Object', {make: function(proto, mixin) {
      return define(create(proto), mixin);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("32", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = false;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cb", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a8", ["12", "15", "2e", "91", "2f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      descriptor = $__require('15'),
      setToStringTag = $__require('2e'),
      IteratorPrototype = {};
  $__require('91')(IteratorPrototype, $__require('2f')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2e", ["12", "18", "2f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('12').setDesc,
      has = $__require('18'),
      TAG = $__require('2f')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2d", ["2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2f", ["2d", "25", "2b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('2d')('wks'),
      uid = $__require('25'),
      Symbol = $__require('2b').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6f", ["32", "13", "2c", "91", "18", "cb", "a8", "2e", "12", "2f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('32'),
      $export = $__require('13'),
      redefine = $__require('2c'),
      hide = $__require('91'),
      has = $__require('18'),
      Iterators = $__require('cb'),
      $iterCreate = $__require('a8'),
      setToStringTag = $__require('2e'),
      getProto = $__require('12').getProto,
      ITERATOR = $__require('2f')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d9", ["6f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('6f')(Number, 'Number', function(iterated) {
    this._l = +iterated;
    this._i = 0;
  }, function() {
    var i = this._i++,
        done = !(i < this._l);
    return {
      done: done,
      value: done ? undefined : i
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("da", ["13", "bb"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  var $re = $__require('bb')(/[&<>"']/g, {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  });
  $export($export.P + $export.F, 'String', {escapeHTML: function escapeHTML() {
      return $re(this);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bb", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(regExp, replace) {
    var replacer = replace === Object(replace) ? function(part) {
      return replace[part];
    } : replace;
    return function(it) {
      return String(it).replace(regExp, replacer);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("db", ["13", "bb"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('13');
  var $re = $__require('bb')(/&(?:amp|lt|gt|quot|apos);/g, {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': "'"
  });
  $export($export.P + $export.F, 'String', {unescapeHTML: function unescapeHTML() {
      return $re(this);
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14", ["1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('1b')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("91", ["12", "15", "14"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      createDesc = $__require('15');
  module.exports = $__require('14') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2c", ["2b", "91", "25", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      hide = $__require('91'),
      SRC = $__require('25')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);
  $__require('45').inspectSource = function(it) {
    return $toString.call(it);
  };
  (module.exports = function(O, key, val, safe) {
    if (typeof val == 'function') {
      val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      val.hasOwnProperty('name') || hide(val, 'name', key);
    }
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe)
        delete O[key];
      hide(O, key, val);
    }
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1d", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7b", ["1d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('1d');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13", ["2b", "45", "91", "2c", "7b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('2b'),
      core = $__require('45'),
      hide = $__require('91'),
      redefine = $__require('2c'),
      ctx = $__require('7b'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
        key,
        own,
        out,
        exp;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      out = (own ? target : source)[key];
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (target && !own)
        redefine(target, key, out);
      if (exports[key] != out)
        hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out)
        expProto[key] = out;
    }
  };
  global.core = core;
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("78", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f", ["78"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('78');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24", ["19"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('19');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("34", ["12", "1f", "24", "1b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      toObject = $__require('1f'),
      IObject = $__require('24');
  module.exports = $__require('1b')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("dc", ["12", "2b", "13", "34"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('12'),
      global = $__require('2b'),
      $export = $__require('13'),
      log = {},
      enabled = true;
  $.each.call(('assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,' + 'info,isIndependentlyComposed,log,markTimeline,profile,profileEnd,table,' + 'time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(','), function(key) {
    log[key] = function() {
      var $console = global.console;
      if (enabled && $console && $console[key]) {
        return Function.apply.call($console[key], $console, arguments);
      }
    };
  });
  $export($export.G + $export.F, {log: $__require('34')(log.log, log, {
      enable: function() {
        enabled = true;
      },
      disable: function() {
        enabled = false;
      }
    })});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("45", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("dd", ["cd", "ce", "7e", "d0", "cf", "d1", "d3", "d4", "d5", "d6", "d8", "d9", "da", "db", "dc", "45"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('cd');
  $__require('ce');
  $__require('7e');
  $__require('d0');
  $__require('cf');
  $__require('d1');
  $__require('d3');
  $__require('d4');
  $__require('d5');
  $__require('d6');
  $__require('d8');
  $__require('d9');
  $__require('da');
  $__require('db');
  $__require('dc');
  module.exports = $__require('45');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("de", ["dd"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('dd');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("df", ["e0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = $__require('e0')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e1", ["e2", "e3", "e4", "e5", "e6", "e7", "e8", "df"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('e2'),
      $export = $__require('e3'),
      toObject = $__require('e4'),
      call = $__require('e5'),
      isArrayIter = $__require('e6'),
      toLength = $__require('e7'),
      getIterFn = $__require('e8');
  $export($export.S + $export.F * !$__require('df')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e9", ["ea", "e1", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('ea');
  $__require('e1');
  module.exports = $__require('eb').Array.from;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ec", ["e9"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('e9'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ed", ["ec"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Array$from = $__require('ec')["default"];
  exports["default"] = function(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++)
        arr2[i] = arr[i];
      return arr2;
    } else {
      return _Array$from(arr);
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ee", ["ef"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, {"THREE": __require("ef")});
  (function() {
    THREE.TrackballControls = function(object, domElement) {
      var _this = this;
      var STATE = {
        NONE: -1,
        ROTATE: 0,
        ZOOM: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_ZOOM_PAN: 4
      };
      this.object = object;
      this.domElement = (domElement !== undefined) ? domElement : document;
      this.enabled = true;
      this.screen = {
        left: 0,
        top: 0,
        width: 0,
        height: 0
      };
      this.rotateSpeed = 1.0;
      this.zoomSpeed = 1.2;
      this.panSpeed = 0.3;
      this.noRotate = false;
      this.noZoom = false;
      this.noPan = false;
      this.staticMoving = false;
      this.dynamicDampingFactor = 0.2;
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.keys = [65, 83, 68];
      this.target = new THREE.Vector3();
      var EPS = 0.000001;
      var lastPosition = new THREE.Vector3();
      var _state = STATE.NONE,
          _prevState = STATE.NONE,
          _eye = new THREE.Vector3(),
          _movePrev = new THREE.Vector2(),
          _moveCurr = new THREE.Vector2(),
          _lastAxis = new THREE.Vector3(),
          _lastAngle = 0,
          _zoomStart = new THREE.Vector2(),
          _zoomEnd = new THREE.Vector2(),
          _touchZoomDistanceStart = 0,
          _touchZoomDistanceEnd = 0,
          _panStart = new THREE.Vector2(),
          _panEnd = new THREE.Vector2();
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.up0 = this.object.up.clone();
      var changeEvent = {type: 'change'};
      var startEvent = {type: 'start'};
      var endEvent = {type: 'end'};
      this.handleResize = function() {
        if (this.domElement === document) {
          this.screen.left = 0;
          this.screen.top = 0;
          this.screen.width = window.innerWidth;
          this.screen.height = window.innerHeight;
        } else {
          var box = this.domElement.getBoundingClientRect();
          var d = this.domElement.ownerDocument.documentElement;
          this.screen.left = box.left + window.pageXOffset - d.clientLeft;
          this.screen.top = box.top + window.pageYOffset - d.clientTop;
          this.screen.width = box.width;
          this.screen.height = box.height;
        }
      };
      this.handleEvent = function(event) {
        if (typeof this[event.type] == 'function') {
          this[event.type](event);
        }
      };
      var getMouseOnScreen = (function() {
        var vector = new THREE.Vector2();
        return function getMouseOnScreen(pageX, pageY) {
          vector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);
          return vector;
        };
      }());
      var getMouseOnCircle = (function() {
        var vector = new THREE.Vector2();
        return function getMouseOnCircle(pageX, pageY) {
          vector.set(((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5)), ((_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width));
          return vector;
        };
      }());
      this.rotateCamera = (function() {
        var axis = new THREE.Vector3(),
            quaternion = new THREE.Quaternion(),
            eyeDirection = new THREE.Vector3(),
            objectUpDirection = new THREE.Vector3(),
            objectSidewaysDirection = new THREE.Vector3(),
            moveDirection = new THREE.Vector3(),
            angle;
        return function rotateCamera() {
          moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);
          angle = moveDirection.length();
          if (angle) {
            _eye.copy(_this.object.position).sub(_this.target);
            eyeDirection.copy(_eye).normalize();
            objectUpDirection.copy(_this.object.up).normalize();
            objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();
            objectUpDirection.setLength(_moveCurr.y - _movePrev.y);
            objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);
            moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));
            axis.crossVectors(moveDirection, _eye).normalize();
            angle *= _this.rotateSpeed;
            quaternion.setFromAxisAngle(axis, angle);
            _eye.applyQuaternion(quaternion);
            _this.object.up.applyQuaternion(quaternion);
            _lastAxis.copy(axis);
            _lastAngle = angle;
          } else if (!_this.staticMoving && _lastAngle) {
            _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);
            _eye.copy(_this.object.position).sub(_this.target);
            quaternion.setFromAxisAngle(_lastAxis, _lastAngle);
            _eye.applyQuaternion(quaternion);
            _this.object.up.applyQuaternion(quaternion);
          }
          _movePrev.copy(_moveCurr);
        };
      }());
      this.zoomCamera = function() {
        var factor;
        if (_state === STATE.TOUCH_ZOOM_PAN) {
          factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
          _touchZoomDistanceStart = _touchZoomDistanceEnd;
          _eye.multiplyScalar(factor);
        } else {
          factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;
          if (factor !== 1.0 && factor > 0.0) {
            _eye.multiplyScalar(factor);
            if (_this.staticMoving) {
              _zoomStart.copy(_zoomEnd);
            } else {
              _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;
            }
          }
        }
      };
      this.panCamera = (function() {
        var mouseChange = new THREE.Vector2(),
            objectUp = new THREE.Vector3(),
            pan = new THREE.Vector3();
        return function panCamera() {
          mouseChange.copy(_panEnd).sub(_panStart);
          if (mouseChange.lengthSq()) {
            mouseChange.multiplyScalar(_eye.length() * _this.panSpeed);
            pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);
            pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));
            _this.object.position.add(pan);
            _this.target.add(pan);
            if (_this.staticMoving) {
              _panStart.copy(_panEnd);
            } else {
              _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));
            }
          }
        };
      }());
      this.checkDistances = function() {
        if (!_this.noZoom || !_this.noPan) {
          if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {
            _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));
            _zoomStart.copy(_zoomEnd);
          }
          if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {
            _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));
            _zoomStart.copy(_zoomEnd);
          }
        }
      };
      this.update = function() {
        _eye.subVectors(_this.object.position, _this.target);
        if (!_this.noRotate) {
          _this.rotateCamera();
        }
        if (!_this.noZoom) {
          _this.zoomCamera();
        }
        if (!_this.noPan) {
          _this.panCamera();
        }
        _this.object.position.addVectors(_this.target, _eye);
        _this.checkDistances();
        _this.object.lookAt(_this.target);
        if (lastPosition.distanceToSquared(_this.object.position) > EPS) {
          _this.dispatchEvent(changeEvent);
          lastPosition.copy(_this.object.position);
        }
      };
      this.reset = function() {
        _state = STATE.NONE;
        _prevState = STATE.NONE;
        _this.target.copy(_this.target0);
        _this.object.position.copy(_this.position0);
        _this.object.up.copy(_this.up0);
        _eye.subVectors(_this.object.position, _this.target);
        _this.object.lookAt(_this.target);
        _this.dispatchEvent(changeEvent);
        lastPosition.copy(_this.object.position);
      };
      function keydown(event) {
        if (_this.enabled === false)
          return;
        window.removeEventListener('keydown', keydown);
        _prevState = _state;
        if (_state !== STATE.NONE) {
          return;
        } else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {
          _state = STATE.ROTATE;
        } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {
          _state = STATE.ZOOM;
        } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {
          _state = STATE.PAN;
        }
      }
      function keyup(event) {
        if (_this.enabled === false)
          return;
        _state = _prevState;
        window.addEventListener('keydown', keydown, false);
      }
      function mousedown(event) {
        if (_this.enabled === false)
          return;
        event.preventDefault();
        event.stopPropagation();
        if (_state === STATE.NONE) {
          _state = event.button;
        }
        if (_state === STATE.ROTATE && !_this.noRotate) {
          _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
          _movePrev.copy(_moveCurr);
        } else if (_state === STATE.ZOOM && !_this.noZoom) {
          _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));
          _zoomEnd.copy(_zoomStart);
        } else if (_state === STATE.PAN && !_this.noPan) {
          _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));
          _panEnd.copy(_panStart);
        }
        document.addEventListener('mousemove', mousemove, false);
        document.addEventListener('mouseup', mouseup, false);
        _this.dispatchEvent(startEvent);
      }
      function mousemove(event) {
        if (_this.enabled === false)
          return;
        event.preventDefault();
        event.stopPropagation();
        if (_state === STATE.ROTATE && !_this.noRotate) {
          _movePrev.copy(_moveCurr);
          _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));
        } else if (_state === STATE.ZOOM && !_this.noZoom) {
          _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
        } else if (_state === STATE.PAN && !_this.noPan) {
          _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));
        }
      }
      function mouseup(event) {
        if (_this.enabled === false)
          return;
        event.preventDefault();
        event.stopPropagation();
        _state = STATE.NONE;
        document.removeEventListener('mousemove', mousemove);
        document.removeEventListener('mouseup', mouseup);
        _this.dispatchEvent(endEvent);
      }
      function mousewheel(event) {
        if (_this.enabled === false)
          return;
        event.preventDefault();
        event.stopPropagation();
        var delta = 0;
        if (event.wheelDelta) {
          delta = event.wheelDelta / 40;
        } else if (event.detail) {
          delta = -event.detail / 3;
        }
        _zoomStart.y += delta * 0.01;
        _this.dispatchEvent(startEvent);
        _this.dispatchEvent(endEvent);
      }
      function touchstart(event) {
        if (_this.enabled === false)
          return;
        switch (event.touches.length) {
          case 1:
            _state = STATE.TOUCH_ROTATE;
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            _movePrev.copy(_moveCurr);
            break;
          case 2:
            _state = STATE.TOUCH_ZOOM_PAN;
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panStart.copy(getMouseOnScreen(x, y));
            _panEnd.copy(_panStart);
            break;
          default:
            _state = STATE.NONE;
        }
        _this.dispatchEvent(startEvent);
      }
      function touchmove(event) {
        if (_this.enabled === false)
          return;
        event.preventDefault();
        event.stopPropagation();
        switch (event.touches.length) {
          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;
          case 2:
            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;
            _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            break;
          default:
            _state = STATE.NONE;
        }
      }
      function touchend(event) {
        if (_this.enabled === false)
          return;
        switch (event.touches.length) {
          case 1:
            _movePrev.copy(_moveCurr);
            _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
            break;
          case 2:
            _touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
            var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;
            var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;
            _panEnd.copy(getMouseOnScreen(x, y));
            _panStart.copy(_panEnd);
            break;
        }
        _state = STATE.NONE;
        _this.dispatchEvent(endEvent);
      }
      function contextmenu(event) {
        event.preventDefault();
      }
      this.dispose = function() {
        this.domElement.removeEventListener('contextmenu', contextmenu, false);
        this.domElement.removeEventListener('mousedown', mousedown, false);
        this.domElement.removeEventListener('mousewheel', mousewheel, false);
        this.domElement.removeEventListener('MozMousePixelScroll', mousewheel, false);
        this.domElement.removeEventListener('touchstart', touchstart, false);
        this.domElement.removeEventListener('touchend', touchend, false);
        this.domElement.removeEventListener('touchmove', touchmove, false);
        document.removeEventListener('mousemove', mousemove, false);
        document.removeEventListener('mouseup', mouseup, false);
        window.removeEventListener('keydown', keydown, false);
        window.removeEventListener('keyup', keyup, false);
      };
      this.domElement.addEventListener('contextmenu', contextmenu, false);
      this.domElement.addEventListener('mousedown', mousedown, false);
      this.domElement.addEventListener('mousewheel', mousewheel, false);
      this.domElement.addEventListener('MozMousePixelScroll', mousewheel, false);
      this.domElement.addEventListener('touchstart', touchstart, false);
      this.domElement.addEventListener('touchend', touchend, false);
      this.domElement.addEventListener('touchmove', touchmove, false);
      window.addEventListener('keydown', keydown, false);
      window.addEventListener('keyup', keyup, false);
      this.handleResize();
      this.update();
    };
    THREE.TrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);
    THREE.TrackballControls.prototype.constructor = THREE.TrackballControls;
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("f0", ["ef"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, {"THREE": __require("ef")});
  (function() {
    (function() {
      var COLLADA = null;
      var scene = null;
      var visualScene;
      var kinematicsModel;
      var readyCallbackFunc = null;
      var sources = {};
      var images = {};
      var animations = {};
      var controllers = {};
      var geometries = {};
      var materials = {};
      var effects = {};
      var cameras = {};
      var lights = {};
      var animData;
      var kinematics;
      var visualScenes;
      var kinematicsModels;
      var baseUrl;
      var morphs;
      var skins;
      var flip_uv = true;
      var preferredShading = THREE.SmoothShading;
      var colladaUnit = 1.0;
      var colladaUp = 'Y';
      var upConversion = null;
      var options = {
        centerGeometry: false,
        convertUpAxis: false,
        subdivideFaces: true,
        upAxis: 'Y',
        defaultEnvMap: null
      };
      THREE.ColladaLoader = function(manager) {
        this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      };
      THREE.ColladaLoader.prototype = {
        constructor: THREE.ColladaLoader,
        options: options,
        load: function(url, onLoad, onProgress, onError) {
          var length = 0;
          if (document.implementation && document.implementation.createDocument) {
            var scope = this;
            var loader = new THREE.XHRLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.load(url, function(text) {
              var parts = url.split('/');
              parts.pop();
              baseUrl = (parts.length < 1 ? '.' : parts.join('/')) + '/';
              onLoad(scope.parse(text, url));
            }, onProgress, onError);
          } else {
            alert("Don't know how to parse XML!");
          }
        },
        setCrossOrigin: function(value) {
          this.crossOrigin = value;
        },
        parse: function(text) {
          COLLADA = new DOMParser().parseFromString(text, 'application/xml');
          this.parseAsset();
          this.setUpConversion();
          images = this.parseLib("library_images image", _Image, "image");
          materials = this.parseLib("library_materials material", Material, "material");
          effects = this.parseLib("library_effects effect", Effect, "effect");
          geometries = this.parseLib("library_geometries geometry", Geometry, "geometry");
          cameras = this.parseLib("library_cameras camera", Camera, "camera");
          lights = this.parseLib("library_lights light", Light, "light");
          controllers = this.parseLib("library_controllers controller", Controller, "controller");
          animations = this.parseLib("library_animations animation", Animation, "animation");
          visualScenes = this.parseLib("library_visual_scenes visual_scene", VisualScene, "visual_scene");
          kinematicsModels = this.parseLib("library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model");
          morphs = [];
          skins = [];
          visualScene = this.parseScene();
          scene = new THREE.Group();
          for (var i = 0; i < visualScene.nodes.length; i++) {
            scene.add(createSceneGraph(visualScene.nodes[i]));
          }
          scene.scale.multiplyScalar(colladaUnit);
          this.createAnimations();
          kinematicsModel = this.parseKinematicsModel();
          this.createKinematics();
          var result = {
            scene: scene,
            morphs: morphs,
            skins: skins,
            animations: animData,
            kinematics: kinematics,
            dae: {
              images: images,
              materials: materials,
              cameras: cameras,
              lights: lights,
              effects: effects,
              geometries: geometries,
              controllers: controllers,
              animations: animations,
              visualScenes: visualScenes,
              visualScene: visualScene,
              scene: visualScene,
              kinematicsModels: kinematicsModels,
              kinematicsModel: kinematicsModel
            }
          };
          return result;
        },
        setPreferredShading: function(shading) {
          preferredShading = shading;
        },
        parseAsset: function() {
          var elements = COLLADA.querySelectorAll('asset');
          var element = elements[0];
          if (element && element.childNodes) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              switch (child.nodeName) {
                case 'unit':
                  var meter = child.getAttribute('meter');
                  if (meter) {
                    colladaUnit = parseFloat(meter);
                  }
                  break;
                case 'up_axis':
                  colladaUp = child.textContent.charAt(0);
                  break;
              }
            }
          }
        },
        parseLib: function(q, classSpec, prefix) {
          var elements = COLLADA.querySelectorAll(q);
          var lib = {};
          var i = 0;
          var elementsLength = elements.length;
          for (var j = 0; j < elementsLength; j++) {
            var element = elements[j];
            var daeElement = (new classSpec()).parse(element);
            if (!daeElement.id || daeElement.id.length === 0)
              daeElement.id = prefix + (i++);
            lib[daeElement.id] = daeElement;
          }
          return lib;
        },
        parseScene: function() {
          var sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];
          if (sceneElement) {
            var url = sceneElement.getAttribute('url').replace(/^#/, '');
            return visualScenes[url.length > 0 ? url : 'visual_scene0'];
          } else {
            return null;
          }
        },
        parseKinematicsModel: function() {
          var kinematicsModelElement = COLLADA.querySelectorAll('instance_kinematics_model')[0];
          if (kinematicsModelElement) {
            var url = kinematicsModelElement.getAttribute('url').replace(/^#/, '');
            return kinematicsModels[url.length > 0 ? url : 'kinematics_model0'];
          } else {
            return null;
          }
        },
        createAnimations: function() {
          animData = [];
          recurseHierarchy(scene);
        },
        recurseHierarchy: function(node) {
          var n = visualScene.getChildById(node.colladaId, true),
              newData = null;
          if (n && n.keys) {
            newData = {
              fps: 60,
              hierarchy: [{
                node: n,
                keys: n.keys,
                sids: n.sids
              }],
              node: node,
              name: 'animation_' + node.name,
              length: 0
            };
            animData.push(newData);
            for (var i = 0,
                il = n.keys.length; i < il; i++) {
              newData.length = Math.max(newData.length, n.keys[i].time);
            }
          } else {
            newData = {hierarchy: [{
                keys: [],
                sids: []
              }]};
          }
          for (var i = 0,
              il = node.children.length; i < il; i++) {
            var d = recurseHierarchy(node.children[i]);
            for (var j = 0,
                jl = d.hierarchy.length; j < jl; j++) {
              newData.hierarchy.push({
                keys: [],
                sids: []
              });
            }
          }
          return newData;
        },
        createMorph: function(geometry, ctrl) {
          var morphCtrl = ctrl instanceof InstanceController ? controllers[ctrl.url] : ctrl;
          if (!morphCtrl || !morphCtrl.morph) {
            console.log("could not find morph controller!");
            return;
          }
          var morph = morphCtrl.morph;
          for (var i = 0; i < morph.targets.length; i++) {
            var target_id = morph.targets[i];
            var daeGeometry = geometries[target_id];
            if (!daeGeometry.mesh || !daeGeometry.mesh.primitives || !daeGeometry.mesh.primitives.length) {
              continue;
            }
            var target = daeGeometry.mesh.primitives[0].geometry;
            if (target.vertices.length === geometry.vertices.length) {
              geometry.morphTargets.push({
                name: "target_1",
                vertices: target.vertices
              });
            }
          }
          geometry.morphTargets.push({
            name: "target_Z",
            vertices: geometry.vertices
          });
        },
        createSkin: function(geometry, ctrl, applyBindShape) {
          var skinCtrl = controllers[ctrl.url];
          if (!skinCtrl || !skinCtrl.skin) {
            console.log("could not find skin controller!");
            return;
          }
          if (!ctrl.skeleton || !ctrl.skeleton.length) {
            console.log("could not find the skeleton for the skin!");
            return;
          }
          var skin = skinCtrl.skin;
          var skeleton = visualScene.getChildById(ctrl.skeleton[0]);
          var hierarchy = [];
          applyBindShape = applyBindShape !== undefined ? applyBindShape : true;
          var bones = [];
          geometry.skinWeights = [];
          geometry.skinIndices = [];
          if (applyBindShape) {
            for (var i = 0; i < geometry.vertices.length; i++) {
              geometry.vertices[i].applyMatrix4(skin.bindShapeMatrix);
            }
          }
        },
        createKinematics: function() {
          if (kinematicsModel && kinematicsModel.joints.length === 0) {
            kinematics = undefined;
            return;
          }
          var jointMap = {};
          var _addToMap = function(jointIndex, parentVisualElement) {
            var parentVisualElementId = parentVisualElement.getAttribute('id');
            var colladaNode = visualScene.getChildById(parentVisualElementId, true);
            var joint = kinematicsModel.joints[jointIndex];
            scene.traverse(function(node) {
              if (node.colladaId == parentVisualElementId) {
                jointMap[jointIndex] = {
                  node: node,
                  transforms: colladaNode.transforms,
                  joint: joint,
                  position: joint.zeroPosition
                };
              }
            });
          };
          kinematics = {
            joints: kinematicsModel && kinematicsModel.joints,
            getJointValue: function(jointIndex) {
              var jointData = jointMap[jointIndex];
              if (jointData) {
                return jointData.position;
              } else {
                console.log('getJointValue: joint ' + jointIndex + ' doesn\'t exist');
              }
            },
            setJointValue: function(jointIndex, value) {
              var jointData = jointMap[jointIndex];
              if (jointData) {
                var joint = jointData.joint;
                if (value > joint.limits.max || value < joint.limits.min) {
                  console.log('setJointValue: joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ')');
                } else if (joint.static) {
                  console.log('setJointValue: joint ' + jointIndex + ' is static');
                } else {
                  var threejsNode = jointData.node;
                  var axis = joint.axis;
                  var transforms = jointData.transforms;
                  var matrix = new THREE.Matrix4();
                  for (i = 0; i < transforms.length; i++) {
                    var transform = transforms[i];
                    if (transform.sid && transform.sid.indexOf('joint' + jointIndex) !== -1) {
                      switch (joint.type) {
                        case 'revolute':
                          matrix.multiply(m1.makeRotationAxis(axis, THREE.Math.degToRad(value)));
                          break;
                        case 'prismatic':
                          matrix.multiply(m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                          break;
                        default:
                          console.warn('setJointValue: unknown joint type: ' + joint.type);
                          break;
                      }
                    } else {
                      var m1 = new THREE.Matrix4();
                      switch (transform.type) {
                        case 'matrix':
                          matrix.multiply(transform.obj);
                          break;
                        case 'translate':
                          matrix.multiply(m1.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                          break;
                        case 'rotate':
                          matrix.multiply(m1.makeRotationAxis(transform.obj, transform.angle));
                          break;
                      }
                    }
                  }
                  var elementsFloat32Arr = matrix.elements;
                  var elements = Array.prototype.slice.call(elementsFloat32Arr);
                  var elementsRowMajor = [elements[0], elements[4], elements[8], elements[12], elements[1], elements[5], elements[9], elements[13], elements[2], elements[6], elements[10], elements[14], elements[3], elements[7], elements[11], elements[15]];
                  threejsNode.matrix.set.apply(threejsNode.matrix, elementsRowMajor);
                  threejsNode.matrix.decompose(threejsNode.position, threejsNode.quaternion, threejsNode.scale);
                }
              } else {
                console.log('setJointValue: joint ' + jointIndex + ' doesn\'t exist');
              }
            }
          };
          var element = COLLADA.querySelector('scene instance_kinematics_scene');
          if (element) {
            for (var i = 0; i < element.childNodes.length; i++) {
              var child = element.childNodes[i];
              if (child.nodeType != 1)
                continue;
              switch (child.nodeName) {
                case 'bind_joint_axis':
                  var visualTarget = child.getAttribute('target').split('/').pop();
                  var axis = child.querySelector('axis param').textContent;
                  var jointIndex = parseInt(axis.split('joint').pop().split('.')[0]);
                  var visualTargetElement = COLLADA.querySelector('[sid="' + visualTarget + '"]');
                  if (visualTargetElement) {
                    var parentVisualElement = visualTargetElement.parentElement;
                    _addToMap(jointIndex, parentVisualElement);
                  }
                  break;
                default:
                  break;
              }
            }
          }
        },
        getJointId: function(skin, id) {
          for (var i = 0; i < skin.joints.length; i++) {
            if (skin.joints[i] === id) {
              return i;
            }
          }
        },
        calcFrameDuration: function(node) {
          var minT = 10000000;
          for (var i = 0; i < node.channels.length; i++) {
            var sampler = node.channels[i].sampler;
            for (var j = 0; j < sampler.input.length - 1; j++) {
              var t0 = sampler.input[j];
              var t1 = sampler.input[j + 1];
              minT = Math.min(minT, t1 - t0);
            }
          }
          return minT;
        },
        calcMatrixAt: function(node, t) {
          var animated = {};
          var i,
              j;
          for (i = 0; i < node.channels.length; i++) {
            var channel = node.channels[i];
            animated[channel.sid] = channel;
          }
          var matrix = new THREE.Matrix4();
          for (i = 0; i < node.transforms.length; i++) {
            var transform = node.transforms[i];
            var channel = animated[transform.sid];
            if (channel !== undefined) {
              var sampler = channel.sampler;
              var value;
              for (j = 0; j < sampler.input.length - 1; j++) {
                if (sampler.input[j + 1] > t) {
                  value = sampler.output[j];
                  break;
                }
              }
              if (value !== undefined) {
                if (value instanceof THREE.Matrix4) {
                  matrix.multiplyMatrices(matrix, value);
                } else {
                  matrix.multiplyMatrices(matrix, transform.matrix);
                }
              } else {
                matrix.multiplyMatrices(matrix, transform.matrix);
              }
            } else {
              matrix.multiplyMatrices(matrix, transform.matrix);
            }
          }
          return matrix;
        },
        setUpConversion: function() {
          if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
            upConversion = null;
          } else {
            switch (colladaUp) {
              case 'X':
                upConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';
                break;
              case 'Y':
                upConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';
                break;
              case 'Z':
                upConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';
                break;
            }
          }
        }
      };
      function _Image() {
        this.id = "";
        this.init_from = "";
      }
      ;
      _Image.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeName === 'init_from') {
            this.init_from = child.textContent;
          }
        }
        return this;
      };
      function Controller() {
        this.id = "";
        this.name = "";
        this.type = "";
        this.skin = null;
        this.morph = null;
      }
      ;
      Controller.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        this.type = "none";
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'skin':
              this.skin = (new Skin()).parse(child);
              this.type = child.nodeName;
              break;
            case 'morph':
              this.morph = (new Morph()).parse(child);
              this.type = child.nodeName;
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Morph() {
        this.method = null;
        this.source = null;
        this.targets = null;
        this.weights = null;
      }
      ;
      Morph.prototype.parse = function(element) {
        var sources = {};
        var inputs = [];
        var i;
        this.method = element.getAttribute('method');
        this.source = element.getAttribute('source').replace(/^#/, '');
        for (i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'source':
              var source = (new Source()).parse(child);
              sources[source.id] = source;
              break;
            case 'targets':
              inputs = this.parseInputs(child);
              break;
            default:
              console.log(child.nodeName);
              break;
          }
        }
        for (i = 0; i < inputs.length; i++) {
          var input = inputs[i];
          var source = sources[input.source];
          switch (input.semantic) {
            case 'MORPH_TARGET':
              this.targets = source.read();
              break;
            case 'MORPH_WEIGHT':
              this.weights = source.read();
              break;
            default:
              break;
          }
        }
        return this;
      };
      Morph.prototype.parseInputs = function(element) {
        var inputs = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'input':
              inputs.push((new Input()).parse(child));
              break;
            default:
              break;
          }
        }
        return inputs;
      };
      function Skin() {
        this.source = "";
        this.bindShapeMatrix = null;
        this.invBindMatrices = [];
        this.joints = [];
        this.weights = [];
      }
      ;
      Skin.prototype.parse = function(element) {
        var sources = {};
        var joints,
            weights;
        this.source = element.getAttribute('source').replace(/^#/, '');
        this.invBindMatrices = [];
        this.joints = [];
        this.weights = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'bind_shape_matrix':
              var f = _floats(child.textContent);
              this.bindShapeMatrix = getConvertedMat4(f);
              break;
            case 'source':
              var src = new Source().parse(child);
              sources[src.id] = src;
              break;
            case 'joints':
              joints = child;
              break;
            case 'vertex_weights':
              weights = child;
              break;
            default:
              console.log(child.nodeName);
              break;
          }
        }
        this.parseJoints(joints, sources);
        this.parseWeights(weights, sources);
        return this;
      };
      Skin.prototype.parseJoints = function(element, sources) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'input':
              var input = (new Input()).parse(child);
              var source = sources[input.source];
              if (input.semantic === 'JOINT') {
                this.joints = source.read();
              } else if (input.semantic === 'INV_BIND_MATRIX') {
                this.invBindMatrices = source.read();
              }
              break;
            default:
              break;
          }
        }
      };
      Skin.prototype.parseWeights = function(element, sources) {
        var v,
            vcount,
            inputs = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'input':
              inputs.push((new Input()).parse(child));
              break;
            case 'v':
              v = _ints(child.textContent);
              break;
            case 'vcount':
              vcount = _ints(child.textContent);
              break;
            default:
              break;
          }
        }
        var index = 0;
        for (var i = 0; i < vcount.length; i++) {
          var numBones = vcount[i];
          var vertex_weights = [];
          for (var j = 0; j < numBones; j++) {
            var influence = {};
            for (var k = 0; k < inputs.length; k++) {
              var input = inputs[k];
              var value = v[index + input.offset];
              switch (input.semantic) {
                case 'JOINT':
                  influence.joint = value;
                  break;
                case 'WEIGHT':
                  influence.weight = sources[input.source].data[value];
                  break;
                default:
                  break;
              }
            }
            vertex_weights.push(influence);
            index += inputs.length;
          }
          for (var j = 0; j < vertex_weights.length; j++) {
            vertex_weights[j].index = i;
          }
          this.weights.push(vertex_weights);
        }
      };
      function VisualScene() {
        this.id = "";
        this.name = "";
        this.nodes = [];
        this.scene = new THREE.Group();
      }
      ;
      VisualScene.prototype.getChildById = function(id, recursive) {
        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i].getChildById(id, recursive);
          if (node) {
            return node;
          }
        }
        return null;
      };
      VisualScene.prototype.getChildBySid = function(sid, recursive) {
        for (var i = 0; i < this.nodes.length; i++) {
          var node = this.nodes[i].getChildBySid(sid, recursive);
          if (node) {
            return node;
          }
        }
        return null;
      };
      VisualScene.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        this.nodes = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'node':
              this.nodes.push((new Node()).parse(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Node() {
        this.id = "";
        this.name = "";
        this.sid = "";
        this.nodes = [];
        this.controllers = [];
        this.transforms = [];
        this.geometries = [];
        this.channels = [];
        this.matrix = new THREE.Matrix4();
      }
      ;
      Node.prototype.getChannelForTransform = function(transformSid) {
        for (var i = 0; i < this.channels.length; i++) {
          var channel = this.channels[i];
          var parts = channel.target.split('/');
          var id = parts.shift();
          var sid = parts.shift();
          var dotSyntax = (sid.indexOf(".") >= 0);
          var arrSyntax = (sid.indexOf("(") >= 0);
          var arrIndices;
          var member;
          if (dotSyntax) {
            parts = sid.split(".");
            sid = parts.shift();
            member = parts.shift();
          } else if (arrSyntax) {
            arrIndices = sid.split("(");
            sid = arrIndices.shift();
            for (var j = 0; j < arrIndices.length; j++) {
              arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ''));
            }
          }
          if (sid === transformSid) {
            channel.info = {
              sid: sid,
              dotSyntax: dotSyntax,
              arrSyntax: arrSyntax,
              arrIndices: arrIndices
            };
            return channel;
          }
        }
        return null;
      };
      Node.prototype.getChildById = function(id, recursive) {
        if (this.id === id) {
          return this;
        }
        if (recursive) {
          for (var i = 0; i < this.nodes.length; i++) {
            var n = this.nodes[i].getChildById(id, recursive);
            if (n) {
              return n;
            }
          }
        }
        return null;
      };
      Node.prototype.getChildBySid = function(sid, recursive) {
        if (this.sid === sid) {
          return this;
        }
        if (recursive) {
          for (var i = 0; i < this.nodes.length; i++) {
            var n = this.nodes[i].getChildBySid(sid, recursive);
            if (n) {
              return n;
            }
          }
        }
        return null;
      };
      Node.prototype.getTransformBySid = function(sid) {
        for (var i = 0; i < this.transforms.length; i++) {
          if (this.transforms[i].sid === sid)
            return this.transforms[i];
        }
        return null;
      };
      Node.prototype.parse = function(element) {
        var url;
        this.id = element.getAttribute('id');
        this.sid = element.getAttribute('sid');
        this.name = element.getAttribute('name');
        this.type = element.getAttribute('type');
        this.layer = element.getAttribute('layer');
        this.type = this.type === 'JOINT' ? this.type : 'NODE';
        this.nodes = [];
        this.transforms = [];
        this.geometries = [];
        this.cameras = [];
        this.lights = [];
        this.controllers = [];
        this.matrix = new THREE.Matrix4();
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'node':
              this.nodes.push((new Node()).parse(child));
              break;
            case 'instance_camera':
              this.cameras.push((new InstanceCamera()).parse(child));
              break;
            case 'instance_controller':
              this.controllers.push((new InstanceController()).parse(child));
              break;
            case 'instance_geometry':
              this.geometries.push((new InstanceGeometry()).parse(child));
              break;
            case 'instance_light':
              this.lights.push((new InstanceLight()).parse(child));
              break;
            case 'instance_node':
              url = child.getAttribute('url').replace(/^#/, '');
              var iNode = getLibraryNode(url);
              if (iNode) {
                this.nodes.push((new Node()).parse(iNode));
              }
              break;
            case 'rotate':
            case 'translate':
            case 'scale':
            case 'matrix':
            case 'lookat':
            case 'skew':
              this.transforms.push((new Transform()).parse(child));
              break;
            case 'extra':
              break;
            default:
              console.log(child.nodeName);
              break;
          }
        }
        this.channels = getChannelsForNode(this);
        bakeAnimations(this);
        this.updateMatrix();
        return this;
      };
      Node.prototype.updateMatrix = function() {
        this.matrix.identity();
        for (var i = 0; i < this.transforms.length; i++) {
          this.transforms[i].apply(this.matrix);
        }
      };
      function Transform() {
        this.sid = "";
        this.type = "";
        this.data = [];
        this.obj = null;
      }
      ;
      Transform.prototype.parse = function(element) {
        this.sid = element.getAttribute('sid');
        this.type = element.nodeName;
        this.data = _floats(element.textContent);
        this.convert();
        return this;
      };
      Transform.prototype.convert = function() {
        switch (this.type) {
          case 'matrix':
            this.obj = getConvertedMat4(this.data);
            break;
          case 'rotate':
            this.angle = THREE.Math.degToRad(this.data[3]);
          case 'translate':
            fixCoords(this.data, -1);
            this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
            break;
          case 'scale':
            fixCoords(this.data, 1);
            this.obj = new THREE.Vector3(this.data[0], this.data[1], this.data[2]);
            break;
          default:
            console.log('Can not convert Transform of type ' + this.type);
            break;
        }
      };
      Transform.prototype.apply = function() {
        var m1 = new THREE.Matrix4();
        return function(matrix) {
          switch (this.type) {
            case 'matrix':
              matrix.multiply(this.obj);
              break;
            case 'translate':
              matrix.multiply(m1.makeTranslation(this.obj.x, this.obj.y, this.obj.z));
              break;
            case 'rotate':
              matrix.multiply(m1.makeRotationAxis(this.obj, this.angle));
              break;
            case 'scale':
              matrix.scale(this.obj);
              break;
          }
        };
      }();
      Transform.prototype.update = function(data, member) {
        var members = ['X', 'Y', 'Z', 'ANGLE'];
        switch (this.type) {
          case 'matrix':
            if (!member) {
              this.obj.copy(data);
            } else if (member.length === 1) {
              switch (member[0]) {
                case 0:
                  this.obj.n11 = data[0];
                  this.obj.n21 = data[1];
                  this.obj.n31 = data[2];
                  this.obj.n41 = data[3];
                  break;
                case 1:
                  this.obj.n12 = data[0];
                  this.obj.n22 = data[1];
                  this.obj.n32 = data[2];
                  this.obj.n42 = data[3];
                  break;
                case 2:
                  this.obj.n13 = data[0];
                  this.obj.n23 = data[1];
                  this.obj.n33 = data[2];
                  this.obj.n43 = data[3];
                  break;
                case 3:
                  this.obj.n14 = data[0];
                  this.obj.n24 = data[1];
                  this.obj.n34 = data[2];
                  this.obj.n44 = data[3];
                  break;
              }
            } else if (member.length === 2) {
              var propName = 'n' + (member[0] + 1) + (member[1] + 1);
              this.obj[propName] = data;
            } else {
              console.log('Incorrect addressing of matrix in transform.');
            }
            break;
          case 'translate':
          case 'scale':
            if (Object.prototype.toString.call(member) === '[object Array]') {
              member = members[member[0]];
            }
            switch (member) {
              case 'X':
                this.obj.x = data;
                break;
              case 'Y':
                this.obj.y = data;
                break;
              case 'Z':
                this.obj.z = data;
                break;
              default:
                this.obj.x = data[0];
                this.obj.y = data[1];
                this.obj.z = data[2];
                break;
            }
            break;
          case 'rotate':
            if (Object.prototype.toString.call(member) === '[object Array]') {
              member = members[member[0]];
            }
            switch (member) {
              case 'X':
                this.obj.x = data;
                break;
              case 'Y':
                this.obj.y = data;
                break;
              case 'Z':
                this.obj.z = data;
                break;
              case 'ANGLE':
                this.angle = THREE.Math.degToRad(data);
                break;
              default:
                this.obj.x = data[0];
                this.obj.y = data[1];
                this.obj.z = data[2];
                this.angle = THREE.Math.degToRad(data[3]);
                break;
            }
            break;
        }
      };
      function InstanceController() {
        this.url = "";
        this.skeleton = [];
        this.instance_material = [];
      }
      ;
      InstanceController.prototype.parse = function(element) {
        this.url = element.getAttribute('url').replace(/^#/, '');
        this.skeleton = [];
        this.instance_material = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType !== 1)
            continue;
          switch (child.nodeName) {
            case 'skeleton':
              this.skeleton.push(child.textContent.replace(/^#/, ''));
              break;
            case 'bind_material':
              var instances = child.querySelectorAll('instance_material');
              for (var j = 0; j < instances.length; j++) {
                var instance = instances[j];
                this.instance_material.push((new InstanceMaterial()).parse(instance));
              }
              break;
            case 'extra':
              break;
            default:
              break;
          }
        }
        return this;
      };
      function InstanceMaterial() {
        this.symbol = "";
        this.target = "";
      }
      ;
      InstanceMaterial.prototype.parse = function(element) {
        this.symbol = element.getAttribute('symbol');
        this.target = element.getAttribute('target').replace(/^#/, '');
        return this;
      };
      function InstanceGeometry() {
        this.url = "";
        this.instance_material = [];
      }
      ;
      InstanceGeometry.prototype.parse = function(element) {
        this.url = element.getAttribute('url').replace(/^#/, '');
        this.instance_material = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          if (child.nodeName === 'bind_material') {
            var instances = child.querySelectorAll('instance_material');
            for (var j = 0; j < instances.length; j++) {
              var instance = instances[j];
              this.instance_material.push((new InstanceMaterial()).parse(instance));
            }
            break;
          }
        }
        return this;
      };
      function Geometry() {
        this.id = "";
        this.mesh = null;
      }
      ;
      Geometry.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        extractDoubleSided(this, element);
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'mesh':
              this.mesh = (new Mesh(this)).parse(child);
              break;
            case 'extra':
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Mesh(geometry) {
        this.geometry = geometry.id;
        this.primitives = [];
        this.vertices = null;
        this.geometry3js = null;
      }
      ;
      Mesh.prototype.parse = function(element) {
        this.primitives = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'source':
              _source(child);
              break;
            case 'vertices':
              this.vertices = (new Vertices()).parse(child);
              break;
            case 'linestrips':
              this.primitives.push((new LineStrips().parse(child)));
              break;
            case 'triangles':
              this.primitives.push((new Triangles().parse(child)));
              break;
            case 'polygons':
              this.primitives.push((new Polygons().parse(child)));
              break;
            case 'polylist':
              this.primitives.push((new Polylist().parse(child)));
              break;
            default:
              break;
          }
        }
        this.geometry3js = new THREE.Geometry();
        if (this.vertices === null) {
          return this;
        }
        var vertexData = sources[this.vertices.input['POSITION'].source].data;
        for (var i = 0; i < vertexData.length; i += 3) {
          this.geometry3js.vertices.push(getConvertedVec3(vertexData, i).clone());
        }
        for (var i = 0; i < this.primitives.length; i++) {
          var primitive = this.primitives[i];
          primitive.setVertices(this.vertices);
          this.handlePrimitive(primitive, this.geometry3js);
        }
        if (this.geometry3js.calcNormals) {
          this.geometry3js.computeVertexNormals();
          delete this.geometry3js.calcNormals;
        }
        return this;
      };
      Mesh.prototype.handlePrimitive = function(primitive, geom) {
        if (primitive instanceof LineStrips) {
          geom.isLineStrip = true;
          return;
        }
        var j,
            k,
            pList = primitive.p,
            inputs = primitive.inputs;
        var input,
            index,
            idx32;
        var source,
            numParams;
        var vcIndex = 0,
            vcount = 3,
            maxOffset = 0;
        var texture_sets = [];
        for (j = 0; j < inputs.length; j++) {
          input = inputs[j];
          var offset = input.offset + 1;
          maxOffset = (maxOffset < offset) ? offset : maxOffset;
          switch (input.semantic) {
            case 'TEXCOORD':
              texture_sets.push(input.set);
              break;
          }
        }
        for (var pCount = 0; pCount < pList.length; ++pCount) {
          var p = pList[pCount],
              i = 0;
          while (i < p.length) {
            var vs = [];
            var ns = [];
            var ts = null;
            var cs = [];
            if (primitive.vcount) {
              vcount = primitive.vcount.length ? primitive.vcount[vcIndex++] : primitive.vcount;
            } else {
              vcount = p.length / maxOffset;
            }
            for (j = 0; j < vcount; j++) {
              for (k = 0; k < inputs.length; k++) {
                input = inputs[k];
                source = sources[input.source];
                index = p[i + (j * maxOffset) + input.offset];
                numParams = source.accessor.params.length;
                idx32 = index * numParams;
                switch (input.semantic) {
                  case 'VERTEX':
                    vs.push(index);
                    break;
                  case 'NORMAL':
                    ns.push(getConvertedVec3(source.data, idx32));
                    break;
                  case 'TEXCOORD':
                    ts = ts || {};
                    if (ts[input.set] === undefined)
                      ts[input.set] = [];
                    ts[input.set].push(new THREE.Vector2(source.data[idx32], source.data[idx32 + 1]));
                    break;
                  case 'COLOR':
                    cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
                    break;
                  default:
                    break;
                }
              }
            }
            if (ns.length === 0) {
              input = this.vertices.input.NORMAL;
              if (input) {
                source = sources[input.source];
                numParams = source.accessor.params.length;
                for (var ndx = 0,
                    len = vs.length; ndx < len; ndx++) {
                  ns.push(getConvertedVec3(source.data, vs[ndx] * numParams));
                }
              } else {
                geom.calcNormals = true;
              }
            }
            if (!ts) {
              ts = {};
              input = this.vertices.input.TEXCOORD;
              if (input) {
                texture_sets.push(input.set);
                source = sources[input.source];
                numParams = source.accessor.params.length;
                for (var ndx = 0,
                    len = vs.length; ndx < len; ndx++) {
                  idx32 = vs[ndx] * numParams;
                  if (ts[input.set] === undefined)
                    ts[input.set] = [];
                  ts[input.set].push(new THREE.Vector2(source.data[idx32], 1.0 - source.data[idx32 + 1]));
                }
              }
            }
            if (cs.length === 0) {
              input = this.vertices.input.COLOR;
              if (input) {
                source = sources[input.source];
                numParams = source.accessor.params.length;
                for (var ndx = 0,
                    len = vs.length; ndx < len; ndx++) {
                  idx32 = vs[ndx] * numParams;
                  cs.push(new THREE.Color().setRGB(source.data[idx32], source.data[idx32 + 1], source.data[idx32 + 2]));
                }
              }
            }
            var face = null,
                faces = [],
                uv,
                uvArr;
            if (vcount === 3) {
              faces.push(new THREE.Face3(vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color()));
            } else if (vcount === 4) {
              faces.push(new THREE.Face3(vs[0], vs[1], vs[3], [ns[0].clone(), ns[1].clone(), ns[3].clone()], cs.length ? [cs[0], cs[1], cs[3]] : new THREE.Color()));
              faces.push(new THREE.Face3(vs[1], vs[2], vs[3], [ns[1].clone(), ns[2].clone(), ns[3].clone()], cs.length ? [cs[1], cs[2], cs[3]] : new THREE.Color()));
            } else if (vcount > 4 && options.subdivideFaces) {
              var clr = cs.length ? cs : new THREE.Color(),
                  vec1,
                  vec2,
                  vec3,
                  v1,
                  v2,
                  norm;
              for (k = 1; k < vcount - 1; ) {
                faces.push(new THREE.Face3(vs[0], vs[k], vs[k + 1], [ns[0].clone(), ns[k++].clone(), ns[k].clone()], clr));
              }
            }
            if (faces.length) {
              for (var ndx = 0,
                  len = faces.length; ndx < len; ndx++) {
                face = faces[ndx];
                face.daeMaterial = primitive.material;
                geom.faces.push(face);
                for (k = 0; k < texture_sets.length; k++) {
                  uv = ts[texture_sets[k]];
                  if (vcount > 4) {
                    uvArr = [uv[0], uv[ndx + 1], uv[ndx + 2]];
                  } else if (vcount === 4) {
                    if (ndx === 0) {
                      uvArr = [uv[0], uv[1], uv[3]];
                    } else {
                      uvArr = [uv[1].clone(), uv[2], uv[3].clone()];
                    }
                  } else {
                    uvArr = [uv[0], uv[1], uv[2]];
                  }
                  if (geom.faceVertexUvs[k] === undefined) {
                    geom.faceVertexUvs[k] = [];
                  }
                  geom.faceVertexUvs[k].push(uvArr);
                }
              }
            } else {
              console.log('dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id);
            }
            i += maxOffset * vcount;
          }
        }
      };
      function Polygons() {
        this.material = "";
        this.count = 0;
        this.inputs = [];
        this.vcount = null;
        this.p = [];
        this.geometry = new THREE.Geometry();
      }
      ;
      Polygons.prototype.setVertices = function(vertices) {
        for (var i = 0; i < this.inputs.length; i++) {
          if (this.inputs[i].source === vertices.id) {
            this.inputs[i].source = vertices.input['POSITION'].source;
          }
        }
      };
      Polygons.prototype.parse = function(element) {
        this.material = element.getAttribute('material');
        this.count = _attr_as_int(element, 'count', 0);
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'input':
              this.inputs.push((new Input()).parse(element.childNodes[i]));
              break;
            case 'vcount':
              this.vcount = _ints(child.textContent);
              break;
            case 'p':
              this.p.push(_ints(child.textContent));
              break;
            case 'ph':
              console.warn('polygon holes not yet supported!');
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Polylist() {
        Polygons.call(this);
        this.vcount = [];
      }
      ;
      Polylist.prototype = Object.create(Polygons.prototype);
      Polylist.prototype.constructor = Polylist;
      function LineStrips() {
        Polygons.call(this);
        this.vcount = 1;
      }
      ;
      LineStrips.prototype = Object.create(Polygons.prototype);
      LineStrips.prototype.constructor = LineStrips;
      function Triangles() {
        Polygons.call(this);
        this.vcount = 3;
      }
      ;
      Triangles.prototype = Object.create(Polygons.prototype);
      Triangles.prototype.constructor = Triangles;
      function Accessor() {
        this.source = "";
        this.count = 0;
        this.stride = 0;
        this.params = [];
      }
      ;
      Accessor.prototype.parse = function(element) {
        this.params = [];
        this.source = element.getAttribute('source');
        this.count = _attr_as_int(element, 'count', 0);
        this.stride = _attr_as_int(element, 'stride', 0);
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeName === 'param') {
            var param = {};
            param['name'] = child.getAttribute('name');
            param['type'] = child.getAttribute('type');
            this.params.push(param);
          }
        }
        return this;
      };
      function Vertices() {
        this.input = {};
      }
      ;
      Vertices.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        for (var i = 0; i < element.childNodes.length; i++) {
          if (element.childNodes[i].nodeName === 'input') {
            var input = (new Input()).parse(element.childNodes[i]);
            this.input[input.semantic] = input;
          }
        }
        return this;
      };
      function Input() {
        this.semantic = "";
        this.offset = 0;
        this.source = "";
        this.set = 0;
      }
      ;
      Input.prototype.parse = function(element) {
        this.semantic = element.getAttribute('semantic');
        this.source = element.getAttribute('source').replace(/^#/, '');
        this.set = _attr_as_int(element, 'set', -1);
        this.offset = _attr_as_int(element, 'offset', 0);
        if (this.semantic === 'TEXCOORD' && this.set < 0) {
          this.set = 0;
        }
        return this;
      };
      function Source(id) {
        this.id = id;
        this.type = null;
      }
      ;
      Source.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'bool_array':
              this.data = _bools(child.textContent);
              this.type = child.nodeName;
              break;
            case 'float_array':
              this.data = _floats(child.textContent);
              this.type = child.nodeName;
              break;
            case 'int_array':
              this.data = _ints(child.textContent);
              this.type = child.nodeName;
              break;
            case 'IDREF_array':
            case 'Name_array':
              this.data = _strings(child.textContent);
              this.type = child.nodeName;
              break;
            case 'technique_common':
              for (var j = 0; j < child.childNodes.length; j++) {
                if (child.childNodes[j].nodeName === 'accessor') {
                  this.accessor = (new Accessor()).parse(child.childNodes[j]);
                  break;
                }
              }
              break;
            default:
              break;
          }
        }
        return this;
      };
      Source.prototype.read = function() {
        var result = [];
        var param = this.accessor.params[0];
        switch (param.type) {
          case 'IDREF':
          case 'Name':
          case 'name':
          case 'float':
            return this.data;
          case 'float4x4':
            for (var j = 0; j < this.data.length; j += 16) {
              var s = this.data.slice(j, j + 16);
              var m = getConvertedMat4(s);
              result.push(m);
            }
            break;
          default:
            console.log('ColladaLoader: Source: Read dont know how to read ' + param.type + '.');
            break;
        }
        return result;
      };
      function Material() {
        this.id = "";
        this.name = "";
        this.instance_effect = null;
      }
      ;
      Material.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        for (var i = 0; i < element.childNodes.length; i++) {
          if (element.childNodes[i].nodeName === 'instance_effect') {
            this.instance_effect = (new InstanceEffect()).parse(element.childNodes[i]);
            break;
          }
        }
        return this;
      };
      function ColorOrTexture() {
        this.color = new THREE.Color();
        this.color.setRGB(Math.random(), Math.random(), Math.random());
        this.color.a = 1.0;
        this.texture = null;
        this.texcoord = null;
        this.texOpts = null;
      }
      ;
      ColorOrTexture.prototype.isColor = function() {
        return (this.texture === null);
      };
      ColorOrTexture.prototype.isTexture = function() {
        return (this.texture != null);
      };
      ColorOrTexture.prototype.parse = function(element) {
        if (element.nodeName === 'transparent') {
          this.opaque = element.getAttribute('opaque');
        }
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'color':
              var rgba = _floats(child.textContent);
              this.color = new THREE.Color();
              this.color.setRGB(rgba[0], rgba[1], rgba[2]);
              this.color.a = rgba[3];
              break;
            case 'texture':
              this.texture = child.getAttribute('texture');
              this.texcoord = child.getAttribute('texcoord');
              this.texOpts = {
                offsetU: 0,
                offsetV: 0,
                repeatU: 1,
                repeatV: 1,
                wrapU: 1,
                wrapV: 1
              };
              this.parseTexture(child);
              break;
            default:
              break;
          }
        }
        return this;
      };
      ColorOrTexture.prototype.parseTexture = function(element) {
        if (!element.childNodes)
          return this;
        if (element.childNodes[1] && element.childNodes[1].nodeName === 'extra') {
          element = element.childNodes[1];
          if (element.childNodes[1] && element.childNodes[1].nodeName === 'technique') {
            element = element.childNodes[1];
          }
        }
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'offsetU':
            case 'offsetV':
            case 'repeatU':
            case 'repeatV':
              this.texOpts[child.nodeName] = parseFloat(child.textContent);
              break;
            case 'wrapU':
            case 'wrapV':
              if (child.textContent.toUpperCase() === 'TRUE') {
                this.texOpts[child.nodeName] = 1;
              } else {
                this.texOpts[child.nodeName] = parseInt(child.textContent);
              }
              break;
            default:
              this.texOpts[child.nodeName] = child.textContent;
              break;
          }
        }
        return this;
      };
      function Shader(type, effect) {
        this.type = type;
        this.effect = effect;
        this.material = null;
      }
      ;
      Shader.prototype.parse = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'emission':
            case 'diffuse':
            case 'specular':
            case 'transparent':
              this[child.nodeName] = (new ColorOrTexture()).parse(child);
              break;
            case 'bump':
              var bumpType = child.getAttribute('bumptype');
              if (bumpType) {
                if (bumpType.toLowerCase() === "heightfield") {
                  this['bump'] = (new ColorOrTexture()).parse(child);
                } else if (bumpType.toLowerCase() === "normalmap") {
                  this['normal'] = (new ColorOrTexture()).parse(child);
                } else {
                  console.error("Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'");
                  this['bump'] = (new ColorOrTexture()).parse(child);
                }
              } else {
                console.warn("Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'");
                this['bump'] = (new ColorOrTexture()).parse(child);
              }
              break;
            case 'shininess':
            case 'reflectivity':
            case 'index_of_refraction':
            case 'transparency':
              var f = child.querySelectorAll('float');
              if (f.length > 0)
                this[child.nodeName] = parseFloat(f[0].textContent);
              break;
            default:
              break;
          }
        }
        this.create();
        return this;
      };
      Shader.prototype.create = function() {
        var props = {};
        var transparent = false;
        if (this['transparency'] !== undefined && this['transparent'] !== undefined) {
          var transparentColor = this['transparent'];
          var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;
          if (transparencyLevel > 0) {
            transparent = true;
            props['transparent'] = true;
            props['opacity'] = 1 - transparencyLevel;
          }
        }
        var keys = {
          'diffuse': 'map',
          'ambient': 'lightMap',
          'specular': 'specularMap',
          'emission': 'emissionMap',
          'bump': 'bumpMap',
          'normal': 'normalMap'
        };
        for (var prop in this) {
          switch (prop) {
            case 'ambient':
            case 'emission':
            case 'diffuse':
            case 'specular':
            case 'bump':
            case 'normal':
              var cot = this[prop];
              if (cot instanceof ColorOrTexture) {
                if (cot.isTexture()) {
                  var samplerId = cot.texture;
                  var surfaceId = this.effect.sampler[samplerId];
                  if (surfaceId !== undefined && surfaceId.source !== undefined) {
                    var surface = this.effect.surface[surfaceId.source];
                    if (surface !== undefined) {
                      var image = images[surface.init_from];
                      if (image && baseUrl) {
                        var url = baseUrl + image.init_from;
                        var texture;
                        var loader = THREE.Loader.Handlers.get(url);
                        if (loader !== null) {
                          texture = loader.load(url);
                        } else {
                          texture = new THREE.Texture();
                          loadTextureImage(texture, url);
                        }
                        texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                        texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                        texture.offset.x = cot.texOpts.offsetU;
                        texture.offset.y = cot.texOpts.offsetV;
                        texture.repeat.x = cot.texOpts.repeatU;
                        texture.repeat.y = cot.texOpts.repeatV;
                        props[keys[prop]] = texture;
                        if (prop === 'emission')
                          props['emissive'] = 0xffffff;
                      }
                    }
                  }
                } else if (prop === 'diffuse' || !transparent) {
                  if (prop === 'emission') {
                    props['emissive'] = cot.color.getHex();
                  } else {
                    props[prop] = cot.color.getHex();
                  }
                }
              }
              break;
            case 'shininess':
              props[prop] = this[prop];
              break;
            case 'reflectivity':
              props[prop] = this[prop];
              if (props[prop] > 0.0)
                props['envMap'] = options.defaultEnvMap;
              props['combine'] = THREE.MixOperation;
              break;
            case 'index_of_refraction':
              props['refractionRatio'] = this[prop];
              if (this[prop] !== 1.0)
                props['envMap'] = options.defaultEnvMap;
              break;
            case 'transparency':
              break;
            default:
              break;
          }
        }
        props['shading'] = preferredShading;
        props['side'] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;
        switch (this.type) {
          case 'constant':
            if (props.emissive != undefined)
              props.color = props.emissive;
            this.material = new THREE.MeshBasicMaterial(props);
            break;
          case 'phong':
          case 'blinn':
            if (props.diffuse != undefined)
              props.color = props.diffuse;
            this.material = new THREE.MeshPhongMaterial(props);
            break;
          case 'lambert':
          default:
            if (props.diffuse != undefined)
              props.color = props.diffuse;
            this.material = new THREE.MeshLambertMaterial(props);
            break;
        }
        return this.material;
      };
      function Surface(effect) {
        this.effect = effect;
        this.init_from = null;
        this.format = null;
      }
      ;
      Surface.prototype.parse = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'init_from':
              this.init_from = child.textContent;
              break;
            case 'format':
              this.format = child.textContent;
              break;
            default:
              console.log("unhandled Surface prop: " + child.nodeName);
              break;
          }
        }
        return this;
      };
      function Sampler2D(effect) {
        this.effect = effect;
        this.source = null;
        this.wrap_s = null;
        this.wrap_t = null;
        this.minfilter = null;
        this.magfilter = null;
        this.mipfilter = null;
      }
      ;
      Sampler2D.prototype.parse = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'source':
              this.source = child.textContent;
              break;
            case 'minfilter':
              this.minfilter = child.textContent;
              break;
            case 'magfilter':
              this.magfilter = child.textContent;
              break;
            case 'mipfilter':
              this.mipfilter = child.textContent;
              break;
            case 'wrap_s':
              this.wrap_s = child.textContent;
              break;
            case 'wrap_t':
              this.wrap_t = child.textContent;
              break;
            default:
              console.log("unhandled Sampler2D prop: " + child.nodeName);
              break;
          }
        }
        return this;
      };
      function Effect() {
        this.id = "";
        this.name = "";
        this.shader = null;
        this.surface = {};
        this.sampler = {};
      }
      ;
      Effect.prototype.create = function() {
        if (this.shader === null) {
          return null;
        }
      };
      Effect.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        extractDoubleSided(this, element);
        this.shader = null;
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'profile_COMMON':
              this.parseTechnique(this.parseProfileCOMMON(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      Effect.prototype.parseNewparam = function(element) {
        var sid = element.getAttribute('sid');
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'surface':
              this.surface[sid] = (new Surface(this)).parse(child);
              break;
            case 'sampler2D':
              this.sampler[sid] = (new Sampler2D(this)).parse(child);
              break;
            case 'extra':
              break;
            default:
              console.log(child.nodeName);
              break;
          }
        }
      };
      Effect.prototype.parseProfileCOMMON = function(element) {
        var technique;
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'profile_COMMON':
              this.parseProfileCOMMON(child);
              break;
            case 'technique':
              technique = child;
              break;
            case 'newparam':
              this.parseNewparam(child);
              break;
            case 'image':
              var _image = (new _Image()).parse(child);
              images[_image.id] = _image;
              break;
            case 'extra':
              break;
            default:
              console.log(child.nodeName);
              break;
          }
        }
        return technique;
      };
      Effect.prototype.parseTechnique = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'constant':
            case 'lambert':
            case 'blinn':
            case 'phong':
              this.shader = (new Shader(child.nodeName, this)).parse(child);
              break;
            case 'extra':
              this.parseExtra(child);
              break;
            default:
              break;
          }
        }
      };
      Effect.prototype.parseExtra = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'technique':
              this.parseExtraTechnique(child);
              break;
            default:
              break;
          }
        }
      };
      Effect.prototype.parseExtraTechnique = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'bump':
              this.shader.parse(element);
              break;
            default:
              break;
          }
        }
      };
      function InstanceEffect() {
        this.url = "";
      }
      ;
      InstanceEffect.prototype.parse = function(element) {
        this.url = element.getAttribute('url').replace(/^#/, '');
        return this;
      };
      function Animation() {
        this.id = "";
        this.name = "";
        this.source = {};
        this.sampler = [];
        this.channel = [];
      }
      ;
      Animation.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        this.source = {};
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'animation':
              var anim = (new Animation()).parse(child);
              for (var src in anim.source) {
                this.source[src] = anim.source[src];
              }
              for (var j = 0; j < anim.channel.length; j++) {
                this.channel.push(anim.channel[j]);
                this.sampler.push(anim.sampler[j]);
              }
              break;
            case 'source':
              var src = (new Source()).parse(child);
              this.source[src.id] = src;
              break;
            case 'sampler':
              this.sampler.push((new Sampler(this)).parse(child));
              break;
            case 'channel':
              this.channel.push((new Channel(this)).parse(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Channel(animation) {
        this.animation = animation;
        this.source = "";
        this.target = "";
        this.fullSid = null;
        this.sid = null;
        this.dotSyntax = null;
        this.arrSyntax = null;
        this.arrIndices = null;
        this.member = null;
      }
      ;
      Channel.prototype.parse = function(element) {
        this.source = element.getAttribute('source').replace(/^#/, '');
        this.target = element.getAttribute('target');
        var parts = this.target.split('/');
        var id = parts.shift();
        var sid = parts.shift();
        var dotSyntax = (sid.indexOf(".") >= 0);
        var arrSyntax = (sid.indexOf("(") >= 0);
        if (dotSyntax) {
          parts = sid.split(".");
          this.sid = parts.shift();
          this.member = parts.shift();
        } else if (arrSyntax) {
          var arrIndices = sid.split("(");
          this.sid = arrIndices.shift();
          for (var j = 0; j < arrIndices.length; j++) {
            arrIndices[j] = parseInt(arrIndices[j].replace(/\)/, ''));
          }
          this.arrIndices = arrIndices;
        } else {
          this.sid = sid;
        }
        this.fullSid = sid;
        this.dotSyntax = dotSyntax;
        this.arrSyntax = arrSyntax;
        return this;
      };
      function Sampler(animation) {
        this.id = "";
        this.animation = animation;
        this.inputs = [];
        this.input = null;
        this.output = null;
        this.strideOut = null;
        this.interpolation = null;
        this.startTime = null;
        this.endTime = null;
        this.duration = 0;
      }
      ;
      Sampler.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.inputs = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'input':
              this.inputs.push((new Input()).parse(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      Sampler.prototype.create = function() {
        for (var i = 0; i < this.inputs.length; i++) {
          var input = this.inputs[i];
          var source = this.animation.source[input.source];
          switch (input.semantic) {
            case 'INPUT':
              this.input = source.read();
              break;
            case 'OUTPUT':
              this.output = source.read();
              this.strideOut = source.accessor.stride;
              break;
            case 'INTERPOLATION':
              this.interpolation = source.read();
              break;
            case 'IN_TANGENT':
              break;
            case 'OUT_TANGENT':
              break;
            default:
              console.log(input.semantic);
              break;
          }
        }
        this.startTime = 0;
        this.endTime = 0;
        this.duration = 0;
        if (this.input.length) {
          this.startTime = 100000000;
          this.endTime = -100000000;
          for (var i = 0; i < this.input.length; i++) {
            this.startTime = Math.min(this.startTime, this.input[i]);
            this.endTime = Math.max(this.endTime, this.input[i]);
          }
          this.duration = this.endTime - this.startTime;
        }
      };
      Sampler.prototype.getData = function(type, ndx, member) {
        var data;
        if (type === 'matrix' && this.strideOut === 16) {
          data = this.output[ndx];
        } else if (this.strideOut > 1) {
          data = [];
          ndx *= this.strideOut;
          for (var i = 0; i < this.strideOut; ++i) {
            data[i] = this.output[ndx + i];
          }
          if (this.strideOut === 3) {
            switch (type) {
              case 'rotate':
              case 'translate':
                fixCoords(data, -1);
                break;
              case 'scale':
                fixCoords(data, 1);
                break;
            }
          } else if (this.strideOut === 4 && type === 'matrix') {
            fixCoords(data, -1);
          }
        } else {
          data = this.output[ndx];
          if (member && type === 'translate') {
            data = getConvertedTranslation(member, data);
          }
        }
        return data;
      };
      function Key(time) {
        this.targets = [];
        this.time = time;
      }
      ;
      Key.prototype.addTarget = function(fullSid, transform, member, data) {
        this.targets.push({
          sid: fullSid,
          member: member,
          transform: transform,
          data: data
        });
      };
      Key.prototype.apply = function(opt_sid) {
        for (var i = 0; i < this.targets.length; ++i) {
          var target = this.targets[i];
          if (!opt_sid || target.sid === opt_sid) {
            target.transform.update(target.data, target.member);
          }
        }
      };
      Key.prototype.getTarget = function(fullSid) {
        for (var i = 0; i < this.targets.length; ++i) {
          if (this.targets[i].sid === fullSid) {
            return this.targets[i];
          }
        }
        return null;
      };
      Key.prototype.hasTarget = function(fullSid) {
        for (var i = 0; i < this.targets.length; ++i) {
          if (this.targets[i].sid === fullSid) {
            return true;
          }
        }
        return false;
      };
      Key.prototype.interpolate = function(nextKey, time) {
        for (var i = 0,
            l = this.targets.length; i < l; i++) {
          var target = this.targets[i],
              nextTarget = nextKey.getTarget(target.sid),
              data;
          if (target.transform.type !== 'matrix' && nextTarget) {
            var scale = (time - this.time) / (nextKey.time - this.time),
                nextData = nextTarget.data,
                prevData = target.data;
            if (scale < 0)
              scale = 0;
            if (scale > 1)
              scale = 1;
            if (prevData.length) {
              data = [];
              for (var j = 0; j < prevData.length; ++j) {
                data[j] = prevData[j] + (nextData[j] - prevData[j]) * scale;
              }
            } else {
              data = prevData + (nextData - prevData) * scale;
            }
          } else {
            data = target.data;
          }
          target.transform.update(data, target.member);
        }
      };
      function Camera() {
        this.id = "";
        this.name = "";
        this.technique = "";
      }
      ;
      Camera.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'optics':
              this.parseOptics(child);
              break;
            default:
              break;
          }
        }
        return this;
      };
      Camera.prototype.parseOptics = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          if (element.childNodes[i].nodeName === 'technique_common') {
            var technique = element.childNodes[i];
            for (var j = 0; j < technique.childNodes.length; j++) {
              this.technique = technique.childNodes[j].nodeName;
              if (this.technique === 'perspective') {
                var perspective = technique.childNodes[j];
                for (var k = 0; k < perspective.childNodes.length; k++) {
                  var param = perspective.childNodes[k];
                  switch (param.nodeName) {
                    case 'yfov':
                      this.yfov = param.textContent;
                      break;
                    case 'xfov':
                      this.xfov = param.textContent;
                      break;
                    case 'znear':
                      this.znear = param.textContent;
                      break;
                    case 'zfar':
                      this.zfar = param.textContent;
                      break;
                    case 'aspect_ratio':
                      this.aspect_ratio = param.textContent;
                      break;
                  }
                }
              } else if (this.technique === 'orthographic') {
                var orthographic = technique.childNodes[j];
                for (var k = 0; k < orthographic.childNodes.length; k++) {
                  var param = orthographic.childNodes[k];
                  switch (param.nodeName) {
                    case 'xmag':
                      this.xmag = param.textContent;
                      break;
                    case 'ymag':
                      this.ymag = param.textContent;
                      break;
                    case 'znear':
                      this.znear = param.textContent;
                      break;
                    case 'zfar':
                      this.zfar = param.textContent;
                      break;
                    case 'aspect_ratio':
                      this.aspect_ratio = param.textContent;
                      break;
                  }
                }
              }
            }
          }
        }
        return this;
      };
      function InstanceCamera() {
        this.url = "";
      }
      ;
      InstanceCamera.prototype.parse = function(element) {
        this.url = element.getAttribute('url').replace(/^#/, '');
        return this;
      };
      function Light() {
        this.id = "";
        this.name = "";
        this.technique = "";
      }
      ;
      Light.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'technique_common':
              this.parseCommon(child);
              break;
            case 'technique':
              this.parseTechnique(child);
              break;
            default:
              break;
          }
        }
        return this;
      };
      Light.prototype.parseCommon = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          switch (element.childNodes[i].nodeName) {
            case 'directional':
            case 'point':
            case 'spot':
            case 'ambient':
              this.technique = element.childNodes[i].nodeName;
              var light = element.childNodes[i];
              for (var j = 0; j < light.childNodes.length; j++) {
                var child = light.childNodes[j];
                switch (child.nodeName) {
                  case 'color':
                    var rgba = _floats(child.textContent);
                    this.color = new THREE.Color(0);
                    this.color.setRGB(rgba[0], rgba[1], rgba[2]);
                    this.color.a = rgba[3];
                    break;
                  case 'falloff_angle':
                    this.falloff_angle = parseFloat(child.textContent);
                    break;
                  case 'quadratic_attenuation':
                    var f = parseFloat(child.textContent);
                    this.distance = f ? Math.sqrt(1 / f) : 0;
                }
              }
          }
        }
        return this;
      };
      Light.prototype.parseTechnique = function(element) {
        this.profile = element.getAttribute('profile');
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          switch (child.nodeName) {
            case 'intensity':
              this.intensity = parseFloat(child.textContent);
              break;
          }
        }
        return this;
      };
      function InstanceLight() {
        this.url = "";
      }
      ;
      InstanceLight.prototype.parse = function(element) {
        this.url = element.getAttribute('url').replace(/^#/, '');
        return this;
      };
      function KinematicsModel() {
        this.id = '';
        this.name = '';
        this.joints = [];
        this.links = [];
      }
      KinematicsModel.prototype.parse = function(element) {
        this.id = element.getAttribute('id');
        this.name = element.getAttribute('name');
        this.joints = [];
        this.links = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'technique_common':
              this.parseCommon(child);
              break;
            default:
              break;
          }
        }
        return this;
      };
      KinematicsModel.prototype.parseCommon = function(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (element.childNodes[i].nodeName) {
            case 'joint':
              this.joints.push((new Joint()).parse(child));
              break;
            case 'link':
              this.links.push((new Link()).parse(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Joint() {
        this.sid = '';
        this.name = '';
        this.axis = new THREE.Vector3();
        this.limits = {
          min: 0,
          max: 0
        };
        this.type = '';
        this.static = false;
        this.zeroPosition = 0.0;
        this.middlePosition = 0.0;
      }
      Joint.prototype.parse = function(element) {
        this.sid = element.getAttribute('sid');
        this.name = element.getAttribute('name');
        this.axis = new THREE.Vector3();
        this.limits = {
          min: 0,
          max: 0
        };
        this.type = '';
        this.static = false;
        this.zeroPosition = 0.0;
        this.middlePosition = 0.0;
        var axisElement = element.querySelector('axis');
        var _axis = _floats(axisElement.textContent);
        this.axis = getConvertedVec3(_axis, 0);
        var min = element.querySelector('limits min') ? parseFloat(element.querySelector('limits min').textContent) : -360;
        var max = element.querySelector('limits max') ? parseFloat(element.querySelector('limits max').textContent) : 360;
        this.limits = {
          min: min,
          max: max
        };
        var jointTypes = ['prismatic', 'revolute'];
        for (var i = 0; i < jointTypes.length; i++) {
          var type = jointTypes[i];
          var jointElement = element.querySelector(type);
          if (jointElement) {
            this.type = type;
          }
        }
        if (this.limits.min >= this.limits.max) {
          this.static = true;
        }
        this.middlePosition = (this.limits.min + this.limits.max) / 2.0;
        return this;
      };
      function Link() {
        this.sid = '';
        this.name = '';
        this.transforms = [];
        this.attachments = [];
      }
      Link.prototype.parse = function(element) {
        this.sid = element.getAttribute('sid');
        this.name = element.getAttribute('name');
        this.transforms = [];
        this.attachments = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'attachment_full':
              this.attachments.push((new Attachment()).parse(child));
              break;
            case 'rotate':
            case 'translate':
            case 'matrix':
              this.transforms.push((new Transform()).parse(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      function Attachment() {
        this.joint = '';
        this.transforms = [];
        this.links = [];
      }
      Attachment.prototype.parse = function(element) {
        this.joint = element.getAttribute('joint').split('/').pop();
        this.links = [];
        for (var i = 0; i < element.childNodes.length; i++) {
          var child = element.childNodes[i];
          if (child.nodeType != 1)
            continue;
          switch (child.nodeName) {
            case 'link':
              this.links.push((new Link()).parse(child));
              break;
            case 'rotate':
            case 'translate':
            case 'matrix':
              this.transforms.push((new Transform()).parse(child));
              break;
            default:
              break;
          }
        }
        return this;
      };
      function _source(element) {
        var id = element.getAttribute('id');
        if (sources[id] != undefined) {
          return sources[id];
        }
        sources[id] = (new Source(id)).parse(element);
        return sources[id];
      }
      ;
      function _nsResolver(nsPrefix) {
        if (nsPrefix === "dae") {
          return "http://www.collada.org/2005/11/COLLADASchema";
        }
        return null;
      }
      ;
      function _bools(str) {
        var raw = _strings(str);
        var data = [];
        for (var i = 0,
            l = raw.length; i < l; i++) {
          data.push((raw[i] === 'true' || raw[i] === '1') ? true : false);
        }
        return data;
      }
      ;
      function _floats(str) {
        var raw = _strings(str);
        var data = [];
        for (var i = 0,
            l = raw.length; i < l; i++) {
          data.push(parseFloat(raw[i]));
        }
        return data;
      }
      ;
      function _ints(str) {
        var raw = _strings(str);
        var data = [];
        for (var i = 0,
            l = raw.length; i < l; i++) {
          data.push(parseInt(raw[i], 10));
        }
        return data;
      }
      ;
      function _strings(str) {
        return (str.length > 0) ? _trimString(str).split(/\s+/) : [];
      }
      ;
      function _trimString(str) {
        return str.replace(/^\s+/, "").replace(/\s+$/, "");
      }
      ;
      function _attr_as_float(element, name, defaultValue) {
        if (element.hasAttribute(name)) {
          return parseFloat(element.getAttribute(name));
        } else {
          return defaultValue;
        }
      }
      ;
      function _attr_as_int(element, name, defaultValue) {
        if (element.hasAttribute(name)) {
          return parseInt(element.getAttribute(name), 10);
        } else {
          return defaultValue;
        }
      }
      ;
      function _attr_as_string(element, name, defaultValue) {
        if (element.hasAttribute(name)) {
          return element.getAttribute(name);
        } else {
          return defaultValue;
        }
      }
      ;
      function _format_float(f, num) {
        if (f === undefined) {
          var s = '0.';
          while (s.length < num + 2) {
            s += '0';
          }
          return s;
        }
        num = num || 2;
        var parts = f.toString().split('.');
        parts[1] = parts.length > 1 ? parts[1].substr(0, num) : "0";
        while (parts[1].length < num) {
          parts[1] += '0';
        }
        return parts.join('.');
      }
      ;
      function loadTextureImage(texture, url) {
        var loader = new THREE.ImageLoader();
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
        });
      }
      ;
      function applySkin(geometry, instanceCtrl, frame) {
        var skinController = controllers[instanceCtrl.url];
        frame = frame !== undefined ? frame : 40;
        if (!skinController || !skinController.skin) {
          console.log('ColladaLoader: Could not find skin controller.');
          return;
        }
        if (!instanceCtrl.skeleton || !instanceCtrl.skeleton.length) {
          console.log('ColladaLoader: Could not find the skeleton for the skin. ');
          return;
        }
        var animationBounds = calcAnimationBounds();
        var skeleton = visualScene.getChildById(instanceCtrl.skeleton[0], true) || visualScene.getChildBySid(instanceCtrl.skeleton[0], true);
        var bonelist = flattenSkeleton(skeleton);
        var joints = skinController.skin.joints;
        var sortedbones = [];
        for (var i = 0; i < joints.length; i++) {
          for (var j = 0; j < bonelist.length; j++) {
            if (bonelist[j].name === joints[i]) {
              sortedbones[i] = bonelist[j];
            }
          }
        }
        for (var i = 0; i < sortedbones.length; i++) {
          for (var j = 0; j < sortedbones.length; j++) {
            if (sortedbones[i].parent === sortedbones[j].name) {
              sortedbones[i].parent = j;
            }
          }
        }
        var i,
            j,
            w,
            vidx,
            weight;
        var v = new THREE.Vector3(),
            o,
            s;
        for (i = 0; i < geometry.vertices.length; i++) {
          geometry.vertices[i].applyMatrix4(skinController.skin.bindShapeMatrix);
        }
        var skinIndices = [];
        var skinWeights = [];
        var weights = skinController.skin.weights;
        for (var i = 0; i < weights.length; i++) {
          var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0, weights[i][1] ? weights[i][1].joint : 0, weights[i][2] ? weights[i][2].joint : 0, weights[i][3] ? weights[i][3].joint : 0);
          var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0, weights[i][1] ? weights[i][1].weight : 0, weights[i][2] ? weights[i][2].weight : 0, weights[i][3] ? weights[i][3].weight : 0);
          skinIndices.push(indicies);
          skinWeights.push(weight);
        }
        geometry.skinIndices = skinIndices;
        geometry.skinWeights = skinWeights;
        geometry.bones = sortedbones;
        var animationdata = {
          "name": animationBounds.ID,
          "fps": 30,
          "length": animationBounds.frames / 30,
          "hierarchy": []
        };
        for (var j = 0; j < sortedbones.length; j++) {
          animationdata.hierarchy.push({
            parent: sortedbones[j].parent,
            name: sortedbones[j].name,
            keys: []
          });
        }
        console.log('ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.');
        skinToBindPose(geometry, skeleton, skinController);
        for (frame = 0; frame < animationBounds.frames; frame++) {
          var bones = [];
          var skinned = [];
          setupSkeleton(skeleton, bones, frame);
          setupSkinningMatrices(bones, skinController.skin);
          for (var i = 0; i < bones.length; i++) {
            for (var j = 0; j < animationdata.hierarchy.length; j++) {
              if (animationdata.hierarchy[j].name === bones[i].sid) {
                var key = {};
                key.time = (frame / 30);
                key.matrix = bones[i].animatrix;
                if (frame === 0)
                  bones[i].matrix = key.matrix;
                var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
                key.matrix.decompose(data[0], data[1], data[2]);
                key.pos = [data[0].x, data[0].y, data[0].z];
                key.scl = [data[2].x, data[2].y, data[2].z];
                key.rot = data[1];
                animationdata.hierarchy[j].keys.push(key);
              }
            }
          }
          geometry.animation = animationdata;
        }
      }
      ;
      function calcAnimationBounds() {
        var start = 1000000;
        var end = -start;
        var frames = 0;
        var ID;
        for (var id in animations) {
          var animation = animations[id];
          ID = ID || animation.id;
          for (var i = 0; i < animation.sampler.length; i++) {
            var sampler = animation.sampler[i];
            sampler.create();
            start = Math.min(start, sampler.startTime);
            end = Math.max(end, sampler.endTime);
            frames = Math.max(frames, sampler.input.length);
          }
        }
        return {
          start: start,
          end: end,
          frames: frames,
          ID: ID
        };
      }
      ;
      function createSceneGraph(node, parent) {
        var obj = new THREE.Object3D();
        var skinned = false;
        var skinController;
        var morphController;
        var i,
            j;
        for (i = 0; i < node.controllers.length; i++) {
          var controller = controllers[node.controllers[i].url];
          switch (controller.type) {
            case 'skin':
              if (geometries[controller.skin.source]) {
                var inst_geom = new InstanceGeometry();
                inst_geom.url = controller.skin.source;
                inst_geom.instance_material = node.controllers[i].instance_material;
                node.geometries.push(inst_geom);
                skinned = true;
                skinController = node.controllers[i];
              } else if (controllers[controller.skin.source]) {
                var second = controllers[controller.skin.source];
                morphController = second;
                if (second.morph && geometries[second.morph.source]) {
                  var inst_geom = new InstanceGeometry();
                  inst_geom.url = second.morph.source;
                  inst_geom.instance_material = node.controllers[i].instance_material;
                  node.geometries.push(inst_geom);
                }
              }
              break;
            case 'morph':
              if (geometries[controller.morph.source]) {
                var inst_geom = new InstanceGeometry();
                inst_geom.url = controller.morph.source;
                inst_geom.instance_material = node.controllers[i].instance_material;
                node.geometries.push(inst_geom);
                morphController = node.controllers[i];
              }
              console.log('ColladaLoader: Morph-controller partially supported.');
            default:
              break;
          }
        }
        var double_sided_materials = {};
        for (i = 0; i < node.geometries.length; i++) {
          var instance_geometry = node.geometries[i];
          var instance_materials = instance_geometry.instance_material;
          var geometry = geometries[instance_geometry.url];
          var used_materials = {};
          var used_materials_array = [];
          var num_materials = 0;
          var first_material;
          if (geometry) {
            if (!geometry.mesh || !geometry.mesh.primitives)
              continue;
            if (obj.name.length === 0) {
              obj.name = geometry.id;
            }
            if (instance_materials) {
              for (j = 0; j < instance_materials.length; j++) {
                var instance_material = instance_materials[j];
                var mat = materials[instance_material.target];
                var effect_id = mat.instance_effect.url;
                var shader = effects[effect_id].shader;
                var material3js = shader.material;
                if (geometry.doubleSided) {
                  if (!(instance_material.symbol in double_sided_materials)) {
                    var _copied_material = material3js.clone();
                    _copied_material.side = THREE.DoubleSide;
                    double_sided_materials[instance_material.symbol] = _copied_material;
                  }
                  material3js = double_sided_materials[instance_material.symbol];
                }
                material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
                used_materials[instance_material.symbol] = num_materials;
                used_materials_array.push(material3js);
                first_material = material3js;
                first_material.name = mat.name === null || mat.name === '' ? mat.id : mat.name;
                num_materials++;
              }
            }
            var mesh;
            var material = first_material || new THREE.MeshLambertMaterial({
              color: 0xdddddd,
              side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide
            });
            var geom = geometry.mesh.geometry3js;
            if (num_materials > 1) {
              material = new THREE.MeshFaceMaterial(used_materials_array);
              for (j = 0; j < geom.faces.length; j++) {
                var face = geom.faces[j];
                face.materialIndex = used_materials[face.daeMaterial];
              }
            }
            if (skinController !== undefined) {
              applySkin(geom, skinController);
              if (geom.morphTargets.length > 0) {
                material.morphTargets = true;
                material.skinning = false;
              } else {
                material.morphTargets = false;
                material.skinning = true;
              }
              mesh = new THREE.SkinnedMesh(geom, material, false);
              mesh.name = 'skin_' + skins.length;
              skins.push(mesh);
            } else if (morphController !== undefined) {
              createMorph(geom, morphController);
              material.morphTargets = true;
              mesh = new THREE.Mesh(geom, material);
              mesh.name = 'morph_' + morphs.length;
              morphs.push(mesh);
            } else {
              if (geom.isLineStrip === true) {
                mesh = new THREE.Line(geom);
              } else {
                mesh = new THREE.Mesh(geom, material);
              }
            }
            obj.add(mesh);
          }
        }
        for (i = 0; i < node.cameras.length; i++) {
          var instance_camera = node.cameras[i];
          var cparams = cameras[instance_camera.url];
          var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio), parseFloat(cparams.znear), parseFloat(cparams.zfar));
          obj.add(cam);
        }
        for (i = 0; i < node.lights.length; i++) {
          var light = null;
          var instance_light = node.lights[i];
          var lparams = lights[instance_light.url];
          if (lparams && lparams.technique) {
            var color = lparams.color.getHex();
            var intensity = lparams.intensity;
            var distance = lparams.distance;
            var angle = lparams.falloff_angle;
            var exponent;
            switch (lparams.technique) {
              case 'directional':
                light = new THREE.DirectionalLight(color, intensity, distance);
                light.position.set(0, 0, 1);
                break;
              case 'point':
                light = new THREE.PointLight(color, intensity, distance);
                break;
              case 'spot':
                light = new THREE.SpotLight(color, intensity, distance, angle, exponent);
                light.position.set(0, 0, 1);
                break;
              case 'ambient':
                light = new THREE.AmbientLight(color);
                break;
            }
          }
          if (light) {
            obj.add(light);
          }
        }
        obj.name = node.name || node.id || "";
        obj.colladaId = node.id || "";
        obj.layer = node.layer || "";
        obj.matrix = node.matrix;
        obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);
        if (options.centerGeometry && obj.geometry) {
          var delta = obj.geometry.center();
          delta.multiply(obj.scale);
          delta.applyQuaternion(obj.quaternion);
          obj.position.sub(delta);
        }
        for (i = 0; i < node.nodes.length; i++) {
          obj.add(createSceneGraph(node.nodes[i], node));
        }
        return obj;
      }
      ;
      function bakeAnimations(node) {
        if (node.channels && node.channels.length) {
          var keys = [],
              sids = [];
          for (var i = 0,
              il = node.channels.length; i < il; i++) {
            var channel = node.channels[i],
                fullSid = channel.fullSid,
                sampler = channel.sampler,
                input = sampler.input,
                transform = node.getTransformBySid(channel.sid),
                member;
            if (channel.arrIndices) {
              member = [];
              for (var j = 0,
                  jl = channel.arrIndices.length; j < jl; j++) {
                member[j] = getConvertedIndex(channel.arrIndices[j]);
              }
            } else {
              member = getConvertedMember(channel.member);
            }
            if (transform) {
              if (sids.indexOf(fullSid) === -1) {
                sids.push(fullSid);
              }
              for (var j = 0,
                  jl = input.length; j < jl; j++) {
                var time = input[j],
                    data = sampler.getData(transform.type, j, member),
                    key = findKey(keys, time);
                if (!key) {
                  key = new Key(time);
                  var timeNdx = findTimeNdx(keys, time);
                  keys.splice(timeNdx === -1 ? keys.length : timeNdx, 0, key);
                }
                key.addTarget(fullSid, transform, member, data);
              }
            } else {
              console.log('Could not find transform "' + channel.sid + '" in node ' + node.id);
            }
          }
          for (var i = 0; i < sids.length; i++) {
            var sid = sids[i];
            for (var j = 0; j < keys.length; j++) {
              var key = keys[j];
              if (!key.hasTarget(sid)) {
                interpolateKeys(keys, key, j, sid);
              }
            }
          }
          node.keys = keys;
          node.sids = sids;
        }
      }
      ;
      function extractDoubleSided(obj, element) {
        obj.doubleSided = false;
        var node = element.querySelectorAll('extra double_sided')[0];
        if (node) {
          if (node && parseInt(node.textContent, 10) === 1) {
            obj.doubleSided = true;
          }
        }
      }
      ;
      function findKey(keys, time) {
        var retVal = null;
        for (var i = 0,
            il = keys.length; i < il && retVal === null; i++) {
          var key = keys[i];
          if (key.time === time) {
            retVal = key;
          } else if (key.time > time) {
            break;
          }
        }
        return retVal;
      }
      ;
      function findTimeNdx(keys, time) {
        var ndx = -1;
        for (var i = 0,
            il = keys.length; i < il && ndx === -1; i++) {
          var key = keys[i];
          if (key.time >= time) {
            ndx = i;
          }
        }
        return ndx;
      }
      ;
      function fixCoords(data, sign) {
        if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
          return;
        }
        switch (upConversion) {
          case 'XtoY':
            var tmp = data[0];
            data[0] = sign * data[1];
            data[1] = tmp;
            break;
          case 'XtoZ':
            var tmp = data[2];
            data[2] = data[1];
            data[1] = data[0];
            data[0] = tmp;
            break;
          case 'YtoX':
            var tmp = data[0];
            data[0] = data[1];
            data[1] = sign * tmp;
            break;
          case 'YtoZ':
            var tmp = data[1];
            data[1] = sign * data[2];
            data[2] = tmp;
            break;
          case 'ZtoX':
            var tmp = data[0];
            data[0] = data[1];
            data[1] = data[2];
            data[2] = tmp;
            break;
          case 'ZtoY':
            var tmp = data[1];
            data[1] = data[2];
            data[2] = sign * tmp;
            break;
        }
      }
      ;
      function flattenSkeleton(skeleton) {
        var list = [];
        var walk = function(parentid, node, list) {
          var bone = {};
          bone.name = node.sid;
          bone.parent = parentid;
          bone.matrix = node.matrix;
          var data = [new THREE.Vector3(), new THREE.Quaternion(), new THREE.Vector3()];
          bone.matrix.decompose(data[0], data[1], data[2]);
          bone.pos = [data[0].x, data[0].y, data[0].z];
          bone.scl = [data[2].x, data[2].y, data[2].z];
          bone.rotq = [data[1].x, data[1].y, data[1].z, data[1].w];
          list.push(bone);
          for (var i in node.nodes) {
            walk(node.sid, node.nodes[i], list);
          }
        };
        walk(-1, skeleton, list);
        return list;
      }
      ;
      function getConvertedTranslation(axis, data) {
        if (options.convertUpAxis !== true || colladaUp === options.upAxis) {
          return data;
        }
        switch (axis) {
          case 'X':
            data = upConversion === 'XtoY' ? data * -1 : data;
            break;
          case 'Y':
            data = upConversion === 'YtoZ' || upConversion === 'YtoX' ? data * -1 : data;
            break;
          case 'Z':
            data = upConversion === 'ZtoY' ? data * -1 : data;
            break;
          default:
            break;
        }
        return data;
      }
      ;
      function getConvertedVec3(data, offset) {
        var arr = [data[offset], data[offset + 1], data[offset + 2]];
        fixCoords(arr, -1);
        return new THREE.Vector3(arr[0], arr[1], arr[2]);
      }
      ;
      function getConvertedMat4(data) {
        if (options.convertUpAxis) {
          var arr = [data[0], data[4], data[8]];
          fixCoords(arr, -1);
          data[0] = arr[0];
          data[4] = arr[1];
          data[8] = arr[2];
          arr = [data[1], data[5], data[9]];
          fixCoords(arr, -1);
          data[1] = arr[0];
          data[5] = arr[1];
          data[9] = arr[2];
          arr = [data[2], data[6], data[10]];
          fixCoords(arr, -1);
          data[2] = arr[0];
          data[6] = arr[1];
          data[10] = arr[2];
          arr = [data[0], data[1], data[2]];
          fixCoords(arr, -1);
          data[0] = arr[0];
          data[1] = arr[1];
          data[2] = arr[2];
          arr = [data[4], data[5], data[6]];
          fixCoords(arr, -1);
          data[4] = arr[0];
          data[5] = arr[1];
          data[6] = arr[2];
          arr = [data[8], data[9], data[10]];
          fixCoords(arr, -1);
          data[8] = arr[0];
          data[9] = arr[1];
          data[10] = arr[2];
          arr = [data[3], data[7], data[11]];
          fixCoords(arr, -1);
          data[3] = arr[0];
          data[7] = arr[1];
          data[11] = arr[2];
        }
        return new THREE.Matrix4().set(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
      }
      ;
      function getConvertedIndex(index) {
        if (index > -1 && index < 3) {
          var members = ['X', 'Y', 'Z'],
              indices = {
                X: 0,
                Y: 1,
                Z: 2
              };
          index = getConvertedMember(members[index]);
          index = indices[index];
        }
        return index;
      }
      ;
      function getChannelsForNode(node) {
        var channels = [];
        var startTime = 1000000;
        var endTime = -1000000;
        for (var id in animations) {
          var animation = animations[id];
          for (var i = 0; i < animation.channel.length; i++) {
            var channel = animation.channel[i];
            var sampler = animation.sampler[i];
            var id = channel.target.split('/')[0];
            if (id == node.id) {
              sampler.create();
              channel.sampler = sampler;
              startTime = Math.min(startTime, sampler.startTime);
              endTime = Math.max(endTime, sampler.endTime);
              channels.push(channel);
            }
          }
        }
        if (channels.length) {
          node.startTime = startTime;
          node.endTime = endTime;
        }
        return channels;
      }
      ;
      function getConvertedMember(member) {
        if (options.convertUpAxis) {
          switch (member) {
            case 'X':
              switch (upConversion) {
                case 'XtoY':
                case 'XtoZ':
                case 'YtoX':
                  member = 'Y';
                  break;
                case 'ZtoX':
                  member = 'Z';
                  break;
              }
              break;
            case 'Y':
              switch (upConversion) {
                case 'XtoY':
                case 'YtoX':
                case 'ZtoX':
                  member = 'X';
                  break;
                case 'XtoZ':
                case 'YtoZ':
                case 'ZtoY':
                  member = 'Z';
                  break;
              }
              break;
            case 'Z':
              switch (upConversion) {
                case 'XtoZ':
                  member = 'X';
                  break;
                case 'YtoZ':
                case 'ZtoX':
                case 'ZtoY':
                  member = 'Y';
                  break;
              }
              break;
          }
        }
        return member;
      }
      ;
      function getLibraryNode(id) {
        var nodes = COLLADA.querySelectorAll('library_nodes node');
        for (var i = 0; i < nodes.length; i++) {
          var attObj = nodes[i].attributes.getNamedItem('id');
          if (attObj && attObj.value === id) {
            return nodes[i];
          }
        }
        return undefined;
      }
      ;
      function getNextKeyWith(keys, fullSid, ndx) {
        for (; ndx < keys.length; ndx++) {
          var key = keys[ndx];
          if (key.hasTarget(fullSid)) {
            return key;
          }
        }
        return null;
      }
      ;
      function getPrevKeyWith(keys, fullSid, ndx) {
        ndx = ndx >= 0 ? ndx : ndx + keys.length;
        for (; ndx >= 0; ndx--) {
          var key = keys[ndx];
          if (key.hasTarget(fullSid)) {
            return key;
          }
        }
        return null;
      }
      ;
      function interpolateKeys(keys, key, ndx, fullSid) {
        var prevKey = getPrevKeyWith(keys, fullSid, ndx ? ndx - 1 : 0),
            nextKey = getNextKeyWith(keys, fullSid, ndx + 1);
        if (prevKey && nextKey) {
          var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
              prevTarget = prevKey.getTarget(fullSid),
              nextData = nextKey.getTarget(fullSid).data,
              prevData = prevTarget.data,
              data;
          if (prevTarget.type === 'matrix') {
            data = prevData;
          } else if (prevData.length) {
            data = [];
            for (var i = 0; i < prevData.length; ++i) {
              data[i] = prevData[i] + (nextData[i] - prevData[i]) * scale;
            }
          } else {
            data = prevData + (nextData - prevData) * scale;
          }
          key.addTarget(fullSid, prevTarget.transform, prevTarget.member, data);
        }
      }
      ;
      function recurseHierarchy(node) {
        var n = visualScene.getChildById(node.colladaId, true),
            newData = null;
        if (n && n.keys) {
          newData = {
            fps: 60,
            hierarchy: [{
              node: n,
              keys: n.keys,
              sids: n.sids
            }],
            node: node,
            name: 'animation_' + node.name,
            length: 0
          };
          animData.push(newData);
          for (var i = 0,
              il = n.keys.length; i < il; i++) {
            newData.length = Math.max(newData.length, n.keys[i].time);
          }
        } else {
          newData = {hierarchy: [{
              keys: [],
              sids: []
            }]};
        }
        for (var i = 0,
            il = node.children.length; i < il; i++) {
          var d = recurseHierarchy(node.children[i]);
          for (var j = 0,
              jl = d.hierarchy.length; j < jl; j++) {
            newData.hierarchy.push({
              keys: [],
              sids: []
            });
          }
        }
        return newData;
      }
      ;
      function setupSkeleton(node, bones, frame, parent) {
        node.world = node.world || new THREE.Matrix4();
        node.localworld = node.localworld || new THREE.Matrix4();
        node.world.copy(node.matrix);
        node.localworld.copy(node.matrix);
        if (node.channels && node.channels.length) {
          var channel = node.channels[0];
          var m = channel.sampler.output[frame];
          if (m instanceof THREE.Matrix4) {
            node.world.copy(m);
            node.localworld.copy(m);
            if (frame === 0)
              node.matrix.copy(m);
          }
        }
        if (parent) {
          node.world.multiplyMatrices(parent, node.world);
        }
        bones.push(node);
        for (var i = 0; i < node.nodes.length; i++) {
          setupSkeleton(node.nodes[i], bones, frame, node.world);
        }
      }
      ;
      function setupSkinningMatrices(bones, skin) {
        for (var i = 0; i < bones.length; i++) {
          var bone = bones[i];
          var found = -1;
          if (bone.type != 'JOINT')
            continue;
          for (var j = 0; j < skin.joints.length; j++) {
            if (bone.sid === skin.joints[j]) {
              found = j;
              break;
            }
          }
          if (found >= 0) {
            var inv = skin.invBindMatrices[found];
            bone.invBindMatrix = inv;
            bone.skinningMatrix = new THREE.Matrix4();
            bone.skinningMatrix.multiplyMatrices(bone.world, inv);
            bone.animatrix = new THREE.Matrix4();
            bone.animatrix.copy(bone.localworld);
            bone.weights = [];
            for (var j = 0; j < skin.weights.length; j++) {
              for (var k = 0; k < skin.weights[j].length; k++) {
                var w = skin.weights[j][k];
                if (w.joint === found) {
                  bone.weights.push(w);
                }
              }
            }
          } else {
            console.warn("ColladaLoader: Could not find joint '" + bone.sid + "'.");
            bone.skinningMatrix = new THREE.Matrix4();
            bone.weights = [];
          }
        }
      }
      ;
      function skinToBindPose(geometry, skeleton, skinController) {
        var bones = [];
        setupSkeleton(skeleton, bones, -1);
        setupSkinningMatrices(bones, skinController.skin);
        var v = new THREE.Vector3();
        var skinned = [];
        for (var i = 0; i < geometry.vertices.length; i++) {
          skinned.push(new THREE.Vector3());
        }
        for (var i = 0; i < bones.length; i++) {
          if (bones[i].type != 'JOINT')
            continue;
          for (var j = 0; j < bones[i].weights.length; j++) {
            var w = bones[i].weights[j];
            var vidx = w.index;
            var weight = w.weight;
            var o = geometry.vertices[vidx];
            var s = skinned[vidx];
            v.x = o.x;
            v.y = o.y;
            v.z = o.z;
            v.applyMatrix4(bones[i].skinningMatrix);
            s.x += (v.x * weight);
            s.y += (v.y * weight);
            s.z += (v.z * weight);
          }
        }
        for (var i = 0; i < geometry.vertices.length; i++) {
          geometry.vertices[i] = skinned[i];
        }
      }
      ;
    })();
  })();
  return _retrieveGlobal();
});

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("f1", [], function() {
  return "#define PHONG\n#define POINTS_NUMBER 1000.\n#define WIDTH 128.\n#define HEIGHT 128.\n\nvarying vec3 vViewPosition;\n\nuniform float offsetID;\nuniform float dataOffset;\nuniform float scale;\n\nuniform sampler2D data;\n\nattribute float id;\n\nvarying float vLengthRatio;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n// THREE.ShaderChunk[ \"common\" ],\n// THREE.ShaderChunk[ \"uv_pars_vertex\" ],\n// THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\n// THREE.ShaderChunk[ \"displacementmap_pars_vertex\" ],\n// THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n// THREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n// THREE.ShaderChunk[ \"color_pars_vertex\" ],\n// THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n// THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n// THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n// THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\n\nmat3 matrixFromEuler(vec3 euler)\n{\n\tmat3 m;\n\n\tfloat a = cos(euler.x);\n\tfloat b = sin(euler.x);\n\tfloat c = cos(euler.y);\n\tfloat d = sin(euler.y);\n\tfloat e = cos(euler.z);\n\tfloat f = sin(euler.z);\n\n\tfloat ae = a * e;\n\tfloat af = a * f;\n\tfloat be = b * e;\n\tfloat bf = b * f;\n\n\tm[0][0] = c * e;\n\tm[0][1] = - c * f;\n\tm[0][2] = d;\n\n\tm[1][0] = af + be * d;\n\tm[1][1] = ae - bf * d;\n\tm[1][2] = - b * c;\n\n\tm[2][0] = bf - ae * d;\n\tm[2][1] = be + af * d;\n\tm[2][2] = a * c;\n\n  return m;\n}\n\nvoid main() {\n\n  vec3 position = position;\n\n\tfloat pointID = mod(id + offsetID, POINTS_NUMBER) + dataOffset;\n\n\tvec4 dataChunk1 = texture2D(data, vec2(mod(pointID, WIDTH * .5) / WIDTH * 2., floor(pointID / WIDTH * 2.) / HEIGHT));\n\tvec4 dataChunk2 = texture2D(data, vec2(mod(pointID + .5, WIDTH * .5) / WIDTH * 2., floor((pointID + .5) / WIDTH * 2.) / HEIGHT));\n\n\tvec3 point = dataChunk1.xyz;\n\tfloat radius = dataChunk1.w;\n\tvec3 rotation = dataChunk2.xyz;\n\tfloat type = dataChunk2.w;\n\n\tfloat lengthRatio = id / POINTS_NUMBER;\n\n\tvLengthRatio = lengthRatio;\n\n\tposition *= radius * scale * lengthRatio;\n\n\tmat3 rotationMatrix = matrixFromEuler(rotation);\n\tposition *= rotationMatrix;\n\n\tposition += point;\n\n  // THREE.ShaderChunk[ \"uv_vertex\" ],\n  // THREE.ShaderChunk[ \"uv2_vertex\" ],\n  // THREE.ShaderChunk[ \"color_vertex\" ],\n\n  // THREE.ShaderChunk[ \"beginnormal_vertex\" ],\n  // THREE.ShaderChunk[ \"morphnormal_vertex\" ],\n  // THREE.ShaderChunk[ \"skinbase_vertex\" ],\n  // THREE.ShaderChunk[ \"skinnormal_vertex\" ],\n  // THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n  // THREE.ShaderChunk[ \"begin_vertex\" ],\n  // THREE.ShaderChunk[ \"displacementmap_vertex\" ],\n  // THREE.ShaderChunk[ \"morphtarget_vertex\" ],\n  // THREE.ShaderChunk[ \"skinning_vertex\" ],\n  // THREE.ShaderChunk[ \"project_vertex\" ],\n  // THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\n\n\tvViewPosition = - mvPosition.xyz;\n\n  // THREE.ShaderChunk[ \"worldpos_vertex\" ],\n  // THREE.ShaderChunk[ \"envmap_vertex\" ],\n  // THREE.ShaderChunk[ \"lights_phong_vertex\" ],\n  // THREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n#ifndef FLAT_SHADED\n\n\tvNormal *= rotationMatrix;\n\n#endif\n\n}\n";
});

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("f2", [], function() {
  return "#define PHONG\n\nuniform vec3 color;\nuniform vec3 tipColor;\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float emissiveIntensity;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\nvarying float vLengthRatio;\n\n// THREE.ShaderChunk[ \"common\" ],\n// THREE.ShaderChunk[ \"color_pars_fragment\" ],\n// THREE.ShaderChunk[ \"uv_pars_fragment\" ],\n// THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\n// THREE.ShaderChunk[ \"map_pars_fragment\" ],\n// THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"emissivemap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"fog_pars_fragment\" ],\n// THREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n// THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\n\nvoid main() {\n\n\tvec3 color = mix(color, tipColor, smoothstep(.9, 1., vLengthRatio));\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( color, opacity );\n\tvec3 totalAmbientLight = ambientLightColor;\n\tvec3 totalEmissiveLight = color;\n\tvec3 shadowMask = vec3( 1.0 );\n\n\ttotalEmissiveLight *= emissiveIntensity;\n\tdiffuseColor.rgb *= (1. - emissiveIntensity);\n\n\t// THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\n\t// THREE.ShaderChunk[ \"map_fragment\" ],\n\t// THREE.ShaderChunk[ \"color_fragment\" ],\n\t// THREE.ShaderChunk[ \"alphamap_fragment\" ],\n\t// THREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t// THREE.ShaderChunk[ \"specularmap_fragment\" ],\n\t// THREE.ShaderChunk[ \"normal_phong_fragment\" ],\n\t// THREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t// THREE.ShaderChunk[ \"hemilight_fragment\" ],\n\t// THREE.ShaderChunk[ \"aomap_fragment\" ],\n\t// THREE.ShaderChunk[ \"emissivemap_fragment\" ],\n\n\t// THREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\t// THREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\ttotalDiffuseLight *= shadowMask;\n\ttotalSpecularLight *= shadowMask;\n\n\t#ifdef METAL\n\n\t\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;\n\n\t#else\n\n\t\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;\n\n\t#endif\n\n\t// THREE.ShaderChunk[ \"envmap_fragment\" ],\n\n\t// THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t// THREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t// outgoingLight = mix(outgoingLight, outgoingLight + (1. - (outgoingLight.r + outgoingLight.g + outgoingLight.b) / 3.), smoothstep(.95, 1., vLengthRatio));\n\n\toutgoingLight = mix(outgoingLight, vec3(1.), step(.9985, vLengthRatio));\n\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fade = smoothstep(0.1, 10.0, depth);\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a * vLengthRatio * fade );\n\n}\n";
});

_removeDefine();
})();
$__System.register("f3", ["f4", "f5", "f6", "f7", "f8", "ef", "f0", "f9", "f1", "f2"], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, _Object$assign, THREE, ShaderUtils, VERTEX_SHADER, FRAGMENT_SHADER, POINTS_NUMBER, TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE, DATA_OFFSET, Line;

  return {
    setters: [function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_f8) {
      _Object$assign = _f8["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_f0) {}, function (_f9) {
      ShaderUtils = _f9["default"];
    }, function (_f1) {
      VERTEX_SHADER = _f1["default"];
    }, function (_f2) {
      FRAGMENT_SHADER = _f2["default"];
    }],
    execute: function () {
      "use strict";

      POINTS_NUMBER = 1000;
      TEXTURE_WIDTH = 128;
      TEXTURE_HEIGHT = 128;
      TEXTURE = new THREE.DataTexture(new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * 4), TEXTURE_WIDTH, TEXTURE_HEIGHT, THREE.RGBAFormat, THREE.FloatType);

      TEXTURE.needsUpdate = true;

      DATA_OFFSET = 0;

      Line = (function (_THREE$Object3D) {
        _inherits(Line, _THREE$Object3D);

        function Line() {
          var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

          var _ref$color = _ref.color;
          var color = _ref$color === undefined ? 0x000000 : _ref$color;
          var _ref$tipColor = _ref.tipColor;
          var tipColor = _ref$tipColor === undefined ? 0x000000 : _ref$tipColor;
          var _ref$radius = _ref.radius;
          var radius = _ref$radius === undefined ? 1 : _ref$radius;

          _classCallCheck(this, Line);

          _get(Object.getPrototypeOf(Line.prototype), "constructor", this).call(this);

          this.radius = radius;

          this._time = 0;
          this._bufferOffset = 0;

          this._matrix4Cached1 = new THREE.Matrix4();
          this._eulerCached1 = new THREE.Euler();
          this._vector3Cached1 = new THREE.Vector3();

          this.tip = new THREE.Object3D();
          this.add(this.tip);

          this._direction = new THREE.Vector3();
          this._normal = new THREE.Vector3();
          this._binormal = new THREE.Vector3();

          this._previousPosition = new THREE.Vector3();
          this._previousBinormal = new THREE.Vector3();

          var geometry = new THREE.BufferGeometry();

          var vertices = [];
          var vertexIDs = new Float32Array(POINTS_NUMBER * 8 + 8);
          var vertexNormals = [];
          var indexesArray = [];

          var normalRatio = Math.cos(Math.PI * .25);

          for (var i = 0; i < POINTS_NUMBER; i++) {
            vertices.push([-1, -1, 0]);
            vertices.push([1, -1, 0]);
            vertices.push([1, -1, 0]);
            vertices.push([1, 1, 0]);
            vertices.push([1, 1, 0]);
            vertices.push([-1, 1, 0]);
            vertices.push([-1, 1, 0]);
            vertices.push([-1, -1, 0]);

            vertexIDs[i * 8] = i;
            vertexIDs[i * 8 + 1] = i;
            vertexIDs[i * 8 + 2] = i;
            vertexIDs[i * 8 + 3] = i;
            vertexIDs[i * 8 + 4] = i;
            vertexIDs[i * 8 + 5] = i;
            vertexIDs[i * 8 + 6] = i;
            vertexIDs[i * 8 + 7] = i;

            vertexNormals.push([0, -1, 0]);
            vertexNormals.push([0, -1, 0]);
            vertexNormals.push([1, 0, 0]);
            vertexNormals.push([1, 0, 0]);
            vertexNormals.push([0, 1, 0]);
            vertexNormals.push([0, 1, 0]);
            vertexNormals.push([-1, 0, 0]);
            vertexNormals.push([-1, 0, 0]);

            if (!i) {
              continue;
            }

            var _index = vertices.length - 16;

            indexesArray.push([_index + 0, _index + 1, _index + 9]);
            indexesArray.push([_index + 9, _index + 8, _index + 0]);

            indexesArray.push([_index + 11, _index + 10, _index + 2]);
            indexesArray.push([_index + 2, _index + 3, _index + 11]);

            indexesArray.push([_index + 13, _index + 12, _index + 4]);
            indexesArray.push([_index + 4, _index + 5, _index + 13]);

            indexesArray.push([_index + 7, _index + 15, _index + 14]);
            indexesArray.push([_index + 14, _index + 6, _index + 7]);
          }

          // Head

          var index = vertices.length;

          vertices.push([-1, -1, 0]);
          vertices.push([1, -1, 0]);
          vertices.push([1, 1, 0]);
          vertices.push([-1, 1, 0]);

          vertexNormals.push([0, 0, 1]);
          vertexNormals.push([0, 0, 1]);
          vertexNormals.push([0, 0, 1]);
          vertexNormals.push([0, 0, 1]);

          vertexIDs[index] = 0;
          vertexIDs[index + 1] = 0;
          vertexIDs[index + 2] = 0;
          vertexIDs[index + 3] = 0;

          indexesArray.push([index + 2, index + 1, index + 0]);
          indexesArray.push([index + 0, index + 3, index + 2]);

          // Tail

          index = vertices.length;

          vertices.push([-1, -1, 0]);
          vertices.push([1, -1, 0]);
          vertices.push([1, 1, 0]);
          vertices.push([-1, 1, 0]);

          vertexNormals.push([0, 0, -1]);
          vertexNormals.push([0, 0, -1]);
          vertexNormals.push([0, 0, -1]);
          vertexNormals.push([0, 0, -1]);

          vertexIDs[index] = POINTS_NUMBER - 1;
          vertexIDs[index + 1] = POINTS_NUMBER - 1;
          vertexIDs[index + 2] = POINTS_NUMBER - 1;
          vertexIDs[index + 3] = POINTS_NUMBER - 1;

          indexesArray.push([index + 0, index + 1, index + 2]);
          indexesArray.push([index + 2, index + 3, index + 0]);

          var positions = new Float32Array(vertices.length * 3);
          for (var i = 0; i < vertices.length; i++) {
            positions[i * 3 + 0] = vertices[i][0];
            positions[i * 3 + 1] = vertices[i][1];
            positions[i * 3 + 2] = vertices[i][2];
          }
          geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3));

          var normals = new Float32Array(vertexNormals.length * 3);
          for (var i = 0; i < vertexNormals.length; i++) {
            normals[i * 3 + 0] = vertexNormals[i][0];
            normals[i * 3 + 1] = vertexNormals[i][1];
            normals[i * 3 + 2] = vertexNormals[i][2];
          }
          geometry.addAttribute("normal", new THREE.BufferAttribute(normals, 3));

          var indexes = new Float32Array(indexesArray.length * 3);
          for (var i = 0; i < indexesArray.length; i++) {
            indexes[i * 3 + 0] = indexesArray[i][0];
            indexes[i * 3 + 1] = indexesArray[i][1];
            indexes[i * 3 + 2] = indexesArray[i][2];
          }
          geometry.addAttribute("id", new THREE.BufferAttribute(vertexIDs, 1));

          geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indexes), 1));

          var uniforms = THREE.UniformsUtils.clone(THREE.ShaderLib.phong.uniforms);
          _Object$assign(uniforms, {
            offsetID: {
              type: "f",
              value: 0
            },
            color: {
              type: "c",
              value: new THREE.Color(color)
            },
            tipColor: {
              type: "c",
              value: new THREE.Color(tipColor)
            },
            scale: {
              type: "f",
              value: 1
            },
            emissiveIntensity: {
              type: "f",
              value: 0
            },
            data: {
              type: "t",
              value: TEXTURE
            },
            dataOffset: {
              type: "f",
              value: DATA_OFFSET
            }
          });

          var material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: ShaderUtils.replaceThreeChunks(VERTEX_SHADER),
            fragmentShader: ShaderUtils.replaceThreeChunks(FRAGMENT_SHADER)
          });

          this.mesh = new THREE.Mesh(geometry, material);
          this.mesh.material.lights = true;
          this.mesh.material.transparent = true;

          this.add(this.mesh);

          DATA_OFFSET += POINTS_NUMBER;
        }

        _createClass(Line, [{
          key: "update",
          value: function update(position) {

            var dataOffset = this.mesh.material.uniforms.dataOffset.value * 8;

            this._direction.copy(position).sub(this._previousPosition).normalize();

            if (this._time === 0) {
              for (var i = 0; i < POINTS_NUMBER * 8; i += 8) {
                TEXTURE.image.data[i + dataOffset] = position.x;
                TEXTURE.image.data[i + 1 + dataOffset] = position.y;
                TEXTURE.image.data[i + 2 + dataOffset] = position.z;
              }
              this._normal.crossVectors(this._direction, new THREE.Vector3(1, 0, 0)).normalize();
            } else {
              this._normal.crossVectors(this._previousBinormal, this._direction).normalize();
            }

            this._binormal.crossVectors(this._direction, this._normal).normalize();
            var angle = this._normal.angleTo(this._binormal);

            this._matrix4Cached1.set(this._normal.x, this._binormal.x, this._direction.x, 0, this._normal.y, this._binormal.y, this._direction.y, 0, this._normal.z, this._binormal.z, this._direction.z, 0, 0, 0, 0, 1);

            this._eulerCached1.setFromRotationMatrix(this._matrix4Cached1);

            this._time += .1;

            var positionDifference = this._vector3Cached1.copy(position).sub(this._previousPosition);

            for (var i = 0; i < POINTS_NUMBER * 8; i += 8) {
              var offset = dataOffset + i;
              TEXTURE.image.data[offset] = TEXTURE.image.data[offset] - positionDifference.x;
              TEXTURE.image.data[offset + 1] = TEXTURE.image.data[offset + 1] - positionDifference.y;
              TEXTURE.image.data[offset + 2] = TEXTURE.image.data[offset + 2] - positionDifference.z;
            }

            TEXTURE.image.data[this._bufferOffset + dataOffset] = 0;
            TEXTURE.image.data[this._bufferOffset + 1 + dataOffset] = 0;
            TEXTURE.image.data[this._bufferOffset + 2 + dataOffset] = 0;
            TEXTURE.image.data[this._bufferOffset + 3 + dataOffset] = this.radius;

            TEXTURE.image.data[this._bufferOffset + 4 + dataOffset] = this._eulerCached1.x;
            TEXTURE.image.data[this._bufferOffset + 5 + dataOffset] = this._eulerCached1.y;
            TEXTURE.image.data[this._bufferOffset + 6 + dataOffset] = this._eulerCached1.z;

            this.mesh.material.uniforms.offsetID.value += 1;
            this.mesh.material.uniforms.offsetID.value %= POINTS_NUMBER;

            this._bufferOffset += 8;
            this._bufferOffset %= POINTS_NUMBER * 8;

            TEXTURE.needsUpdate = true;

            this._previousBinormal.copy(this._binormal);
            this._previousPosition.copy(position);

            this.tip.rotation.copy(this._eulerCached1);
            this.position.copy(position);
          }
        }]);

        return Line;
      })(THREE.Object3D);

      _export("default", Line);
    }
  };
});
$__System.register("fa", ["f4", "f5", "f6", "f7", "fb", "ef"], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, _getIterator, THREE, CrossTip;

  return {
    setters: [function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }],
    execute: function () {
      "use strict";

      CrossTip = (function (_THREE$Object3D) {
        _inherits(CrossTip, _THREE$Object3D);

        function CrossTip() {
          _classCallCheck(this, CrossTip);

          _get(Object.getPrototypeOf(CrossTip.prototype), "constructor", this).call(this);

          var geometry = new THREE.BoxGeometry(0.1, 4, 0.1);
          geometry.translate(0, 4, 0);

          this.material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true
          });

          this.parts = [];

          for (var i = 0; i < 4; i++) {
            var partContainer = new THREE.Object3D();
            var part = new THREE.Mesh(geometry, this.material);
            this.parts.push(part);
            partContainer.rotation.z = Math.PI * i * .5;
            partContainer.add(part);
            this.add(partContainer);
          }
        }

        _createClass(CrossTip, [{
          key: "show",
          value: function show(duration, easing) {
            if (duration === undefined) duration = 0;

            TweenMax.to(this.material, duration, {
              opacity: 1,
              ease: easing
            });
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _getIterator(this.parts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var part = _step.value;

                TweenMax.to(part.rotation, duration, {
                  x: 0,
                  ease: easing
                });
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }, {
          key: "hide",
          value: function hide(duration, easing) {
            if (duration === undefined) duration = 0;

            TweenMax.to(this.material, duration, {
              opacity: 0,
              ease: easing
            });
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(this.parts), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var part = _step2.value;

                TweenMax.to(part.rotation, duration, {
                  x: -Math.PI * .5,
                  ease: easing
                });
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }]);

        return CrossTip;
      })(THREE.Object3D);

      _export("default", CrossTip);
    }
  };
});
$__System.register("fc", ["f4", "f5", "f6", "f7", "fd", "fb", "ef", "f3", "fa", "fe"], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, _slicedToArray, _getIterator, THREE, Line, CrossTip, App, Lines;

  return {
    setters: [function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fd) {
      _slicedToArray = _fd["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_f3) {
      Line = _f3["default"];
    }, function (_fa) {
      CrossTip = _fa["default"];
    }, function (_fe) {
      App = _fe["default"];
    }],
    execute: function () {
      "use strict";

      Lines = (function (_THREE$Object3D) {
        _inherits(Lines, _THREE$Object3D);

        function Lines(character) {
          _classCallCheck(this, Lines);

          _get(Object.getPrototypeOf(Lines.prototype), "constructor", this).call(this);

          this.character = character;

          this._previousCharacterPosition = this.character.clone();

          this._vector3Cached1 = new THREE.Vector3();
          this._vector3Cached2 = new THREE.Vector3();
          this._vector3Cached3 = new THREE.Vector3();
          this._cachedQuaternion = new THREE.Quaternion();

          this.lines = [];
          this.particles = [];
          this.offsets = [];

          for (var i = 0; i < 8; i++) {
            var particle = new THREE.Vector3();
            particle.copy(this.character);
            this.particles.push(particle);
            var line = new Line();
            line.radius = 0;
            line.mesh.frustumCulled = false;
            this.lines.push(line);
            this.add(line);
            this.offsets.push(new THREE.Vector3());
            var crossTip = new CrossTip();
            crossTip.hide();
            line._crossTip = crossTip;
            line.tip.add(crossTip);
          }

          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(Lines, [{
          key: "onSceneChange",
          value: function onSceneChange(name, data) {
            var tmpColor = new THREE.Color();
            var tmpTipColor = new THREE.Color();

            var duration = data.transitionDuration || .7;
            var easing = Power2.easeInOut;

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _getIterator(this.lines.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2);

                var i = _step$value[0];
                var line = _step$value[1];

                if (i === 0) {
                  continue;
                }
                var lineData = data.lines[i - 1] || {};

                tmpColor.set(lineData ? lineData.color : 0x000000);
                tmpTipColor.set(lineData ? lineData.tipColor : 0x000000);

                if (lineData.crossTip) {
                  line._crossTip.show(duration, easing);
                  TweenMax.to(line._crossTip.material.color, duration, {
                    r: tmpTipColor.r,
                    g: tmpTipColor.g,
                    b: tmpTipColor.b,
                    ease: easing
                  });
                } else {
                  line._crossTip.hide(duration, easing);
                }

                TweenMax.to(line.mesh.material.uniforms.specular.value, duration, {
                  r: lineData.shading ? .6 : 0,
                  g: lineData.shading ? .6 : 0,
                  b: lineData.shading ? .6 : 0,
                  ease: easing
                });
                TweenMax.to(line.mesh.material.uniforms.emissiveIntensity, duration, {
                  value: lineData.shading ? 0 : 1,
                  ease: easing
                });
                TweenMax.to(line.mesh.material.uniforms.color.value, duration, {
                  r: tmpColor.r,
                  g: tmpColor.g,
                  b: tmpColor.b,
                  ease: easing
                });
                TweenMax.to(line.mesh.material.uniforms.tipColor.value, duration, {
                  r: tmpTipColor.r,
                  g: tmpTipColor.g,
                  b: tmpTipColor.b,
                  ease: easing
                });

                TweenMax.to(this.offsets[i], duration, {
                  x: lineData.offset ? lineData.offset[0] : 0,
                  y: lineData.offset ? lineData.offset[1] : 0,
                  z: lineData.offset ? lineData.offset[2] : 0,
                  ease: easing
                });
                TweenMax.to(line, duration, {
                  radius: lineData.radius || 0,
                  ease: easing
                });
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }, {
          key: "resize",
          value: function resize(width, height) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(this.lines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var line = _step2.value;

                line.resize(width, height);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }, {
          key: "update",
          value: function update(timeScale) {
            var mainLine = this.lines[0];

            var characterOffset = this._vector3Cached1.subVectors(this.character, this._previousCharacterPosition);

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = _getIterator(this.lines.entries()), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _step3$value = _slicedToArray(_step3.value, 2);

                var i = _step3$value[0];
                var line = _step3$value[1];

                var particle = this.particles[i];

                this._vector3Cached3.copy(this.character);
                this._vector3Cached2.copy(this.offsets[i]);
                this._cachedQuaternion.slerp(mainLine.tip.quaternion, .1 * timeScale);
                this._vector3Cached2.applyQuaternion(this._cachedQuaternion);
                this._vector3Cached3.add(this._vector3Cached2);

                particle.lerp(this._vector3Cached3, .1 * timeScale);

                line.update(particle);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"]) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            this._previousCharacterPosition.copy(this.character);
          }
        }]);

        return Lines;
      })(THREE.Object3D);

      _export("default", Lines);
    }
  };
});
$__System.register("ff", ["f4", "f5", "f7", "ef"], function (_export) {
  var _get, _inherits, _classCallCheck, THREE, VERTEX_SHADER, NOISE_FRAGMENT_SHADER, FRAGMENT_SHADER, BackgroundPlane;

  return {
    setters: [function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }],
    execute: function () {
      "use strict";

      VERTEX_SHADER = "\n  varying vec2 vUv;\n\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
      NOISE_FRAGMENT_SHADER = "\n\tuniform vec3 color;\n\tuniform float opacity;\n\n\tvarying vec2 vUv;\n\n\tvoid main() {\n\t\tfloat strength = 9.0;\n\n    float x = (vUv.x + 4.0) * (vUv.y + 4.0) * 10.0;\n\n\t\t//vec4 grain = vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005) * strength;\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t\tfloat fade = smoothstep(0.1, 50.0, depth);\n\n\t\tgl_FragColor = vec4(color /*+ grain.xyz*/, vUv.x * fade * opacity);\n\t}";
      FRAGMENT_SHADER = "\n  uniform vec3 color;\n  uniform float opacity;\n\n  varying vec2 vUv;\n\n  void main() {\n    float strength = 9.0;\n\n    float x = (vUv.x + 4.0) * (vUv.y + 4.0) * 10.0;\n\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    float fade = smoothstep(0.1, 50.0, depth);\n\n    gl_FragColor = vec4(color, vUv.x * fade * opacity);\n  }";

      BackgroundPlane = (function (_THREE$Object3D) {
        _inherits(BackgroundPlane, _THREE$Object3D);

        function BackgroundPlane() {
          var useNoise = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

          _classCallCheck(this, BackgroundPlane);

          _get(Object.getPrototypeOf(BackgroundPlane.prototype), "constructor", this).call(this);

          this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.ShaderMaterial({
            uniforms: {
              color: {
                type: "c",
                value: new THREE.Color(0)
              },
              opacity: {
                type: "f",
                value: 1
              }
            },
            vertexShader: VERTEX_SHADER,
            fragmentShader: useNoise ? NOISE_FRAGMENT_SHADER : FRAGMENT_SHADER,
            depthTest: false,
            depthWrite: false,
            side: THREE.DoubleSide,
            transparent: true
          }));

          this.mesh.frustumCulled = false;

          this.add(this.mesh);
        }

        return BackgroundPlane;
      })(THREE.Object3D);

      _export("default", BackgroundPlane);
    }
  };
});
$__System.register("100", [], function (_export) {
    /*
        Some Math functions
    */

    "use strict";

    var PI2, HALF_PI, DEG2RAD, RAD2DEG, EPS, mix, map, normalize, clamp, bitValue, random, max, min;
    return {
        setters: [],
        execute: function () {
            PI2 = 2.0 * Math.PI;
            HALF_PI = Math.PI * 0.5;
            DEG2RAD = Math.PI / 180.0;
            RAD2DEG = 180.0 / Math.PI;
            EPS = 10e-6;

            _export("PI2", PI2);

            _export("HALF_PI", HALF_PI);

            _export("DEG2RAD", DEG2RAD);

            _export("RAD2DEG", RAD2DEG);

            _export("EPS", EPS);

            // Lineary interpolates between a->b, using n as a weightath

            mix = function mix(n, a, b) {
                return a * (1 - n) + b * n;
            };

            _export("mix", mix);

            // Linearly maps n from a->b to x->y

            map = function map(n, a, b, x, y) {
                return x + (n - a) * (y - x) / (b - a);
            };

            _export("map", map);

            // Linearly maps n from a->b to 0-1

            normalize = function normalize(n, a, b) {
                return map(n, a, b, 0, 1);
            };

            _export("normalize", normalize);

            // Clamp n within range a->b

            clamp = function clamp(n, a, b) {
                return n < a ? a : n > b ? b : n;
            };

            _export("clamp", clamp);

            //Returns the value of bit in position `i` in `n`

            bitValue = function bitValue(n, i) {
                return n & 1 << i;
            };

            _export("bitValue", bitValue);

            /*
             * Returns a pseudo-random floating point number within the range a->b, if b is not supplied it
             * returns within the range 0-a
             */

            random = function random(a, b) {
                a = a === undefined ? 1 : a;
                return b === undefined ? Math.random() * a : Math.random() * (b - a) + a;
            };

            _export("random", random);

            /*
             * Included for completeness. This allows functional style reductions such as `numbers.reduce( max )`. 
             * `Math.max.apply( this, []] )` alone is bound by the stack size
             */

            max = function max(a, b) {
                return Math.max(a, b);
            };

            _export("max", max);

            min = function min(a, b) {
                return Math.min(a, b);
            };

            _export("min", min);
        }
    };
});
$__System.register("101", ["100", "102", "103", "f4", "f5", "f6", "f7", "fd", "fb", "ef", "ff", "fe"], function (_export) {
  var random, DATA, spring3, _get, _inherits, _createClass, _classCallCheck, _slicedToArray, _getIterator, THREE, BackgroundPlane, App, BIG_PLANES_NUMBER, NORMAL_PLANES_NUMBER, SMALL_PLANES_NUMBER, Background;

  return {
    setters: [function (_3) {
      random = _3.random;
    }, function (_) {
      DATA = _["default"];
    }, function (_2) {
      spring3 = _2.spring3;
    }, function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fd) {
      _slicedToArray = _fd["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_ff) {
      BackgroundPlane = _ff["default"];
    }, function (_fe) {
      App = _fe["default"];
    }],
    execute: function () {
      "use strict";

      BIG_PLANES_NUMBER = 5;
      NORMAL_PLANES_NUMBER = 20;
      SMALL_PLANES_NUMBER = 100;

      Background = (function (_THREE$Object3D) {
        _inherits(Background, _THREE$Object3D);

        function Background(character) {
          var useNoise = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

          _classCallCheck(this, Background);

          _get(Object.getPrototypeOf(Background.prototype), "constructor", this).call(this);

          this.character = character;

          this.backgroundPlanes = [];

          this._lastSceneChangeTimeStamp = Date.now();

          for (var i = 0; i < BIG_PLANES_NUMBER + NORMAL_PLANES_NUMBER + SMALL_PLANES_NUMBER; i++) {
            var backgroundPlane = new BackgroundPlane(useNoise);
            backgroundPlane._animationQuaternionStart = new THREE.Quaternion();
            backgroundPlane._animationQuaternionEnd = new THREE.Quaternion();
            backgroundPlane._animationProgress = 0;
            backgroundPlane._type = i < BIG_PLANES_NUMBER ? "big" : i < BIG_PLANES_NUMBER + NORMAL_PLANES_NUMBER ? "normal" : "small";
            var distance = undefined;
            var scale = undefined;
            switch (backgroundPlane._type) {
              case "big":
                scale = 10000;
                break;
              case "normal":
                scale = 1000;
                break;
              case "small":
                scale = 10;
                break;
            }
            backgroundPlane._scale = scale;
            backgroundPlane.mesh.scale.set(scale, scale, 1);
            if (backgroundPlane._type === "normal") {
              backgroundPlane.rotation.set(Math.PI * .5 * Math.floor(Math.random() * 2), Math.PI * .5 * Math.floor(Math.random() * 2), Math.PI * .5 * Math.floor(Math.random() * 2));
            } else {
              backgroundPlane.rotation.set(Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random(), Math.PI * 2 * Math.random());
            }
            backgroundPlane.position.set(Math.random() * 2000 - 1000, Math.random() * 2000 - 1000, Math.random() * 2000 - 1000);
            this.add(backgroundPlane);
            this.backgroundPlanes.push(backgroundPlane);
          }

          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(Background, [{
          key: "onSceneChange",
          value: function onSceneChange(name, _ref) {
            var background = _ref.background;
            var transitionDuration = _ref.transitionDuration;

            var euler = new THREE.Euler();
            var color = new THREE.Color();
            var vector3 = new THREE.Vector3();
            var position = new THREE.Vector3();
            var scale = new THREE.Vector3();

            var easing = Power3.easeInOut;

            var smallPlanesCounter = 0;

            if (!transitionDuration) {
              transitionDuration = (Date.now() - this._lastSceneChangeTimeStamp) / 1000;
              transitionDuration = Math.max(Math.min(transitionDuration, 1.3), .2);
            }

            this._lastSceneChangeTimeStamp = Date.now();

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _getIterator(this.backgroundPlanes.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2);

                var i = _step$value[0];
                var backgroundPlane = _step$value[1];

                scale.set(backgroundPlane._scale, backgroundPlane._scale, 1);

                var distance = undefined;
                var opacity = 1;
                var delay = Math.random() * transitionDuration;
                var duration = transitionDuration * (1 + (Math.random() * 2 - 1) * .2);

                switch (backgroundPlane._type) {
                  case "big":
                    distance = 5000;
                    color.set(background.assets[i % background.assets.length]);
                    break;
                  case "normal":
                    if (background.detail.numberRatio === 0) {
                      color.set(background.detail.colors[i % background.detail.colors.length]);
                    } else {
                      color.set(background.assets[i % background.assets.length]);
                    }
                    distance = 1000;
                    scale.x *= .2 + Math.random() * .8;
                    scale.y *= Math.random();
                    break;
                  case "small":
                    opacity = smallPlanesCounter / (SMALL_PLANES_NUMBER - 1) < background.detail.numberRatio ? 1 : 0;
                    opacity *= background.detail.opacities[i % background.detail.opacities.length];
                    color.set(background.detail.colors[i % background.detail.colors.length]);
                    distance = Math.random() * 2000;
                    scale.x *= background.detail.scale[0];
                    scale.y *= background.detail.scale[1];
                    smallPlanesCounter++;
                    break;
                }

                euler.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);

                position.set(0, 0, 1);
                position.applyEuler(euler);
                position.multiplyScalar(distance);
                position.add(this.character);

                TweenMax.killTweensOf(backgroundPlane.position);
                TweenMax.to(backgroundPlane.position, duration, {
                  x: position.x,
                  y: position.y,
                  z: position.z,
                  delay: delay,
                  ease: easing
                });

                TweenMax.killTweensOf(backgroundPlane.mesh.scale);
                TweenMax.to(backgroundPlane.mesh.scale, duration, {
                  x: scale.x,
                  y: scale.y,
                  delay: delay,
                  ease: easing
                });

                TweenMax.killTweensOf(backgroundPlane.mesh.material.uniforms.color.value);
                TweenMax.to(backgroundPlane.mesh.material.uniforms.color.value, duration, {
                  r: color.r,
                  g: color.g,
                  b: color.b,
                  delay: delay,
                  ease: easing
                });

                TweenMax.killTweensOf(backgroundPlane.mesh.material.uniforms.opacity);
                TweenMax.to(backgroundPlane.mesh.material.uniforms.opacity, duration * .5, {
                  value: 0,
                  delay: delay,
                  ease: easing
                });
                TweenMax.to(backgroundPlane.mesh.material.uniforms.opacity, duration * .5, {
                  delay: delay + duration * .5,
                  value: opacity,
                  ease: easing
                });
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }]);

        return Background;
      })(THREE.Object3D);

      _export("default", Background);
    }
  };
});
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("104", [], function() {
  return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<COLLADA xmlns=\"http://www.collada.org/2008/03/COLLADASchema\" version=\"1.5.0\">\n\t<asset>\n\t\t<contributor>\n\t\t\t<authoring_tool>CINEMA4D 16.011 COLLADA Exporter</authoring_tool>\n\t\t</contributor>\n\t\t<created>2016-02-11T15:06:47Z</created>\n\t\t<modified>2016-02-11T15:06:47Z</modified>\n\t\t<unit meter=\"0.01\" name=\"centimeter\"/>\n\t\t<up_axis>Y_UP</up_axis>\n\t</asset>\n\t<library_effects>\n\t\t<effect id=\"ID2\">\n\t\t\t<profile_COMMON>\n\t\t\t\t<technique sid=\"COMMON\">\n\t\t\t\t\t<blinn>\n\t\t\t\t\t\t<specular>\n\t\t\t\t\t\t\t<color>0.2 0.2 0.2 1</color>\n\t\t\t\t\t\t</specular>\n\t\t\t\t\t\t<shininess>\n\t\t\t\t\t\t\t<float>0.5</float>\n\t\t\t\t\t\t</shininess>\n\t\t\t\t\t\t<reflective>\n\t\t\t\t\t\t\t<color>1 1 1 1</color>\n\t\t\t\t\t\t</reflective>\n\t\t\t\t\t\t<reflectivity>\n\t\t\t\t\t\t\t<float>0</float>\n\t\t\t\t\t\t</reflectivity>\n\t\t\t\t\t</blinn>\n\t\t\t\t</technique>\n\t\t\t</profile_COMMON>\n\t\t</effect>\n\t</library_effects>\n\t<library_materials>\n\t\t<material id=\"ID1\" name=\"Mat\">\n\t\t\t<instance_effect url=\"#ID2\"/>\n\t\t</material>\n\t</library_materials>\n\t<library_geometries>\n\t\t<geometry id=\"ID5\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID6\">\n\t\t\t\t\t<float_array id=\"ID7\" count=\"165\" digits=\"2490374\">-57.2003 1238.99 70.7211 -18.5994 1271.06 71.1583 -17.2009 1279.71 58.0241 -15.5548 1282.97 58.3701 0.840649 1292.86 67.2573 22.3833 1296.94 71.7315 59.1234 1295.99 71.7132 77.4214 1291.65 62.9636 89.7288 1281.65 58.157 90.6038 1279.41 58.8596 92.5148 1261.86 76.3188 93.0103 1237.29 74.712 88.2936 1245.1 83.8903 79.9599 1245.63 94.1149 74.1994 1242.6 97.5794 54.6789 1273.36 95.2697 6.12367 1263.77 95.7317 -1.13965 1241.2 97.7002 -9.05632 1247.77 91.8304 -18.5209 1232.32 79.6673 3.90784 1185.25 58.6414 86.3702 1176.75 46.9884 149.443 1179.81 25.9652 163.805 1364.05 208.545 396.914 1173.82 114.54 179.291 1370.19 25.9652 298.523 1248.77 -94.8204 145.367 1111.95 25.9652 169.172 995.736 -33.5095 142.599 923.156 94.5536 95.364 1064.38 -66.9129 99.8149 1045.59 25.9652 32.6161 1110.68 81.5731 58.9288 1030.56 -40.0249 11.8393 1006.94 74.5714 -48.0293 1063.2 -26.8464 -10.7508 1138.92 -156.775 -150.044 1148.3 120.135 -142.98 1022.19 -13.8455 -283.103 1138.25 91.9389 -167.922 1131.73 25.9652 -199.801 1167.02 -7.7258 -153.451 1257.6 55.4566 -104.457 1355.03 25.9652 -52.1545 1251.15 -18.336 22.699 1338.34 58.1114 96.4728 1379.54 25.9652 167.523 1417.68 -88.8227 899.235 1569.88 -233.953 226.467 1380.87 -243.114 149.02 1342.02 -107.934 186.208 1291.81 -64.2784 304.838 1341.62 -127.946 288.482 1440.87 145.672 72.315 1532.33 25.9659</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"55\" source=\"#ID7\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID8\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID6\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID8\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID10\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID11\">\n\t\t\t\t\t<float_array id=\"ID12\" count=\"123\" digits=\"2490374\">873.552 7.99416 540.561 898.029 -0.693561 520.501 841.479 -5.59414 500.44 849.735 18.298 480.379 939.722 4.44011 460.318 848.87 -20.1572 440.257 796.476 19.9751 420.197 961.167 20.7797 400.136 899.217 -31.8794 380.075 740.067 7.94844 360.014 938.009 42.156 339.953 979.861 -31.7551 319.893 713.66 -16.8189 299.832 863.166 58.5367 279.771 1060.33 203.727 436.286 743.738 -46.9997 239.65 752.148 59.8225 219.589 1060.03 18.2834 120.007 838.024 -71.0431 179.467 640.075 40.023 159.406 1076.39 58.4778 139.346 440.298 -77.1609 119.285 570.884 0.316289 99.2241 970.478 92.7325 79.1633 1128.15 160.45 235.679 581.98 -50.204 39.0417 802.101 107.084 18.9809 1233.53 204.845 175.496 689.355 -96.5656 -73.8629 614.309 91.8444 -41.2014 1249.72 46.7281 -61.2622 878.421 -206.431 95.2531 465.173 45.7003 -101.384 1152.82 106.274 -121.445 1104.26 -4.26458 260.31 410.226 -22.5437 -161.566 952.317 146.052 -181.627 1302.18 -70.5739 -201.688 483.584 -95.4071 -221.748 692.709 150.216 -241.809 1406.11 -80.975 -85.2946</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"41\" source=\"#ID12\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID13\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID11\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID13\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID15\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID16\">\n\t\t\t\t\t<float_array id=\"ID17\" count=\"123\" digits=\"2490374\">256.882 -108.653 1876.09 -30.1044 200.951 1666.49 -114.231 -127.979 1693.35 215.071 -94.7234 1720.22 74.3298 195.375 1747.08 -143.741 -30.4029 1773.95 135.453 -5.92407 2338.91 154.989 142.105 1827.68 -121.637 60.9873 1854.54 44.603 -276.66 2117.87 193.966 62.3637 1908.27 -61.6429 122.782 1935.14 -31.4538 -129.531 1962 187.457 274.108 2225.33 13.9011 143.191 2015.73 -74.6485 -67.4446 2042.6 145.063 214.656 2305.93 81.6354 123.971 2096.32 -79.1121 0.210487 2123.19 -288.408 -103.544 2150.05 124.241 78.0985 2176.92 -51.2782 53.3845 2203.78 28.3521 -95.3517 2230.65 134.866 24.2714 2257.51 -6.19361 79.8993 2284.38 -9.57687 -63.1536 2311.24 117.782 272.612 2574.57 38.4663 78.1775 2364.97 -21.6764 -22.7364 2391.84 85.4102 -42.7385 2418.7 68.5739 56.2409 2445.57 -11.0534 10.4312 2472.43 52.9688 -42.905 2499.3 77.8898 27.6144 2526.16 11.6385 26.5369 2553.03 32.7152 -27.2069 2579.89 69.263 5.73297 2606.76 33.0634 24.291 2633.62 29.7422 -7.70457 2660.48 52.4911 -1.14187 2687.35 42.6445 10.4924 2714.21</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"41\" source=\"#ID17\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID18\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID16\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID18\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID20\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID21\">\n\t\t\t\t\t<float_array id=\"ID22\" count=\"87\" digits=\"2490374\">44.5674 95.2227 60.6122 -5.04816 97.4526 60.6122 -25.1174 89.0905 60.6122 -57.4511 65.6764 60.6122 -68.0432 14.3884 60.6122 -29.5772 -50.279 60.6122 86.3782 -73.6931 60.6122 123.729 22.1931 60.6122 100.315 62.889 60.6122 65.1941 88.533 60.6122 68.535 104.029 13.2488 102.268 83.9603 -2.80413 146.309 -21.4031 -2.80413 124.01 -44.2597 -2.80413 34.2559 -47.6045 -2.80413 -15.3597 -17.5007 -2.80413 -49.3658 37.6896 -2.80413 -42.6761 88.9776 -2.80413 1.36468 122.426 -2.80413 49.8653 115.737 -2.80413 76.0667 -1.8781 32.512 31.4685 -18.045 32.512 8.6119 37.1454 32.512 55.44 39.9327 32.512 69.9345 10.9439 32.512 62.1298 -2.99306 32.512 38.1582 -5.22297 32.512 31.4685 9.27146 32.512 46.5204 36.5746 -56.0635</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"29\" source=\"#ID22\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID23\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID21\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID23\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID25\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID26\">\n\t\t\t\t\t<float_array id=\"ID27\" count=\"75\" digits=\"2490374\">131.375 -7.20732 -284.916 -62.0938 -10.5338 9.9476e-014 -127.514 -119.198 1.13687e-013 108.664 -161.333 7.10543e-015 171.867 -83.7158 4.9738e-014 -1.10882 0.554409 5.68434e-014 -66.5291 -46.016 -4.9738e-014 -86.4879 -93.6952 -42.7183 -90.9231 -134.721 -47.8513 -76.5085 -110.327 -42.7183 -14.4146 -85.9335 21.7154 92.032 -118.089 -6.39488e-014 127.514 -143.592 62.1291 130.841 -145.81 62.1291 113.1 -62.6483 1.77636e-015 15.5235 -43.7983 112.516 -3.32646 -130.286 9.59233e-014 16.6323 -131.395 -1.22569e-013 27.7205 -97.0216 -24.4747 33.2646 -65.9747 -24.4747 -13.3058 -49.3424 -24.4747 -73.182 -229.965 -31.0586 -148.582 -334.309 1.49214e-013 -218.437 -403.056 -1.56319e-013 -204.023 -307.697 -1.77636e-013</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"25\" source=\"#ID27\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID28\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID26\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID28\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID30\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID31\">\n\t\t\t\t\t<float_array id=\"ID32\" count=\"93\" digits=\"2490374\">-312.849 -11.9601 566.58 -355.837 -111.057 -114.217 212.937 171.579 -75.8547 -159.639 87.9618 20.6295 52.8845 270.063 0.869998 -91.9866 -6.37755 115.343 200.232 257.336 -4.6261 106.006 -237.166 115.957 -250.832 150.921 154.319 191.458 -101.433 252.305 -289.015 0.811072 231.044 181.905 47.6529 269.407 204.593 -132.96 307.769 -53.6158 -99.6055 197.3 -123.772 -204.184 207.652 490.096 185.941 93.2061 -2.0743 -196.366 461.218 -137.922 142.756 263.392 83.0977 -125.181 537.943 81.655 53.1975 311.7 -119.507 -261.726 246.128 -186.237 -138.225 431.082 72.1121 54.2131 363.428 -130.891 -104.038 557.801 4.31725 93.538 407.559 149.669 -118.533 557.357 -62.7499 246.749 320.076 76.1747 197.727 36.0199 114.979 170.129 -114.635 300.304 50.0481 -76.273 389.877 91.684 -37.9108</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"31\" source=\"#ID32\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID33\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID31\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID33\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID35\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID36\">\n\t\t\t\t\t<float_array id=\"ID37\" count=\"51\" digits=\"2490374\">-271.07 44.9179 -696.774 -138.208 -13.3342 -955.965 -26.023 45.7641 -876.793 38.4981 154.536 -867.685 -57.278 98.6826 -856.08 -185.616 42.1557 -842.177 -19.3156 0.180319 -839.85 -188.252 116.635 -808.011 -38.0923 -25.3365 -747.487 34.1535 88.5871 -765.991 7.88398 40.6706 -694.495 -108.755 12.6828 -776.432 -50.5101 54.3776 -686.72 -44.8249 -6.94177 -660.427 -2.5341 77.4594 -681.322 -11.6778 40.4622 -597.609 -164.132 24.1371 -672.731</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"17\" source=\"#ID37\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID38\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID36\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID38\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID40\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID41\">\n\t\t\t\t\t<float_array id=\"ID42\" count=\"51\" digits=\"2490374\">-271.07 44.9179 953.248 -138.208 -13.3342 694.057 -26.023 45.7641 773.229 -30.1484 -43.326 782.337 -57.278 98.6826 793.942 -185.616 42.1557 807.845 -123.871 0.180319 823.904 -29.9243 116.635 842.011 -38.0923 -25.3365 862.077 34.1535 88.5871 884.031 7.88398 40.6706 907.811 -108.755 12.6828 933.361 -50.5101 230.296 929.301 -44.8249 -6.94177 989.595 -94.0234 77.4594 1020.2 -11.6778 40.4622 1052.41 -92.9101 24.1371 1086.21</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"17\" source=\"#ID42\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID43\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID41\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID43\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID45\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID46\">\n\t\t\t\t\t<float_array id=\"ID47\" count=\"63\" digits=\"2490374\">236.999 102.394 552.574 152.594 42.8134 483.448 64.5428 63.5294 378.355 48.2708 75.5538 269.554 51.7132 159.684 62.6947 63.6253 141.805 -4.35172 74.6911 93.3824 -28.9354 0 129.885 -104.921 0 84.4429 -136.955 0 50.0866 -6.37196 0 73.9567 8.97313 16.446 96.9848 7.52101 22.0445 122.324 31.1077 12.4505 114.71 97.1546 -0.576216 92.9016 152.73 -14.7411 57.3329 179.048 -17.3844 47.1028 141.111 -14.8882 44.3322 49.254 -29.0955 21.1014 31.9908 -57.5524 0 -175.28 -127.233 0 -246.849</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"21\" source=\"#ID47\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID48\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID46\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID48\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID50\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID51\">\n\t\t\t\t\t<float_array id=\"ID52\" count=\"75\" digits=\"2490374\">-149.69 173.221 57.1351 -88.7764 178.076 35.8047 -98.52 113.057 75.425 -92.5468 28.4837 28.7692 -95.8716 -88.0583 57.4005 -87.4883 -167.53 30.9065 -37.9638 -209.546 30.8335 78.7875 -181.171 27.8666 95.613 -127.389 79.0306 91.8967 -71.1009 29.6569 96.7022 94.1392 41.2182 95.8039 173.52 60.7055 88.739 177.911 35.7971 72.8834 113.192 75.2023 66.9116 28.4837 28.758 70.2522 -88.3663 57.2925 54.1098 -167.227 30.8268 37.9659 -209.479 56.6921 -39.3888 -181.17 37.2051 -57.1822 -127.401 78.7406 -54.2533 -71.1005 29.6479 -44.9673 94.444 41.2101 -7.63988 187.634 -1.14892e-014 -96.3345 330.884 -2.02608e-014 -29.5447 456.881 -2.79759e-014</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"25\" source=\"#ID52\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID53\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID51\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID53\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID55\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID56\">\n\t\t\t\t\t<float_array id=\"ID57\" count=\"66\" digits=\"2490374\">190.599 -158.392 75.3723 93.3479 -75.4988 49.7439 93.6799 -87.4169 70.2795 89.5181 -172.599 55.7099 78.4985 -188.49 38.8958 57.7516 -202.859 50.4613 -39.4853 -186.302 61.0538 -110.808 -176.624 25.0337 -93.5559 -113.626 85.6104 -93.6173 -69.7412 41.471 -102.565 -35.9461 61.7294 -76.0237 -39.0572 106.014 -38.8869 -96.765 111.37 -77.8488 -66.1163 103.892 -33.4902 -56.6762 48.2585 -67.9536 -72.7257 40.3463 -41.3951 -143.467 83.7094 -69.0902 -199.942 73.8148 -69.793 -241.737 39.2468 -10.557 -215.461 61.3832 68.5103 -197.14 3.63298 85.3247 -180.465 2.60598</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"22\" source=\"#ID57\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID58\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID56\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID58\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID60\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID61\">\n\t\t\t\t\t<float_array id=\"ID62\" count=\"69\" digits=\"2490374\">-164.888 114.38 77.1557 -98.3427 169.657 77.9093 -95.9317 184.578 55.2669 -93.094 190.189 55.8634 -64.8295 207.245 71.1843 -27.6916 214.283 78.8974 35.6453 212.634 78.8659 67.1897 205.162 63.7823 88.4067 187.911 55.496 89.9151 184.062 56.7074 93.2096 153.792 86.8055 94.0637 111.435 84.0356 85.9325 124.911 99.8583 71.5659 125.825 117.485 61.6352 120.591 123.457 27.9833 173.623 119.475 -55.722 157.098 120.272 -68.2434 118.183 123.665 -81.8911 129.505 113.546 -98.2074 102.867 92.5782 -59.542 21.734 56.3311 82.6168 7.08074 36.2423 191.349 12.3467 7.97332e-005</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"23\" source=\"#ID62\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID63\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID61\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID63\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t\t<geometry id=\"ID65\">\n\t\t\t<mesh>\n\t\t\t\t<source id=\"ID66\">\n\t\t\t\t\t<float_array id=\"ID67\" count=\"87\" digits=\"2490374\">-51.7381 1075.14 120.188 -24.5241 1076.09 123.464 -11.3776 1077.35 125.423 -7.73982 1078.74 128.271 -8.38939 1077.99 129.499 -19.1736 1069.77 135.451 -36.971 1054.88 137.884 -77.0418 1017.32 134.822 -113.076 981.738 129.466 -119.572 976.401 123.109 -117.406 983.05 111.057 -112.204 998.735 101.252 -98.5823 1043.17 91.8119 -84.0417 1092.49 83.0133 -81.9018 1097.86 82.8085 -70.363 1104.73 87.4877 -62.3767 1107.36 92.1903 -65.6346 1094.32 99.6456 -66.8214 1089.14 102.365 -72.9583 1068.78 103.471 -88.2858 1022.89 106.739 -95.9889 1003.29 110.803 -97.485 996.677 117.007 -95.1888 997.465 122.649 -85.3461 1007.5 125.099 -55.573 1037.19 128.009 -35.5716 1063.7 129.176 -23.8884 1122.67 127.993 -23.6306 1181.83 127.325</float_array>\n\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t<accessor count=\"29\" source=\"#ID67\" stride=\"3\">\n\t\t\t\t\t\t\t<param name=\"X\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Y\" type=\"float\"/>\n\t\t\t\t\t\t\t<param name=\"Z\" type=\"float\"/>\n\t\t\t\t\t\t</accessor>\n\t\t\t\t\t</technique_common>\n\t\t\t\t</source>\n\t\t\t\t<vertices id=\"ID68\">\n\t\t\t\t\t<input semantic=\"POSITION\" source=\"#ID66\"/>\n\t\t\t\t</vertices>\n\t\t\t\t<linestrips count=\"1\" material=\"Material1\">\n\t\t\t\t\t<input offset=\"0\" semantic=\"VERTEX\" source=\"#ID68\" set=\"0\"/>\n\t\t\t\t\t<p>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</p>\n\t\t\t\t</linestrips>\n\t\t\t</mesh>\n\t\t</geometry>\n\t</library_geometries>\n\t<library_visual_scenes>\n\t\t<visual_scene id=\"ID3\">\n\t\t\t<node id=\"ID4\" name=\"default\">\n\t\t\t\t<translate sid=\"translate\">43.6629 5.68434e-014 -332.191</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 -90</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID5\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID9\" name=\"gearshift\">\n\t\t\t\t<translate sid=\"translate\">0 0 -259.51</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID10\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID14\" name=\"suspension\">\n\t\t\t\t<translate sid=\"translate\">0 0 -259.51</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID15\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID19\" name=\"wheel\">\n\t\t\t\t<translate sid=\"translate\">-303.046 2.80874 314.067</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 226.135</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 16.9475</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 -180</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID20\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID24\" name=\"logo\">\n\t\t\t\t<translate sid=\"translate\">-138.173 29.7848 54.4957</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 204.525</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 14.6304</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 -180</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID25\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID29\" name=\"door\">\n\t\t\t\t<translate sid=\"translate\">0 0 0</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID30\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID34\" name=\"roof\">\n\t\t\t\t<translate sid=\"translate\">0 0 0</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID35\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID39\" name=\"headlight-front\">\n\t\t\t\t<translate sid=\"translate\">0 0 97.6228</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID40\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID44\" name=\"mirror\">\n\t\t\t\t<translate sid=\"translate\">-820 0 0</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID45\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID49\" name=\"chassis\">\n\t\t\t\t<translate sid=\"translate\">518.45 0 0</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 -90</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID50\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID54\" name=\"front-bumper\">\n\t\t\t\t<translate sid=\"translate\">-513.05 15.9762 17.0138</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 -90</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID55\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID59\" name=\"rear-bumper\">\n\t\t\t\t<translate sid=\"translate\">43.6629 5.68434e-014 -332.191</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 -90</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID60\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t\t<node id=\"ID64\" name=\"headlight-rear\">\n\t\t\t\t<translate sid=\"translate\">0 7.10543e-015 -96.8348</translate>\n\t\t\t\t<rotate sid=\"rotateY\">0 1 0 0</rotate>\n\t\t\t\t<rotate sid=\"rotateX\">1 0 0 -90</rotate>\n\t\t\t\t<rotate sid=\"rotateZ\">0 0 1 0</rotate>\n\t\t\t\t<scale sid=\"scale\">1 1 1</scale>\n\t\t\t\t<instance_geometry url=\"#ID65\">\n\t\t\t\t\t<bind_material>\n\t\t\t\t\t\t<technique_common>\n\t\t\t\t\t\t\t<instance_material symbol=\"Material1\" target=\"#ID1\">\n\t\t\t\t\t\t\t\t<bind_vertex_input semantic=\"UVSET0\" input_semantic=\"TEXCOORD\" input_set=\"0\"/>\n\t\t\t\t\t\t\t</instance_material>\n\t\t\t\t\t\t</technique_common>\n\t\t\t\t\t</bind_material>\n\t\t\t\t</instance_geometry>\n\t\t\t</node>\n\t\t</visual_scene>\n\t</library_visual_scenes>\n\t<scene>\n\t\t<instance_visual_scene url=\"#ID3\"/>\n\t</scene>\n</COLLADA>\n";
});

_removeDefine();
})();
$__System.register("105", ["104", "106", "f6", "f7", "fb", "ef", "fe"], function (_export) {
  var PATHS_COLLADA, Signal, _createClass, _classCallCheck, _getIterator, THREE, App, SPEED, Path;

  return {
    setters: [function (_2) {
      PATHS_COLLADA = _2["default"];
    }, function (_) {
      Signal = _["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_fe) {
      App = _fe["default"];
    }],
    execute: function () {
      "use strict";

      SPEED = 1.8;

      Path = (function () {
        function Path() {
          _classCallCheck(this, Path);

          var collada = new THREE.ColladaLoader().parse(PATHS_COLLADA);

          var rawPaths = [];
          this.paths = [];
          this.curves = [];

          this.distance = 0;

          this.direction = new THREE.Vector3();
          this.position = new THREE.Vector3();
          this.previousVertex = new THREE.Vector3();
          this.nextVertex = new THREE.Vector3();
          this.currentOffsetMatrix = new THREE.Matrix4();

          this._origin = new THREE.Vector3(0, 0, 0);
          this._up = new THREE.Vector3(0, 1, 0);

          collada.scene.traverse(function (obj) {
            if (obj instanceof THREE.Line || obj instanceof THREE.Mesh) {
              obj.name = obj.parent.name;
              rawPaths.push(obj);
            }
          }, true);

          var material = new THREE.LineBasicMaterial({
            color: 0xff0000
          });

          var i = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(rawPaths), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var rawPath = _step.value;

              var firstVertex = rawPath.geometry.vertices[0];
              var secondVertex = rawPath.geometry.vertices[1];
              var matrix = new THREE.Matrix4();
              rawPath.geometry.translate(-firstVertex.x, -firstVertex.y, -firstVertex.z);
              matrix.lookAt(this._origin, secondVertex, this._up);
              matrix.getInverse(matrix);
              rawPath.geometry.applyMatrix(matrix);
              var curve = new THREE.CatmullRomCurve3(rawPath.geometry.vertices);
              curve.name = rawPath.name;
              this.curves.push(curve);
              var geometry = new THREE.Geometry();
              geometry.vertices = curve.getPoints(200);
              var path = new THREE.Line(geometry, material);
              path.name = rawPath.name;
              this.paths.push(path);
              path.position.x = i;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.currentPath = this.paths[0];

          this.previousDistance = this.nextDistance = 0;
          this.currentEdgeID = -1;

          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(Path, [{
          key: "onSceneChange",
          value: function onSceneChange(name, data) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(this.paths), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var path = _step2.value;

                if (path.name === name) {
                  this.currentPath = path;
                  this._sceneChanged = true;
                  this.update(0);
                  break;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }, {
          key: "update",
          value: function update() {
            var timeScale = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

            this.distance += SPEED * timeScale;

            if (this.distance >= this.nextDistance) {
              this.currentEdgeID++;
              if (this._sceneChanged || this.currentEdgeID >= this.currentPath.geometry.vertices.length - 1) {
                this._sceneChanged = false;
                this.currentEdgeID = 0;
                this.currentOffsetMatrix.makeRotationFromEuler(new THREE.Euler(Math.random() * Math.PI * 4 - Math.PI * 2, Math.random() * Math.PI * 4 - Math.PI * 2, Math.random() * Math.PI * 4 - Math.PI * 2));
                this.currentOffsetMatrix.setPosition(this.nextVertex);
              }
              this.previousVertex.copy(this.currentPath.geometry.vertices[this.currentEdgeID]);
              this.previousVertex.applyMatrix4(this.currentOffsetMatrix);
              this.nextVertex.copy(this.currentPath.geometry.vertices[this.currentEdgeID + 1]);
              this.nextVertex.applyMatrix4(this.currentOffsetMatrix);
              this.previousDistance = this.nextDistance;
              this.nextDistance += this.previousVertex.distanceTo(this.nextVertex);
              this.direction.copy(this.nextVertex).sub(this.previousVertex).normalize();
            }
            this.position.copy(this.previousVertex).lerp(this.nextVertex, (this.distance - this.previousDistance) / (this.nextDistance - this.previousDistance));
          }
        }]);

        return Path;
      })();

      _export("default", Path);
    }
  };
});
$__System.register("f9", ["f6", "f7", "ef"], function (_export) {
  var _createClass, _classCallCheck, THREE, ShaderUtils;

  return {
    setters: [function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }],
    execute: function () {
      "use strict";

      ShaderUtils = (function () {
        function ShaderUtils() {
          _classCallCheck(this, ShaderUtils);
        }

        _createClass(ShaderUtils, null, [{
          key: "replaceThreeChunks",
          value: function replaceThreeChunks(glsl) {
            return glsl.replace(/\/\/\s*THREE\.ShaderChunk\[\s*\"\s*(\w+)\"*\s*\]\s*[,|;]*/g, function (a, b) {
              return THREE.ShaderChunk[b] + '\n';
            });
          }
        }]);

        return ShaderUtils;
      })();

      _export("default", ShaderUtils);
    }
  };
});
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("107", [], function() {
  return "attribute float lengthPosition;\n\nvarying float vLengthPosition;\n\n// THREE.ShaderChunk[ \"common\" ],\n// THREE.ShaderChunk[ \"uv_pars_vertex\" ],\n// THREE.ShaderChunk[ \"uv2_pars_vertex\" ],\n// THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n// THREE.ShaderChunk[ \"color_pars_vertex\" ],\n// THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n// THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n// THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n// THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\n\nvoid main() {\n\n\tvLengthPosition = lengthPosition;\n\n  // THREE.ShaderChunk[ \"uv_vertex\" ],\n  // THREE.ShaderChunk[ \"uv2_vertex\" ],\n  // THREE.ShaderChunk[ \"color_vertex\" ],\n  // THREE.ShaderChunk[ \"skinbase_vertex\" ],\n\n\t#ifdef USE_ENVMAP\n\n  // THREE.ShaderChunk[ \"beginnormal_vertex\" ],\n  // THREE.ShaderChunk[ \"morphnormal_vertex\" ],\n  // THREE.ShaderChunk[ \"skinnormal_vertex\" ],\n  // THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t#endif\n\n  // THREE.ShaderChunk[ \"begin_vertex\" ],\n  // THREE.ShaderChunk[ \"morphtarget_vertex\" ],\n  // THREE.ShaderChunk[ \"skinning_vertex\" ],\n  // THREE.ShaderChunk[ \"project_vertex\" ],\n  // THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\n\n  // THREE.ShaderChunk[ \"worldpos_vertex\" ],\n  // THREE.ShaderChunk[ \"envmap_vertex\" ],\n  // THREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n}\n";
});

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("108", [], function() {
  return "uniform vec3 diffuse;\nuniform float opacity;\nuniform float progresses[5];\nuniform float opacities[5];\nuniform float ringLength;\n\nvarying float vLengthPosition;\n\n// THREE.ShaderChunk[ \"common\" ],\n// THREE.ShaderChunk[ \"color_pars_fragment\" ],\n// THREE.ShaderChunk[ \"uv_pars_fragment\" ],\n// THREE.ShaderChunk[ \"uv2_pars_fragment\" ],\n// THREE.ShaderChunk[ \"map_pars_fragment\" ],\n// THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"aomap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"fog_pars_fragment\" ],\n// THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n// THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\n\nvoid main() {\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tvec3 totalAmbientLight = vec3( 1.0 ); // hardwired\n\tvec3 shadowMask = vec3( 1.0 );\n\n  // THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\n  // THREE.ShaderChunk[ \"map_fragment\" ],\n  // THREE.ShaderChunk[ \"color_fragment\" ],\n  // THREE.ShaderChunk[ \"alphamap_fragment\" ],\n  // THREE.ShaderChunk[ \"alphatest_fragment\" ],\n  // THREE.ShaderChunk[ \"specularmap_fragment\" ],\n  // THREE.ShaderChunk[ \"aomap_fragment\" ],\n  // THREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\toutgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;\n\n  // THREE.ShaderChunk[ \"envmap_fragment\" ],\n\n  // THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n  // THREE.ShaderChunk[ \"fog_fragment\" ],\n\n\tfloat alpha = 0.;\n\n\tfor(int i = 0; i < 5; i++) {\n\t\talpha += (1. - smoothstep(abs(progresses[i] - (1. - vLengthPosition)), 0., ringLength)) * opacities[i];\n\t}\n\n\talpha = min(alpha, 1.);\n\n\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fade = smoothstep(0.1, 100.0, depth);\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a * alpha * fade );\n\n}\n";
});

_removeDefine();
})();
$__System.register("109", ["107", "108", "f4", "f5", "f6", "f7", "10a", "fb", "f8", "ef", "fe", "f9"], function (_export) {
  var VERTEX_SHADER, FRAGMENT_SHADER, _get, _inherits, _createClass, _classCallCheck, _Map, _getIterator, _Object$assign, THREE, App, ShaderUtils, Tunnel;

  return {
    setters: [function (_) {
      VERTEX_SHADER = _["default"];
    }, function (_2) {
      FRAGMENT_SHADER = _2["default"];
    }, function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_a) {
      _Map = _a["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_f8) {
      _Object$assign = _f8["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_fe) {
      App = _fe["default"];
    }, function (_f9) {
      ShaderUtils = _f9["default"];
    }],
    execute: function () {
      "use strict";

      Tunnel = (function (_THREE$Object3D) {
        _inherits(Tunnel, _THREE$Object3D);

        function Tunnel(path) {
          _classCallCheck(this, Tunnel);

          _get(Object.getPrototypeOf(Tunnel.prototype), "constructor", this).call(this);

          this.path = path;

          this.tunnels = new _Map();
          this.currentTunnel = null;

          this._tweenProgresses = [{ value: 0 }, { value: 0 }, { value: 0 }, { value: 0 }, { value: 0 }];

          var straightCurve = new THREE.CatmullRomCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1000)]);
          var straightGeometry = new THREE.TubeGeometry(straightCurve, 128, 100, 4);
          var straightBufferGeometry = new THREE.BufferGeometry();
          straightBufferGeometry.fromGeometry(straightGeometry);
          var lengthPositionArray = new Float32Array(straightBufferGeometry.attributes.position.array.length / 3);
          for (var i = 0; i < lengthPositionArray.length; i++) {
            lengthPositionArray[i] = straightBufferGeometry.attributes.position.array[i * 3 + 2] / 1000;
          }
          straightBufferGeometry.addAttribute("lengthPosition", new THREE.BufferAttribute(lengthPositionArray, 1));

          // let straightMesh = new THREE.Mesh(straightBufferGeometry, this.material);
          // this.add(straightMesh);

          var vertexShader = ShaderUtils.replaceThreeChunks(VERTEX_SHADER);
          var fragmentShader = ShaderUtils.replaceThreeChunks(FRAGMENT_SHADER);

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(this.path.curves), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var curve = _step.value;

              var bufferGeometry = new THREE.BufferGeometry();
              var geometry = new THREE.TubeGeometry(curve, 128, 70, 4);
              bufferGeometry.fromGeometry(geometry);
              bufferGeometry.addAttribute("lengthPosition", new THREE.BufferAttribute(lengthPositionArray, 1));

              var uniforms = THREE.UniformsUtils.clone(THREE.ShaderLib.basic.uniforms);
              _Object$assign(uniforms, {
                progresses: {
                  type: "fv1",
                  value: [0, 0, 0, 0, 0]
                },
                opacities: {
                  type: "fv1",
                  value: [0, 0, 0, 0, 0]
                },
                ringLength: {
                  type: "f",
                  value: .01
                }
              });

              var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.DoubleSide,
                depthWrite: false,
                // depthTest: false,
                vertexColors: THREE.VertexColors,
                transparent: true
              });

              var mesh = new THREE.Mesh(bufferGeometry, material);
              mesh._length = curve.getLength();
              mesh.visible = false;
              mesh.matrixAutoUpdate = false;
              this.tunnels.set(curve.name, mesh);
              this.add(mesh);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.currentTunnel = this.tunnels.get("default");

          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(Tunnel, [{
          key: "onSceneChange",
          value: function onSceneChange(name, data) {
            var _this = this;

            if (!data.tunnel || Math.random() > .3) {
              return;
            }

            TweenMax.to(this.currentTunnel.material.uniforms.opacity, 1, {
              value: 0,
              onComplete: function onComplete(tunnel) {
                tunnel.visible = false;
                _this.changeTunnel(name, data.tunnel.color);
              },
              onCompleteParams: [this.currentTunnel]
            });
          }
        }, {
          key: "changeTunnel",
          value: function changeTunnel(name, colorHex) {
            var _this2 = this;

            this.currentTunnel = this.tunnels.get(name);
            this.currentTunnel.matrix.copy(this.path.currentOffsetMatrix);

            this.currentTunnel.visible = true;
            this.currentTunnel.material.uniforms.opacity.value = 1;

            var color = new THREE.Color(colorHex);

            TweenMax.to(this.currentTunnel.material.uniforms.diffuse.value, .4, {
              r: color.r,
              g: color.g,
              b: color.b
            });

            var scale = this.currentTunnel._length / 1000;
            var duration = .5 + Math.random();
            var delay = .2 + Math.random() * .2;

            for (var i = 0; i < this.currentTunnel.material.uniforms.progresses.value.length; i++) {
              TweenMax.killTweensOf(this._tweenProgresses[i]);
              this.currentTunnel.material.uniforms.progresses.value[i] = 0;
              this.currentTunnel.material.uniforms.ringLength.value = .005 / scale;
              this.currentTunnel.material.uniforms.opacities.value[i] = 0;

              delay += Math.random() < .5 ? .2 : .4;

              TweenMax.fromTo(this._tweenProgresses[i], duration, {
                value: 0
              }, {
                value: 1,
                delay: delay,
                onUpdate: function onUpdate(id) {
                  var progress = _this2._tweenProgresses[id];
                  _this2.currentTunnel.material.uniforms.progresses.value[id] = 1 - .3 / scale + progress.value * (.3 / scale);
                  _this2.currentTunnel.material.uniforms.opacities.value[id] = Math.sin(progress.value * Math.PI);
                },
                onUpdateParams: [i],
                ease: Linear.easeInOut
              });
            }
          }
        }]);

        return Tunnel;
      })(THREE.Object3D);

      _export("default", Tunnel);
    }
  };
});
$__System.register("10b", ["103", "f6", "f7", "ef", "fe"], function (_export) {
  var spring3, spring, _createClass, _classCallCheck, THREE, App, up, CameraControls;

  return {
    setters: [function (_) {
      spring3 = _.spring3;
      spring = _.spring;
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_fe) {
      App = _fe["default"];
    }],
    execute: function () {
      "use strict";

      up = new THREE.Vector3(0, 1, 0);

      /*
      	This utility moves a THREE.Object3D towards a 3D position in space whilst optionally maintaining
      	a minimum distance from it. The easing is a damped spring equation which can be continually
      	updated with a new position.
      
      	It also aims the camera towards the object too.
      */

      CameraControls = (function () {
        function CameraControls(camera, character) {
          _classCallCheck(this, CameraControls);

          this.camera = camera;
          this.character = character;

          this.currentRotation = new THREE.Matrix4();
          this.currentRotationQuat = new THREE.Quaternion();

          this.targetPositionDistance = 0.1;

          this.eye = new THREE.Vector3().copy(this.character);
          this.eyeTarget = new THREE.Vector3().copy(this.character);
          this._vector3Cached = new THREE.Vector3();
          this.focalDistance = 0.2;
          this.positionDistance = 0.2;

          this.wagon = new THREE.Vector3();

          // Define some transitions to position and orientate the camera
          this.positionlDistanceTransition = spring(10.5);
          this.positionTransition = spring3(10.5);
          this.eyeTargetTransition = spring3(5);
          this.focalDistanceTransition = spring(0.9);

          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(CameraControls, [{
          key: "onSceneChange",
          value: function onSceneChange() {
            this.targetPositionDistance = Math.max(this.targetPositionDistance - 0.08, 0.08);
          }
        }, {
          key: "update",
          value: function update(timeScale) {
            // Update camera distance
            this.targetPositionDistance = Math.min(this.targetPositionDistance + 0.005, 0.5);

            this.wagon.lerp(this.character, .015 * timeScale);

            var delta = .016 * timeScale;

            var targetFocalDistance = this.targetPositionDistance * 0.5;

            // CAMERA DIRECTION

            // Animate the value (0-1) along the path at which the camera should point
            this.focalDistance += this.focalDistanceTransition(this.focalDistance, targetFocalDistance, delta);

            // the get 3d point
            this.eyeTarget.copy(this.character).sub(this.wagon).normalize().multiplyScalar(this.focalDistance * -10).add(this.character);

            //
            this.eye.add(this.eyeTargetTransition(this.eye, this.eyeTarget, delta));

            // CAMERA POSITION

            // Animate the value (0-1) along the path at which the camera should point
            this.positionDistance += this.positionlDistanceTransition(this.positionDistance, this.targetPositionDistance, delta);

            var distanceFromLine = 50 * this.targetPositionDistance;
            var normal = new THREE.Vector3(0, distanceFromLine, 0);
            this._vector3Cached.copy(this.character).sub(this.wagon).normalize().multiplyScalar(this.positionDistance * -200).add(this.character);
            this._vector3Cached.add(normal);

            // UPDATE CAMERA
            this.camera.position.add(this.positionTransition(this.camera.position, this._vector3Cached, delta));

            // this.camera.updateMatrixWorld()
            // up.transformDirection( this.camera.matrixWorld )
            this.currentRotation.lookAt(this.camera.position, this.eye, up);
            this.currentRotationQuat.setFromRotationMatrix(this.currentRotation);

            this.camera.quaternion.slerp(this.currentRotationQuat, 0.1);
            // this.camera.lookAt( this.eye, up );
          }
        }]);

        return CameraControls;
      })();

      _export("default", CameraControls);
    }
  };
});
$__System.register("103", [], function (_export) {
	/*
 	Super simple generalised spring constraint with damping. Useful for animating objects smoothly
 
 	Usage: 
 	```
 
 		let transition = spring()
 		valueToAnimate += transition( valueToAnimate, valueToAnimateTowards, timeDelta )
 
 	```
 */

	"use strict";

	var spring, spring3;
	return {
		setters: [],
		execute: function () {
			spring = function spring() {
				var springiness = arguments.length <= 0 || arguments[0] === undefined ? 1.5 : arguments[0];

				var force = undefined,
				    root = Math.sqrt(springiness),
				    velocity = 0.0;
				// damp = v =>

				return function (a, b, delta) {
					var theta = b - a;
					force = theta * springiness + -velocity * 2.0 * root;
					velocity += force * delta;
					return velocity * delta;
				};
			};

			_export("spring", spring);

			/*
   
   	Same spring example in 3 dimensions
   	Usage: 
   	```
   
   		let transition = spring()
   		vec3ToAnimate.add( transition( vec3ToAnimate, vec3ToAnimateTowards, timeDelta ))
   
   	```
   */

			spring3 = function spring3(springiness) {

				var transition = {
					x: spring(springiness),
					y: spring(springiness),
					z: spring(springiness)
				};

				var velocity = { x: 0, y: 0, z: 0 };

				return function (a, b, delta) {

					velocity.x = transition.x(a.x, b.x, delta);
					velocity.y = transition.y(a.y, b.y, delta);
					velocity.z = transition.z(a.z, b.z, delta);

					return velocity;
				};
			};

			_export("spring3", spring3);
		}
	};
});
$__System.register("10c", ["101", "103", "105", "109", "f4", "f5", "f6", "f7", "ed", "ef", "ee", "fc", "10b", "10d", "fe", "10e"], function (_export) {
  var Background, spring, Path, Tunnel, _get, _inherits, _createClass, _classCallCheck, _toConsumableArray, THREE, Lines, CameraControls, Pointer, App, SoundManager, MainScene;

  return {
    setters: [function (_) {
      Background = _["default"];
    }, function (_4) {
      spring = _4.spring;
    }, function (_2) {
      Path = _2["default"];
    }, function (_3) {
      Tunnel = _3["default"];
    }, function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_ed) {
      _toConsumableArray = _ed["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_ee) {}, function (_fc) {
      Lines = _fc["default"];
    }, function (_b) {
      CameraControls = _b["default"];
    }, function (_d) {
      Pointer = _d["default"];
    }, function (_fe) {
      App = _fe["default"];
    }, function (_e) {
      SoundManager = _e["default"];
    }],
    execute: function () {
      "use strict";

      MainScene = (function (_THREE$Scene) {
        _inherits(MainScene, _THREE$Scene);

        function MainScene(canvas) {
          var useTextureNoise = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

          var _camera;

          var fov = arguments.length <= 2 || arguments[2] === undefined ? 65 : arguments[2];
          var viewOffset = arguments.length <= 3 || arguments[3] === undefined ? [0, 0] : arguments[3];

          _classCallCheck(this, MainScene);

          _get(Object.getPrototypeOf(MainScene.prototype), "constructor", this).call(this);

          this.pointer = Pointer.get(canvas);

          this.camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 100000);

          (_camera = this.camera).setViewOffset.apply(_camera, [window.innerWidth + viewOffset[0], window.innerHeight + viewOffset[1]].concat(_toConsumableArray(viewOffset), [window.innerWidth, window.innerHeight]));

          App.onSceneChange.add(this.onSceneChange, this);

          // Lighting

          var ambientLight = new THREE.AmbientLight(0xeeeeee);
          this.add(ambientLight);

          var directionalLight = new THREE.DirectionalLight();
          directionalLight.position.set(1, 1, 1);
          this.add(directionalLight);

          /*
              The character object is the focal point of the interaction.
              This is the point at which the lines geometry is generated
              and the camera follows
          */
          this.character = new THREE.Vector3();

          this.background = new Background(this.character, useTextureNoise);
          if (!/\bnobackground\b/.test(window.location.search)) {
            this.add(this.background);
          }

          this.path = new Path();
          this.path.update();

          // this.tunnel = new Tunnel(this.path);
          // this.add(this.tunnel);

          this.lines = new Lines(this.character);
          this.add(this.lines);

          if (/\bdebugcamera\b/.test(window.location.search)) {
            this.camera.position.z = 1;
            this.controls = new THREE.TrackballControls(this.camera);
          } else {
            this.controls = new CameraControls(this.camera, this.character);
          }

          SoundManager.play("Drone_02", {
            loop: true
          });

          for (var i = 0; i < 100; i++) {
            this.update();
          }

          App.onResize.add(this.resize, this);
        }

        _createClass(MainScene, [{
          key: "resize",
          value: function resize(width, height) {
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
          }
        }, {
          key: "onSceneChange",
          value: function onSceneChange(name, data) {
            if (data.sound) {
              SoundManager.play(data.sound);
            }
          }
        }, {
          key: "update",
          value: function update() {
            var timeScale = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

            // Move the focus point along the path
            this.path.update(timeScale);
            this.character.lerp(this.path.position, .1 * timeScale);

            // Update camera controls
            this.controls.update(timeScale);

            this.lines.update(timeScale);
          }
        }]);

        return MainScene;
      })(THREE.Scene);

      _export("default", MainScene);
    }
  };
});
$__System.registerDynamic("10f", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    'use strict';
    var isCommonjs = typeof module !== 'undefined' && module.exports;
    var keyboardAllowed = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element;
    var fn = (function() {
      var val;
      var valLength;
      var fnMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'], ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];
      var i = 0;
      var l = fnMap.length;
      var ret = {};
      for (; i < l; i++) {
        val = fnMap[i];
        if (val && val[1] in document) {
          for (i = 0, valLength = val.length; i < valLength; i++) {
            ret[fnMap[0][i]] = val[i];
          }
          return ret;
        }
      }
      return false;
    })();
    var screenfull = {
      request: function(elem) {
        var request = fn.requestFullscreen;
        elem = elem || document.documentElement;
        if (/5\.1[\.\d]* Safari/.test(navigator.userAgent)) {
          elem[request]();
        } else {
          elem[request](keyboardAllowed && Element.ALLOW_KEYBOARD_INPUT);
        }
      },
      exit: function() {
        document[fn.exitFullscreen]();
      },
      toggle: function(elem) {
        if (this.isFullscreen) {
          this.exit();
        } else {
          this.request(elem);
        }
      },
      raw: fn
    };
    if (!fn) {
      if (isCommonjs) {
        module.exports = false;
      } else {
        window.screenfull = false;
      }
      return;
    }
    Object.defineProperties(screenfull, {
      isFullscreen: {get: function() {
          return Boolean(document[fn.fullscreenElement]);
        }},
      element: {
        enumerable: true,
        get: function() {
          return document[fn.fullscreenElement];
        }
      },
      enabled: {
        enumerable: true,
        get: function() {
          return Boolean(document[fn.fullscreenEnabled]);
        }
      }
    });
    if (isCommonjs) {
      module.exports = screenfull;
    } else {
      window.screenfull = screenfull;
    }
  })();
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("110", ["10f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('10f');
  global.define = __define;
  return module.exports;
});

$__System.register("111", ["102", "110", "112", "f4", "f5", "f6", "f7", "fd", "fb", "ef", "fe", "10d"], function (_export) {
  var DATA, Screenfull, _Object$keys, _get, _inherits, _createClass, _classCallCheck, _slicedToArray, _getIterator, THREE, App, Pointer, UIScene;

  return {
    setters: [function (_2) {
      DATA = _2["default"];
    }, function (_3) {
      Screenfull = _3["default"];
    }, function (_) {
      _Object$keys = _["default"];
    }, function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fd) {
      _slicedToArray = _fd["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_fe) {
      App = _fe["default"];
    }, function (_d) {
      Pointer = _d["default"];
    }],
    execute: function () {
      "use strict";

      UIScene = (function (_THREE$Scene) {
        _inherits(UIScene, _THREE$Scene);

        function UIScene(canvas) {
          _classCallCheck(this, UIScene);

          _get(Object.getPrototypeOf(UIScene.prototype), "constructor", this).call(this);

          this.pointer = Pointer.get(canvas);

          this.camera = new THREE.OrthographicCamera(window.innerWidth * -.5, window.innerWidth * .5, window.innerHeight * .5, window.innerHeight * -.5, 1, 1000);
          this.camera.position.z = 10;

          var sceneNames = _Object$keys(DATA.scenes);
          sceneNames.splice(sceneNames.indexOf("default"), 1);

          this.grid = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.ShaderMaterial({
            depthTest: false,
            depthWrite: false,
            uniforms: {
              "resolution": {
                type: "v2",
                value: new THREE.Vector2()
              },
              "color": {
                type: "c",
                value: new THREE.Color()
              }
            },
            vertexShader: "\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",
            fragmentShader: "\n        uniform vec3 color;\n        uniform vec2 resolution;\n        varying vec2 vUv;\n        void main() {\n          vec2 coord = vUv * resolution;\n          float radius = 3.;\n          float opacity = 1. - distance(mod(coord, vec2(200.)), vec2(radius)) / radius;\n          opacity = step(.5, opacity);\n          gl_FragColor = vec4(color, opacity * .2);\n        }"
          }));
          this.grid.material.transparent = true;
          this.add(this.grid);

          this.planes = [];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(sceneNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var sceneName = _step.value;

              var plane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
              }));
              plane.name = sceneName;
              this.planes.push(plane);
              this.add(plane);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.raycaster = new THREE.Raycaster();

          this.pointer.onDown.add(this.onDown, this);

          App.onResize.add(this.resize, this);
          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(UIScene, [{
          key: "onSceneChange",
          value: function onSceneChange(sceneName, data) {
            var color = new THREE.Color(data.background.main);
            var light = color.getHSL().l < .5 ? 1 : 0;
            TweenMax.to(this.grid.material.uniforms.color.value, data.transitionDuration || .4, {
              r: light,
              g: light,
              b: light
            });
          }
        }, {
          key: "onDown",
          value: function onDown() {
            if (Screenfull.enabled) {
              Screenfull.request();
            }
            this.raycaster.setFromCamera(this.pointer.normalizedCenteredFlippedY, this.camera);
            var intersects = this.raycaster.intersectObjects(this.planes);
            if (intersects && intersects[0]) {
              var plane = intersects[0].object;
              App.changeSceneByName(plane.name);

              TweenMax.fromTo(plane.material, .2, {
                opacity: .2
              }, {
                opacity: 0
              });
            }
          }
        }, {
          key: "resize",
          value: function resize(width, height) {
            this.camera.left = width * -.5;
            this.camera.right = width * .5;
            this.camera.top = height * .5;
            this.camera.bottom = height * -.5;
            this.camera.updateProjectionMatrix();

            var gridWidth = width * .8;
            gridWidth -= gridWidth % 200.;
            gridWidth += 5;
            var gridHeight = height * .8;
            gridHeight -= gridHeight % 200.;
            gridHeight += 5;
            this.grid.scale.set(gridWidth, gridHeight, 1);
            this.grid.material.uniforms.resolution.value.set(gridWidth, gridHeight);

            var ratio = width / height;
            var rows = ratio > 1 ? 2 : 6;
            var columns = ratio > 1 ? 6 : 2;
            var planeWidth = width / columns;
            var planeHeight = height / rows;

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _getIterator(this.planes.entries()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _step2$value = _slicedToArray(_step2.value, 2);

                var i = _step2$value[0];
                var plane = _step2$value[1];

                plane.position.x = i % columns * planeWidth - width * .5 + planeWidth * .5;
                plane.position.y = Math.floor(i / columns) * planeHeight - height * .5 + planeHeight * .5;
                plane.scale.set(planeWidth, planeHeight, 1);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }]);

        return UIScene;
      })(THREE.Scene);

      _export("default", UIScene);
    }
  };
});
$__System.register("113", ["f6", "f7", "ef", "fe"], function (_export) {
  var _createClass, _classCallCheck, THREE, App, View;

  return {
    setters: [function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }, function (_fe) {
      App = _fe["default"];
    }],
    execute: function () {
      "use strict";

      View = (function () {
        function View(canvas, opts) {
          _classCallCheck(this, View);

          this.renderer = opts.renderer || new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
          });
          this.renderer.setClearColor(0x000000);
          this.renderer.autoClear = false;
          this.renderer.sortObjects = false;

          if (App.stats) {
            App.stats.addCustom("DrawCall", this.renderer.info.render, "calls");
            App.stats.addCustom("Faces", this.renderer.info.render, "faces");
            App.stats.addCustom("Points", this.renderer.info.render, "points");
            App.stats.addCustom("Vertices", this.renderer.info.render, "vertices");
            App.stats.addCustom("Geometries", this.renderer.info.memory, "geometries");
            App.stats.addCustom("Textures", this.renderer.info.memory, "textures");
          }

          App.onResize.add(this.resize, this);
          App.onSceneChange.add(this.onSceneChange, this);
        }

        _createClass(View, [{
          key: "onSceneChange",
          value: function onSceneChange(name, _ref) {
            var _this = this;

            var background = _ref.background;
            var _ref$transitionDuration = _ref.transitionDuration;
            var transitionDuration = _ref$transitionDuration === undefined ? .4 : _ref$transitionDuration;

            var clearColor = this.renderer.getClearColor();
            var nextClearColor = new THREE.Color(background.main);
            TweenMax.to(clearColor, transitionDuration * 3, {
              r: nextClearColor.r,
              g: nextClearColor.g,
              b: nextClearColor.b,
              ease: Power3.easeOut,
              onUpdate: function onUpdate() {
                _this.renderer.setClearColor(clearColor);
              }
            });
          }
        }, {
          key: "resize",
          value: function resize(width, height) {
            var lowQuality = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

            if (!lowQuality) {
              width *= window.devicePixelRatio;
              height *= window.devicePixelRatio;
            }

            this.renderer.setSize(width, height, false);
          }
        }, {
          key: "render",
          value: function render(mainScene, uiScene) {
            this.renderer.clear();

            this.renderer.render(mainScene, mainScene.camera);

            // this.renderer.render(uiScene, uiScene.camera);
          }
        }]);

        return View;
      })();

      _export("default", View);
    }
  };
});
$__System.register("114", ["106", "f6", "f7", "fd", "fb"], function (_export) {
  var Signal, _createClass, _classCallCheck, _slicedToArray, _getIterator, callbacks, scopes, Ticker;

  return {
    setters: [function (_) {
      Signal = _["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fd) {
      _slicedToArray = _fd["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }],
    execute: function () {
      "use strict";

      callbacks = [];
      scopes = [];

      Ticker = (function () {
        function Ticker() {
          _classCallCheck(this, Ticker);

          this._updateBinded = this.update.bind(this);

          this._previousTimestamp = 0;

          this.deltaTime = 0;

          this.update();
        }

        _createClass(Ticker, [{
          key: "update",
          value: function update(time) {
            requestAnimationFrame(this._updateBinded);

            var timestamp = window.performance.now();

            this.deltaTime = timestamp - this._previousTimestamp;

            this._previousTimestamp = timestamp;

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _getIterator(callbacks.entries()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2);

                var i = _step$value[0];
                var callback = _step$value[1];

                callback.call(scopes[i]);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"]) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }, {
          key: "add",
          value: function add(callback, scope) {
            callbacks.push(callback);
            scopes.push(scope);
          }
        }, {
          key: "remove",
          value: function remove(callback) {
            var index = callbacks.indexOf(callback);
            callbacks.splice(index, 1);
            scopes.splice(index, 1);
          }
        }]);

        return Ticker;
      })();

      _export("default", new Ticker());
    }
  };
});
$__System.registerDynamic("115", ["116", "117"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('116');
  $__require('117')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("118", ["119", "115"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119');
  $__require('115');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11a", ["118"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('118'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f4", ["11a"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('11a')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11b", ["119"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11c", ["11b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('11b'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11d", ["119", "11e", "11f", "e2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('119').getDesc,
      isObject = $__require('11e'),
      anObject = $__require('11f');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('e2')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("120", ["e3", "11d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('e3');
  $export($export.S, 'Object', {setPrototypeOf: $__require('11d').set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("121", ["120", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('120');
  module.exports = $__require('eb').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("122", ["121"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('121'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f5", ["11c", "122"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('11c')["default"];
  var _Object$setPrototypeOf = $__require('122')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("123", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    var THREE = this["THREE"];
    var THREE = {REVISION: '73'};
    if (typeof define === 'function' && define.amd) {
      define('three', THREE);
    } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
      module.exports = THREE;
    }
    if (self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined) {
      (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !self.requestAnimationFrame; ++x) {
          self.requestAnimationFrame = self[vendors[x] + 'RequestAnimationFrame'];
          self.cancelAnimationFrame = self[vendors[x] + 'CancelAnimationFrame'] || self[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if (self.requestAnimationFrame === undefined && self.setTimeout !== undefined) {
          self.requestAnimationFrame = function(callback) {
            var currTime = Date.now(),
                timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = self.setTimeout(function() {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
        }
        if (self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined) {
          self.cancelAnimationFrame = function(id) {
            self.clearTimeout(id);
          };
        }
      })();
    }
    if (self.performance === undefined) {
      self.performance = {};
    }
    if (self.performance.now === undefined) {
      (function() {
        var start = Date.now();
        self.performance.now = function() {
          return Date.now() - start;
        };
      })();
    }
    if (Number.EPSILON === undefined) {
      Number.EPSILON = Math.pow(2, -52);
    }
    if (Math.sign === undefined) {
      Math.sign = function(x) {
        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
      };
    }
    if (Function.prototype.name === undefined && Object.defineProperty !== undefined) {
      Object.defineProperty(Function.prototype, 'name', {get: function() {
          return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }});
    }
    THREE.MOUSE = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2
    };
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.NeverDepth = 0;
    THREE.AlwaysDepth = 1;
    THREE.LessDepth = 2;
    THREE.LessEqualDepth = 3;
    THREE.EqualDepth = 4;
    THREE.GreaterEqualDepth = 5;
    THREE.GreaterDepth = 6;
    THREE.NotEqualDepth = 7;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.UVMapping = 300;
    THREE.CubeReflectionMapping = 301;
    THREE.CubeRefractionMapping = 302;
    THREE.EquirectangularReflectionMapping = 303;
    THREE.EquirectangularRefractionMapping = 304;
    THREE.SphericalReflectionMapping = 305;
    THREE.RepeatWrapping = 1000;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.HalfFloatType = 1025;
    THREE.UnsignedShort4444Type = 1016;
    THREE.UnsignedShort5551Type = 1017;
    THREE.UnsignedShort565Type = 1018;
    THREE.AlphaFormat = 1019;
    THREE.RGBFormat = 1020;
    THREE.RGBAFormat = 1021;
    THREE.LuminanceFormat = 1022;
    THREE.LuminanceAlphaFormat = 1023;
    THREE.RGBEFormat = THREE.RGBAFormat;
    THREE.RGB_S3TC_DXT1_Format = 2001;
    THREE.RGBA_S3TC_DXT1_Format = 2002;
    THREE.RGBA_S3TC_DXT3_Format = 2003;
    THREE.RGBA_S3TC_DXT5_Format = 2004;
    THREE.RGB_PVRTC_4BPPV1_Format = 2100;
    THREE.RGB_PVRTC_2BPPV1_Format = 2101;
    THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
    THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
    THREE.LoopOnce = 2200;
    THREE.LoopRepeat = 2201;
    THREE.LoopPingPong = 2202;
    THREE.Projector = function() {
      console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
      this.projectVector = function(vector, camera) {
        console.warn('THREE.Projector: .projectVector() is now vector.project().');
        vector.project(camera);
      };
      this.unprojectVector = function(vector, camera) {
        console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        vector.unproject(camera);
      };
      this.pickingRay = function(vector, camera) {
        console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
      };
    };
    THREE.CanvasRenderer = function() {
      console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
      this.domElement = document.createElement('canvas');
      this.clear = function() {};
      this.render = function() {};
      this.setClearColor = function() {};
      this.setSize = function() {};
    };
    THREE.Color = function(color) {
      if (arguments.length === 3) {
        return this.fromArray(arguments);
      }
      return this.set(color);
    };
    THREE.Color.prototype = {
      constructor: THREE.Color,
      r: 1,
      g: 1,
      b: 1,
      set: function(value) {
        if (value instanceof THREE.Color) {
          this.copy(value);
        } else if (typeof value === 'number') {
          this.setHex(value);
        } else if (typeof value === 'string') {
          this.setStyle(value);
        }
        return this;
      },
      setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      },
      setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      },
      setHSL: function() {
        function hue2rgb(p, q, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p + (q - p) * 6 * t;
          if (t < 1 / 2)
            return q;
          if (t < 2 / 3)
            return p + (q - p) * 6 * (2 / 3 - t);
          return p;
        }
        return function(h, s, l) {
          h = THREE.Math.euclideanModulo(h, 1);
          s = THREE.Math.clamp(s, 0, 1);
          l = THREE.Math.clamp(l, 0, 1);
          if (s === 0) {
            this.r = this.g = this.b = l;
          } else {
            var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
            var q = (2 * l) - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
          }
          return this;
        };
      }(),
      setStyle: function(style) {
        function handleAlpha(string) {
          if (string === undefined)
            return;
          if (parseFloat(string) < 1) {
            console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
          }
        }
        var m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
          var color;
          var name = m[1];
          var components = m[2];
          switch (name) {
            case 'rgb':
            case 'rgba':
              if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                handleAlpha(color[5]);
                return this;
              }
              if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                handleAlpha(color[5]);
                return this;
              }
              break;
            case 'hsl':
            case 'hsla':
              if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                var h = parseFloat(color[1]) / 360;
                var s = parseInt(color[2], 10) / 100;
                var l = parseInt(color[3], 10) / 100;
                handleAlpha(color[5]);
                return this.setHSL(h, s, l);
              }
              break;
          }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
          var hex = m[1];
          var size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            return this;
          }
        }
        if (style && style.length > 0) {
          var hex = THREE.ColorKeywords[style];
          if (hex !== undefined) {
            this.setHex(hex);
          } else {
            console.warn('THREE.Color: Unknown color ' + style);
          }
        }
        return this;
      },
      clone: function() {
        return new this.constructor(this.r, this.g, this.b);
      },
      copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      },
      copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      },
      copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      },
      convertGammaToLinear: function() {
        var r = this.r,
            g = this.g,
            b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
      },
      convertLinearToGamma: function() {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
      },
      getHex: function() {
        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
      },
      getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function(optionalTarget) {
        var hsl = optionalTarget || {
          h: 0,
          s: 0,
          l: 0
        };
        var r = this.r,
            g = this.g,
            b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue,
            saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
      },
      getStyle: function() {
        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
      },
      offsetHSL: function(h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
      },
      add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      },
      addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      },
      addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      },
      multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      },
      multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      },
      lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      },
      equals: function(c) {
        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      }
    };
    THREE.ColorKeywords = {
      'aliceblue': 0xF0F8FF,
      'antiquewhite': 0xFAEBD7,
      'aqua': 0x00FFFF,
      'aquamarine': 0x7FFFD4,
      'azure': 0xF0FFFF,
      'beige': 0xF5F5DC,
      'bisque': 0xFFE4C4,
      'black': 0x000000,
      'blanchedalmond': 0xFFEBCD,
      'blue': 0x0000FF,
      'blueviolet': 0x8A2BE2,
      'brown': 0xA52A2A,
      'burlywood': 0xDEB887,
      'cadetblue': 0x5F9EA0,
      'chartreuse': 0x7FFF00,
      'chocolate': 0xD2691E,
      'coral': 0xFF7F50,
      'cornflowerblue': 0x6495ED,
      'cornsilk': 0xFFF8DC,
      'crimson': 0xDC143C,
      'cyan': 0x00FFFF,
      'darkblue': 0x00008B,
      'darkcyan': 0x008B8B,
      'darkgoldenrod': 0xB8860B,
      'darkgray': 0xA9A9A9,
      'darkgreen': 0x006400,
      'darkgrey': 0xA9A9A9,
      'darkkhaki': 0xBDB76B,
      'darkmagenta': 0x8B008B,
      'darkolivegreen': 0x556B2F,
      'darkorange': 0xFF8C00,
      'darkorchid': 0x9932CC,
      'darkred': 0x8B0000,
      'darksalmon': 0xE9967A,
      'darkseagreen': 0x8FBC8F,
      'darkslateblue': 0x483D8B,
      'darkslategray': 0x2F4F4F,
      'darkslategrey': 0x2F4F4F,
      'darkturquoise': 0x00CED1,
      'darkviolet': 0x9400D3,
      'deeppink': 0xFF1493,
      'deepskyblue': 0x00BFFF,
      'dimgray': 0x696969,
      'dimgrey': 0x696969,
      'dodgerblue': 0x1E90FF,
      'firebrick': 0xB22222,
      'floralwhite': 0xFFFAF0,
      'forestgreen': 0x228B22,
      'fuchsia': 0xFF00FF,
      'gainsboro': 0xDCDCDC,
      'ghostwhite': 0xF8F8FF,
      'gold': 0xFFD700,
      'goldenrod': 0xDAA520,
      'gray': 0x808080,
      'green': 0x008000,
      'greenyellow': 0xADFF2F,
      'grey': 0x808080,
      'honeydew': 0xF0FFF0,
      'hotpink': 0xFF69B4,
      'indianred': 0xCD5C5C,
      'indigo': 0x4B0082,
      'ivory': 0xFFFFF0,
      'khaki': 0xF0E68C,
      'lavender': 0xE6E6FA,
      'lavenderblush': 0xFFF0F5,
      'lawngreen': 0x7CFC00,
      'lemonchiffon': 0xFFFACD,
      'lightblue': 0xADD8E6,
      'lightcoral': 0xF08080,
      'lightcyan': 0xE0FFFF,
      'lightgoldenrodyellow': 0xFAFAD2,
      'lightgray': 0xD3D3D3,
      'lightgreen': 0x90EE90,
      'lightgrey': 0xD3D3D3,
      'lightpink': 0xFFB6C1,
      'lightsalmon': 0xFFA07A,
      'lightseagreen': 0x20B2AA,
      'lightskyblue': 0x87CEFA,
      'lightslategray': 0x778899,
      'lightslategrey': 0x778899,
      'lightsteelblue': 0xB0C4DE,
      'lightyellow': 0xFFFFE0,
      'lime': 0x00FF00,
      'limegreen': 0x32CD32,
      'linen': 0xFAF0E6,
      'magenta': 0xFF00FF,
      'maroon': 0x800000,
      'mediumaquamarine': 0x66CDAA,
      'mediumblue': 0x0000CD,
      'mediumorchid': 0xBA55D3,
      'mediumpurple': 0x9370DB,
      'mediumseagreen': 0x3CB371,
      'mediumslateblue': 0x7B68EE,
      'mediumspringgreen': 0x00FA9A,
      'mediumturquoise': 0x48D1CC,
      'mediumvioletred': 0xC71585,
      'midnightblue': 0x191970,
      'mintcream': 0xF5FFFA,
      'mistyrose': 0xFFE4E1,
      'moccasin': 0xFFE4B5,
      'navajowhite': 0xFFDEAD,
      'navy': 0x000080,
      'oldlace': 0xFDF5E6,
      'olive': 0x808000,
      'olivedrab': 0x6B8E23,
      'orange': 0xFFA500,
      'orangered': 0xFF4500,
      'orchid': 0xDA70D6,
      'palegoldenrod': 0xEEE8AA,
      'palegreen': 0x98FB98,
      'paleturquoise': 0xAFEEEE,
      'palevioletred': 0xDB7093,
      'papayawhip': 0xFFEFD5,
      'peachpuff': 0xFFDAB9,
      'peru': 0xCD853F,
      'pink': 0xFFC0CB,
      'plum': 0xDDA0DD,
      'powderblue': 0xB0E0E6,
      'purple': 0x800080,
      'red': 0xFF0000,
      'rosybrown': 0xBC8F8F,
      'royalblue': 0x4169E1,
      'saddlebrown': 0x8B4513,
      'salmon': 0xFA8072,
      'sandybrown': 0xF4A460,
      'seagreen': 0x2E8B57,
      'seashell': 0xFFF5EE,
      'sienna': 0xA0522D,
      'silver': 0xC0C0C0,
      'skyblue': 0x87CEEB,
      'slateblue': 0x6A5ACD,
      'slategray': 0x708090,
      'slategrey': 0x708090,
      'snow': 0xFFFAFA,
      'springgreen': 0x00FF7F,
      'steelblue': 0x4682B4,
      'tan': 0xD2B48C,
      'teal': 0x008080,
      'thistle': 0xD8BFD8,
      'tomato': 0xFF6347,
      'turquoise': 0x40E0D0,
      'violet': 0xEE82EE,
      'wheat': 0xF5DEB3,
      'white': 0xFFFFFF,
      'whitesmoke': 0xF5F5F5,
      'yellow': 0xFFFF00,
      'yellowgreen': 0x9ACD32
    };
    THREE.Quaternion = function(x, y, z, w) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._w = (w !== undefined) ? w : 1;
    };
    THREE.Quaternion.prototype = {
      constructor: THREE.Quaternion,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get w() {
        return this._w;
      },
      set w(value) {
        this._w = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
      },
      setFromEuler: function(euler, update) {
        if (euler instanceof THREE.Euler === false) {
          throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        var order = euler.order;
        if (order === 'XYZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromAxisAngle: function(axis, angle) {
        var halfAngle = angle / 2,
            s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m) {
        var te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10],
            trace = m11 + m22 + m33,
            s;
        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
      },
      setFromUnitVectors: function() {
        var v1,
            r;
        var EPS = 0.000001;
        return function(vFrom, vTo) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          r = vFrom.dot(vTo) + 1;
          if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              v1.set(-vFrom.y, vFrom.x, 0);
            } else {
              v1.set(0, -vFrom.z, vFrom.y);
            }
          } else {
            v1.crossVectors(vFrom, vTo);
          }
          this._x = v1.x;
          this._y = v1.y;
          this._z = v1.z;
          this._w = r;
          this.normalize();
          return this;
        };
      }(),
      inverse: function() {
        this.conjugate().normalize();
        return this;
      },
      conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
      },
      dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      },
      lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
      },
      multiply: function(q, p) {
        if (p !== undefined) {
          console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      },
      multiplyQuaternions: function(a, b) {
        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
      },
      multiplyVector3: function(vector) {
        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
      },
      slerp: function(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        var halfTheta = Math.acos(cosHalfTheta);
        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < 0.001) {
          this._w = 0.5 * (w + this._w);
          this._x = 0.5 * (x + this._x);
          this._y = 0.5 * (y + this._y);
          this._z = 0.5 * (z + this._z);
          return this;
        }
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = (w * ratioA + this._w * ratioB);
        this._x = (x * ratioA + this._x * ratioB);
        this._y = (y * ratioA + this._y * ratioB);
        this._z = (z * ratioA + this._z * ratioB);
        this.onChangeCallback();
        return this;
      },
      equals: function(quaternion) {
        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {}
    };
    THREE.Quaternion.slerp = function(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    };
    THREE.Vector2 = function(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    };
    THREE.Vector2.prototype = {
      constructor: THREE.Vector2,
      get width() {
        return this.x;
      },
      set width(value) {
        this.x = value;
      },
      get height() {
        return this.y;
      },
      set height(value) {
        this.y = value;
      },
      set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      },
      addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      },
      multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      },
      multiplyScalar: function(scalar) {
        if (isFinite(scalar)) {
          this.x *= scalar;
          this.y *= scalar;
        } else {
          this.x = 0;
          this.y = 0;
        }
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      },
      clampScalar: function() {
        var min,
            max;
        return function clampScalar(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector2();
            max = new THREE.Vector2();
          }
          min.set(minVal, minVal);
          max.set(maxVal, maxVal);
          return this.clamp(min, max);
        };
      }(),
      clampLength: function(min, max) {
        var length = this.length();
        this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        return this;
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;
      },
      setLength: function(length) {
        return this.multiplyScalar(length / this.length());
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
      },
      rotateAround: function(center, angle) {
        var c = Math.cos(angle),
            s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
    };
    THREE.Vector3 = function(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    };
    THREE.Vector3.prototype = {
      constructor: THREE.Vector3,
      set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      },
      addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      },
      multiply: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      },
      multiplyScalar: function(scalar) {
        if (isFinite(scalar)) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
        }
        return this;
      },
      multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      },
      applyEuler: function() {
        var quaternion;
        return function applyEuler(euler) {
          if (euler instanceof THREE.Euler === false) {
            console.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');
          }
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromEuler(euler));
          return this;
        };
      }(),
      applyAxisAngle: function() {
        var quaternion;
        return function applyAxisAngle(axis, angle) {
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
          return this;
        };
      }(),
      applyMatrix3: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
      },
      applyProjection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
      },
      applyQuaternion: function(q) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      },
      project: function() {
        var matrix;
        return function project(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
          return this.applyProjection(matrix);
        };
      }(),
      unproject: function() {
        var matrix;
        return function unproject(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
          return this.applyProjection(matrix);
        };
      }(),
      transformDirection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        this.normalize();
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      },
      clampScalar: function() {
        var min,
            max;
        return function clampScalar(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector3();
            max = new THREE.Vector3();
          }
          min.set(minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      }(),
      clampLength: function(min, max) {
        var length = this.length();
        this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        return this;
      },
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(length) {
        return this.multiplyScalar(length / this.length());
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      cross: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
          return this.crossVectors(v, w);
        }
        var x = this.x,
            y = this.y,
            z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
      },
      crossVectors: function(a, b) {
        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      },
      projectOnVector: function() {
        var v1,
            dot;
        return function projectOnVector(vector) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(vector).normalize();
          dot = this.dot(v1);
          return this.copy(v1).multiplyScalar(dot);
        };
      }(),
      projectOnPlane: function() {
        var v1;
        return function projectOnPlane(planeNormal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(this).projectOnVector(planeNormal);
          return this.sub(v1);
        };
      }(),
      reflect: function() {
        var v1;
        return function reflect(normal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
      }(),
      angleTo: function(v) {
        var theta = this.dot(v) / (this.length() * v.length());
        return Math.acos(THREE.Math.clamp(theta, -1, 1));
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      },
      setEulerFromRotationMatrix: function(m, order) {
        console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
      },
      setEulerFromQuaternion: function(q, order) {
        console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
      },
      getPositionFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
      },
      getScaleFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
      },
      getColumnFromMatrix: function(index, matrix) {
        console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(index, matrix);
      },
      setFromMatrixPosition: function(m) {
        this.x = m.elements[12];
        this.y = m.elements[13];
        this.z = m.elements[14];
        return this;
      },
      setFromMatrixScale: function(m) {
        var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
        var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
        var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      },
      setFromMatrixColumn: function(index, matrix) {
        var offset = index * 4;
        var me = matrix.elements;
        this.x = me[offset];
        this.y = me[offset + 1];
        this.z = me[offset + 2];
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
      }
    };
    THREE.Vector4 = function(x, y, z, w) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = (w !== undefined) ? w : 1;
    };
    THREE.Vector4.prototype = {
      constructor: THREE.Vector4,
      set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setW: function(w) {
        this.w = w;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = (v.w !== undefined) ? v.w : 1;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      },
      addScaledVector: function(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      },
      multiplyScalar: function(scalar) {
        if (isFinite(scalar)) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
          this.w *= scalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
        }
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      },
      divideScalar: function(scalar) {
        return this.multiplyScalar(1 / scalar);
      },
      setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      },
      setAxisAngleFromRotationMatrix: function(m) {
        var angle,
            x,
            y,
            z,
            epsilon = 0.01,
            epsilon2 = 0.1,
            te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
          if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if ((xx > yy) && (xx > zz)) {
            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 0.001)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      },
      min: function(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      },
      max: function(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      },
      clamp: function(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      },
      clampScalar: function() {
        var min,
            max;
        return function clampScalar(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector4();
            max = new THREE.Vector4();
          }
          min.set(minVal, minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      }(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(length) {
        return this.multiplyScalar(length / this.length());
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
      }
    };
    THREE.Euler = function(x, y, z, order) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._order = order || THREE.Euler.DefaultOrder;
    };
    THREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    THREE.Euler.DefaultOrder = 'XYZ';
    THREE.Euler.prototype = {
      constructor: THREE.Euler,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get order() {
        return this._order;
      },
      set order(value) {
        this._order = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
      },
      clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m, order, update) {
        var clamp = THREE.Math.clamp;
        var te = m.elements;
        var m11 = te[0],
            m12 = te[4],
            m13 = te[8];
        var m21 = te[1],
            m22 = te[5],
            m23 = te[9];
        var m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        order = order || this._order;
        if (order === 'XYZ') {
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.99999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === 'YXZ') {
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.99999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === 'ZXY') {
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.99999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === 'ZYX') {
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.99999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === 'YZX') {
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.99999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === 'XZY') {
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.99999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
        }
        this._order = order;
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromQuaternion: function() {
        var matrix;
        return function(q, order, update) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.makeRotationFromQuaternion(q);
          this.setFromRotationMatrix(matrix, order, update);
          return this;
        };
      }(),
      setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      },
      reorder: function() {
        var q = new THREE.Quaternion();
        return function(newOrder) {
          q.setFromEuler(this);
          this.setFromQuaternion(q, newOrder);
        };
      }(),
      equals: function(euler) {
        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
      },
      fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined)
          this._order = array[3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      },
      toVector3: function(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new THREE.Vector3(this._x, this._y, this._z);
        }
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {}
    };
    THREE.Line3 = function(start, end) {
      this.start = (start !== undefined) ? start : new THREE.Vector3();
      this.end = (end !== undefined) ? end : new THREE.Vector3();
    };
    THREE.Line3.prototype = {
      constructor: THREE.Line3,
      set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.end, this.start);
      },
      distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      },
      distance: function() {
        return this.start.distanceTo(this.end);
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      closestPointToPointParameter: function() {
        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();
        return function(point, clampToLine) {
          startP.subVectors(point, this.start);
          startEnd.subVectors(this.end, this.start);
          var startEnd2 = startEnd.dot(startEnd);
          var startEnd_startP = startEnd.dot(startP);
          var t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = THREE.Math.clamp(t, 0, 1);
          }
          return t;
        };
      }(),
      closestPointToPoint: function(point, clampToLine, optionalTarget) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      },
      equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
    };
    THREE.Box2 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector2(Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector2(-Infinity, -Infinity);
    };
    THREE.Box2.prototype = {
      constructor: THREE.Box2,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector2();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector2();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    THREE.Box3 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
    };
    THREE.Box3.prototype = {
      constructor: THREE.Box3,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector3();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      setFromObject: function() {
        var v1 = new THREE.Vector3();
        return function(object) {
          var scope = this;
          object.updateMatrixWorld(true);
          this.makeEmpty();
          object.traverse(function(node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
              if (geometry instanceof THREE.Geometry) {
                var vertices = geometry.vertices;
                for (var i = 0,
                    il = vertices.length; i < il; i++) {
                  v1.copy(vertices[i]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {
                var positions = geometry.attributes['position'].array;
                for (var i = 0,
                    il = positions.length; i < il; i += 3) {
                  v1.set(positions[i], positions[i + 1], positions[i + 2]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              }
            }
          });
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y) && (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      getBoundingSphere: function() {
        var v1 = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Sphere();
          result.center = this.center();
          result.radius = this.size(v1).length() * 0.5;
          return result;
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      applyMatrix4: function() {
        var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
        return function(matrix) {
          points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.makeEmpty();
          this.setFromPoints(points);
          return this;
        };
      }(),
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    THREE.Matrix3 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix3.prototype = {
      constructor: THREE.Matrix3,
      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[3] = n12;
        te[6] = n13;
        te[1] = n21;
        te[4] = n22;
        te[7] = n23;
        te[2] = n31;
        te[5] = n32;
        te[8] = n33;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
      },
      multiplyVector3: function(vector) {
        console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
      },
      multiplyVector3Array: function(a) {
        console.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1;
        return function(array, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.fromArray(array, j);
            v1.applyMatrix3(this);
            v1.toArray(array, j);
          }
          return array;
        };
      }(),
      applyToBuffer: function() {
        var v1;
        return function applyToBuffer(buffer, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = buffer.length / buffer.itemSize;
          for (var i = 0,
              j = offset; i < length; i++, j++) {
            v1.x = buffer.getX(j);
            v1.y = buffer.getY(j);
            v1.z = buffer.getZ(j);
            v1.applyMatrix3(this);
            buffer.setXYZ(v1.x, v1.y, v1.z);
          }
          return buffer;
        };
      }(),
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      },
      determinant: function() {
        var te = this.elements;
        var a = te[0],
            b = te[1],
            c = te[2],
            d = te[3],
            e = te[4],
            f = te[5],
            g = te[6],
            h = te[7],
            i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      },
      getInverse: function(matrix, throwOnInvertible) {
        var me = matrix.elements;
        var te = this.elements;
        te[0] = me[10] * me[5] - me[6] * me[9];
        te[1] = -me[10] * me[1] + me[2] * me[9];
        te[2] = me[6] * me[1] - me[2] * me[5];
        te[3] = -me[10] * me[4] + me[6] * me[8];
        te[4] = me[10] * me[0] - me[2] * me[8];
        te[5] = -me[6] * me[0] + me[2] * me[4];
        te[6] = me[9] * me[4] - me[5] * me[8];
        te[7] = -me[9] * me[0] + me[1] * me[8];
        te[8] = me[5] * me[0] - me[1] * me[4];
        var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
        if (det === 0) {
          var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1.0 / det);
        return this;
      },
      transpose: function() {
        var tmp,
            m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      },
      getNormalMatrix: function(m) {
        this.getInverse(m).transpose();
        return this;
      },
      transposeIntoArray: function(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8]];
      }
    };
    THREE.Matrix4 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix4.prototype = {
      constructor: THREE.Matrix4,
      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
      },
      copy: function(m) {
        this.elements.set(m.elements);
        return this;
      },
      extractPosition: function(m) {
        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
      },
      copyPosition: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
      },
      makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      },
      extractRotation: function() {
        var v1;
        return function(m) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          var te = this.elements;
          var me = m.elements;
          var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
          var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
          var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          return this;
        };
      }(),
      makeRotationFromEuler: function(euler) {
        if (euler instanceof THREE.Euler === false) {
          console.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var te = this.elements;
        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos(x),
            b = Math.sin(x);
        var c = Math.cos(y),
            d = Math.sin(y);
        var e = Math.cos(z),
            f = Math.sin(z);
        if (euler.order === 'XYZ') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === 'YXZ') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === 'ZXY') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === 'ZYX') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === 'YZX') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      setRotationFromQuaternion: function(q) {
        console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q);
      },
      makeRotationFromQuaternion: function(q) {
        var te = this.elements;
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      lookAt: function() {
        var x,
            y,
            z;
        return function(eye, target, up) {
          if (x === undefined)
            x = new THREE.Vector3();
          if (y === undefined)
            y = new THREE.Vector3();
          if (z === undefined)
            z = new THREE.Vector3();
          var te = this.elements;
          z.subVectors(eye, target).normalize();
          if (z.lengthSq() === 0) {
            z.z = 1;
          }
          x.crossVectors(up, z).normalize();
          if (x.lengthSq() === 0) {
            z.x += 0.0001;
            x.crossVectors(up, z).normalize();
          }
          y.crossVectors(z, x);
          te[0] = x.x;
          te[4] = y.x;
          te[8] = z.x;
          te[1] = x.y;
          te[5] = y.y;
          te[9] = z.y;
          te[2] = x.z;
          te[6] = y.z;
          te[10] = z.z;
          return this;
        };
      }(),
      multiply: function(m, n) {
        if (n !== undefined) {
          console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      },
      multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0],
            a12 = ae[4],
            a13 = ae[8],
            a14 = ae[12];
        var a21 = ae[1],
            a22 = ae[5],
            a23 = ae[9],
            a24 = ae[13];
        var a31 = ae[2],
            a32 = ae[6],
            a33 = ae[10],
            a34 = ae[14];
        var a41 = ae[3],
            a42 = ae[7],
            a43 = ae[11],
            a44 = ae[15];
        var b11 = be[0],
            b12 = be[4],
            b13 = be[8],
            b14 = be[12];
        var b21 = be[1],
            b22 = be[5],
            b23 = be[9],
            b24 = be[13];
        var b31 = be[2],
            b32 = be[6],
            b33 = be[10],
            b34 = be[14];
        var b41 = be[3],
            b42 = be[7],
            b43 = be[11],
            b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      },
      multiplyToArray: function(a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
      },
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      },
      multiplyVector3: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
        return vector.applyProjection(this);
      },
      multiplyVector4: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      multiplyVector3Array: function(a) {
        console.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1;
        return function(array, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.fromArray(array, j);
            v1.applyMatrix4(this);
            v1.toArray(array, j);
          }
          return array;
        };
      }(),
      applyToBuffer: function() {
        var v1;
        return function applyToBuffer(buffer, offset, length) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = buffer.length / buffer.itemSize;
          for (var i = 0,
              j = offset; i < length; i++, j++) {
            v1.x = buffer.getX(j);
            v1.y = buffer.getY(j);
            v1.z = buffer.getZ(j);
            v1.applyMatrix4(this);
            buffer.setXYZ(v1.x, v1.y, v1.z);
          }
          return buffer;
        };
      }(),
      rotateAxis: function(v) {
        console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
      },
      crossVector: function(vector) {
        console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      determinant: function() {
        var te = this.elements;
        var n11 = te[0],
            n12 = te[4],
            n13 = te[8],
            n14 = te[12];
        var n21 = te[1],
            n22 = te[5],
            n23 = te[9],
            n24 = te[13];
        var n31 = te[2],
            n32 = te[6],
            n33 = te[10],
            n34 = te[14];
        var n41 = te[3],
            n42 = te[7],
            n43 = te[11],
            n44 = te[15];
        return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
      },
      transpose: function() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      },
      getPosition: function() {
        var v1;
        return function() {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
          var te = this.elements;
          return v1.set(te[12], te[13], te[14]);
        };
      }(),
      setPosition: function(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
      },
      getInverse: function(m, throwOnInvertible) {
        var te = this.elements;
        var me = m.elements;
        var n11 = me[0],
            n12 = me[4],
            n13 = me[8],
            n14 = me[12];
        var n21 = me[1],
            n22 = me[5],
            n23 = me[9],
            n24 = me[13];
        var n31 = me[2],
            n32 = me[6],
            n33 = me[10],
            n34 = me[14];
        var n41 = me[3],
            n42 = me[7],
            n43 = me[11],
            n44 = me[15];
        te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
        var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
        if (det === 0) {
          var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1 / det);
        return this;
      },
      translate: function(v) {
        console.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function(angle) {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function(angle) {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function(angle) {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function(axis, angle) {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      scale: function(v) {
        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      },
      getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      },
      makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      },
      makeRotationX: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationY: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationZ: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationAxis: function(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      },
      makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      },
      compose: function(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
      },
      decompose: function() {
        var vector,
            matrix;
        return function(position, quaternion, scale) {
          if (vector === undefined)
            vector = new THREE.Vector3();
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          var te = this.elements;
          var sx = vector.set(te[0], te[1], te[2]).length();
          var sy = vector.set(te[4], te[5], te[6]).length();
          var sz = vector.set(te[8], te[9], te[10]).length();
          var det = this.determinant();
          if (det < 0) {
            sx = -sx;
          }
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          matrix.elements.set(this.elements);
          var invSX = 1 / sx;
          var invSY = 1 / sy;
          var invSZ = 1 / sz;
          matrix.elements[0] *= invSX;
          matrix.elements[1] *= invSX;
          matrix.elements[2] *= invSX;
          matrix.elements[4] *= invSY;
          matrix.elements[5] *= invSY;
          matrix.elements[6] *= invSY;
          matrix.elements[8] *= invSZ;
          matrix.elements[9] *= invSZ;
          matrix.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(matrix);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        };
      }(),
      makeFrustum: function(left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      },
      makePerspective: function(fov, aspect, near, far) {
        var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
      },
      makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;
        var x = (right + left) / w;
        var y = (top + bottom) / h;
        var z = (far + near) / p;
        te[0] = 2 / w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 / h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 / p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      },
      equals: function(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 16; i++) {
          if (te[i] !== me[i])
            return false;
        }
        return true;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15]];
      }
    };
    THREE.Ray = function(origin, direction) {
      this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
      this.direction = (direction !== undefined) ? direction : new THREE.Vector3();
    };
    THREE.Ray.prototype = {
      constructor: THREE.Ray,
      set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
      },
      recast: function() {
        var v1 = new THREE.Vector3();
        return function(t) {
          this.origin.copy(this.at(t, v1));
          return this;
        };
      }(),
      closestPointToPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
          return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      },
      distanceToPoint: function(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      },
      distanceSqToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceToSquared(point);
          }
          v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return v1.distanceToSquared(point);
        };
      }(),
      distanceSqToSegment: function() {
        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();
        return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          segDir.copy(v1).sub(v0).normalize();
          diff.copy(this.origin).sub(segCenter);
          var segExtent = v0.distanceTo(v1) * 0.5;
          var a01 = -this.direction.dot(segDir);
          var b0 = diff.dot(this.direction);
          var b1 = -diff.dot(segDir);
          var c = diff.lengthSq();
          var det = Math.abs(1 - a01 * a01);
          var s0,
              s1,
              sqrDist,
              extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  var invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
          }
          return sqrDist;
        };
      }(),
      isIntersectionSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
      },
      intersectSphere: function() {
        var v1 = new THREE.Vector3();
        return function(sphere, optionalTarget) {
          v1.subVectors(sphere.center, this.origin);
          var tca = v1.dot(this.direction);
          var d2 = v1.dot(v1) - tca * tca;
          var radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          var thc = Math.sqrt(radius2 - d2);
          var t0 = tca - thc;
          var t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, optionalTarget);
          return this.at(t0, optionalTarget);
        };
      }(),
      isIntersectionPlane: function(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      },
      distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      },
      intersectPlane: function(plane, optionalTarget) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, optionalTarget);
      },
      isIntersectionBox: function() {
        var v = new THREE.Vector3();
        return function(box) {
          return this.intersectBox(box, v) !== null;
        };
      }(),
      intersectBox: function(box, optionalTarget) {
        var tmin,
            tmax,
            tymin,
            tymax,
            tzmin,
            tzmax;
        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if ((tmin > tymax) || (tymin > tmax))
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if ((tmin > tzmax) || (tzmin > tmax))
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
      },
      intersectTriangle: function() {
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();
        return function(a, b, c, backfaceCulling, optionalTarget) {
          edge1.subVectors(b, a);
          edge2.subVectors(c, a);
          normal.crossVectors(edge1, edge2);
          var DdN = this.direction.dot(normal);
          var sign;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign = 1;
          } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          diff.subVectors(this.origin, a);
          var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          var QdN = -sign * diff.dot(normal);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, optionalTarget);
        };
      }(),
      applyMatrix4: function(matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
      },
      equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
    };
    THREE.Sphere = function(center, radius) {
      this.center = (center !== undefined) ? center : new THREE.Vector3();
      this.radius = (radius !== undefined) ? radius : 0;
    };
    THREE.Sphere.prototype = {
      constructor: THREE.Sphere,
      set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      },
      setFromPoints: function() {
        var box = new THREE.Box3();
        return function(points, optionalCenter) {
          var center = this.center;
          if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
          } else {
            box.setFromPoints(points).center(center);
          }
          var maxRadiusSq = 0;
          for (var i = 0,
              il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      },
      empty: function() {
        return (this.radius <= 0);
      },
      containsPoint: function(point) {
        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
      },
      distanceToPoint: function(point) {
        return (point.distanceTo(this.center) - this.radius);
      },
      intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
      },
      clampPoint: function(point, optionalTarget) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        var result = optionalTarget || new THREE.Vector3();
        result.copy(point);
        if (deltaLengthSq > (this.radius * this.radius)) {
          result.sub(this.center).normalize();
          result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
      },
      getBoundingBox: function(optionalTarget) {
        var box = optionalTarget || new THREE.Box3();
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
      },
      applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      },
      translate: function(offset) {
        this.center.add(offset);
        return this;
      },
      equals: function(sphere) {
        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
      }
    };
    THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
      this.planes = [(p0 !== undefined) ? p0 : new THREE.Plane(), (p1 !== undefined) ? p1 : new THREE.Plane(), (p2 !== undefined) ? p2 : new THREE.Plane(), (p3 !== undefined) ? p3 : new THREE.Plane(), (p4 !== undefined) ? p4 : new THREE.Plane(), (p5 !== undefined) ? p5 : new THREE.Plane()];
    };
    THREE.Frustum.prototype = {
      constructor: THREE.Frustum,
      set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          planes[i].copy(frustum.planes[i]);
        }
        return this;
      },
      setFromMatrix: function(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0],
            me1 = me[1],
            me2 = me[2],
            me3 = me[3];
        var me4 = me[4],
            me5 = me[5],
            me6 = me[6],
            me7 = me[7];
        var me8 = me[8],
            me9 = me[9],
            me10 = me[10],
            me11 = me[11];
        var me12 = me[12],
            me13 = me[13],
            me14 = me[14],
            me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      },
      intersectsObject: function() {
        var sphere = new THREE.Sphere();
        return function(object) {
          var geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          sphere.copy(geometry.boundingSphere);
          sphere.applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(sphere);
        };
      }(),
      intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
          var distance = planes[i].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      },
      intersectsBox: function() {
        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();
        return function(box) {
          var planes = this.planes;
          for (var i = 0; i < 6; i++) {
            var plane = planes[i];
            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            var d1 = plane.distanceToPoint(p1);
            var d2 = plane.distanceToPoint(p2);
            if (d1 < 0 && d2 < 0) {
              return false;
            }
          }
          return true;
        };
      }(),
      containsPoint: function(point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          if (planes[i].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
    };
    THREE.Plane = function(normal, constant) {
      this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
      this.constant = (constant !== undefined) ? constant : 0;
    };
    THREE.Plane.prototype = {
      constructor: THREE.Plane,
      set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      },
      setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      },
      setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      },
      setFromCoplanarPoints: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        return function(a, b, c) {
          var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        };
      }(),
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      },
      normalize: function() {
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      },
      negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      },
      distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
      },
      distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      },
      projectPoint: function(point, optionalTarget) {
        return this.orthoPoint(point, optionalTarget).sub(point).negate();
      },
      orthoPoint: function(point, optionalTarget) {
        var perpendicularMagnitude = this.distanceToPoint(point);
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
      },
      isIntersectionLine: function(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
      },
      intersectLine: function() {
        var v1 = new THREE.Vector3();
        return function(line, optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          var direction = line.delta(v1);
          var denominator = this.normal.dot(direction);
          if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) {
              return result.copy(line.start);
            }
            return undefined;
          }
          var t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return undefined;
          }
          return result.copy(direction).multiplyScalar(t).add(line.start);
        };
      }(),
      coplanarPoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();
        return function(matrix, optionalNormalMatrix) {
          var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
          var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
          var newCoplanarPoint = this.coplanarPoint(v2);
          newCoplanarPoint.applyMatrix4(matrix);
          this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
          return this;
        };
      }(),
      translate: function(offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
      },
      equals: function(plane) {
        return plane.normal.equals(this.normal) && (plane.constant === this.constant);
      }
    };
    THREE.Math = {
      generateUUID: function() {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0,
            r;
        return function() {
          for (var i = 0; i < 36; i++) {
            if (i === 8 || i === 13 || i === 18 || i === 23) {
              uuid[i] = '-';
            } else if (i === 14) {
              uuid[i] = '4';
            } else {
              if (rnd <= 0x02)
                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
              r = rnd & 0xf;
              rnd = rnd >> 4;
              uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];
            }
          }
          return uuid.join('');
        };
      }(),
      clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
      },
      euclideanModulo: function(n, m) {
        return ((n % m) + m) % m;
      },
      mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      },
      smoothstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      },
      smootherstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      },
      random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
      },
      randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
      },
      randFloat: function(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
      },
      degToRad: function() {
        var degreeToRadiansFactor = Math.PI / 180;
        return function(degrees) {
          return degrees * degreeToRadiansFactor;
        };
      }(),
      radToDeg: function() {
        var radianToDegreesFactor = 180 / Math.PI;
        return function(radians) {
          return radians * radianToDegreesFactor;
        };
      }(),
      isPowerOfTwo: function(value) {
        return (value & (value - 1)) === 0 && value !== 0;
      },
      nearestPowerOfTwo: function(value) {
        return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
      },
      nextPowerOfTwo: function(value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
      }
    };
    THREE.Spline = function(points) {
      this.points = points;
      var c = [],
          v3 = {
            x: 0,
            y: 0,
            z: 0
          },
          point,
          intPoint,
          weight,
          w2,
          w3,
          pa,
          pb,
          pc,
          pd;
      this.initFromArray = function(a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
          this.points[i] = {
            x: a[i][0],
            y: a[i][1],
            z: a[i][2]
          };
        }
      };
      this.getPoint = function(k) {
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
      };
      this.getControlPointsArray = function() {
        var i,
            p,
            l = this.points.length,
            coords = [];
        for (i = 0; i < l; i++) {
          p = this.points[i];
          coords[i] = [p.x, p.y, p.z];
        }
        return coords;
      };
      this.getLength = function(nSubDivisions) {
        var i,
            index,
            nSamples,
            position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;
        chunkLengths[0] = 0;
        if (!nSubDivisions)
          nSubDivisions = 100;
        nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (i = 1; i < nSamples; i++) {
          index = i / nSamples;
          position = this.getPoint(index);
          tmpVec.copy(position);
          totalLength += tmpVec.distanceTo(oldPosition);
          oldPosition.copy(position);
          point = (this.points.length - 1) * index;
          intPoint = Math.floor(point);
          if (intPoint !== oldIntPoint) {
            chunkLengths[intPoint] = totalLength;
            oldIntPoint = intPoint;
          }
        }
        chunkLengths[chunkLengths.length] = totalLength;
        return {
          chunks: chunkLengths,
          total: totalLength
        };
      };
      this.reparametrizeByArcLength = function(samplingCoef) {
        var i,
            j,
            index,
            indexCurrent,
            indexNext,
            realDistance,
            sampling,
            position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (i = 1; i < this.points.length; i++) {
          realDistance = sl.chunks[i] - sl.chunks[i - 1];
          sampling = Math.ceil(samplingCoef * realDistance / sl.total);
          indexCurrent = (i - 1) / (this.points.length - 1);
          indexNext = i / (this.points.length - 1);
          for (j = 1; j < sampling - 1; j++) {
            index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
            position = this.getPoint(index);
            newpoints.push(tmpVec.copy(position).clone());
          }
          newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
      };
      function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    };
    THREE.Triangle = function(a, b, c) {
      this.a = (a !== undefined) ? a : new THREE.Vector3();
      this.b = (b !== undefined) ? b : new THREE.Vector3();
      this.c = (c !== undefined) ? c : new THREE.Vector3();
    };
    THREE.Triangle.normal = function() {
      var v0 = new THREE.Vector3();
      return function(a, b, c, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
          return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
      };
    }();
    THREE.Triangle.barycoordFromPoint = function() {
      var v0 = new THREE.Vector3();
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(point, a, b, c, optionalTarget) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = (dot00 * dot11 - dot01 * dot01);
        var result = optionalTarget || new THREE.Vector3();
        if (denom === 0) {
          return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return result.set(1 - u - v, v, u);
      };
    }();
    THREE.Triangle.containsPoint = function() {
      var v1 = new THREE.Vector3();
      return function(point, a, b, c) {
        var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
        return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
      };
    }();
    THREE.Triangle.prototype = {
      constructor: THREE.Triangle,
      set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      },
      setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      },
      area: function() {
        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();
        return function() {
          v0.subVectors(this.c, this.b);
          v1.subVectors(this.a, this.b);
          return v0.cross(v1).length() * 0.5;
        };
      }(),
      midpoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      },
      normal: function(optionalTarget) {
        return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
      },
      plane: function(optionalTarget) {
        var result = optionalTarget || new THREE.Plane();
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
      },
      barycoordFromPoint: function(point, optionalTarget) {
        return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
      },
      containsPoint: function(point) {
        return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
      },
      equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    };
    THREE.Channels = function() {
      this.mask = 1;
    };
    THREE.Channels.prototype = {
      constructor: THREE.Channels,
      set: function(channel) {
        this.mask = 1 << channel;
      },
      enable: function(channel) {
        this.mask |= 1 << channel;
      },
      toggle: function(channel) {
        this.mask ^= 1 << channel;
      },
      disable: function(channel) {
        this.mask &= ~(1 << channel);
      }
    };
    THREE.Clock = function(autoStart) {
      this.autoStart = (autoStart !== undefined) ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    };
    THREE.Clock.prototype = {
      constructor: THREE.Clock,
      start: function() {
        this.startTime = self.performance.now();
        this.oldTime = this.startTime;
        this.running = true;
      },
      stop: function() {
        this.getElapsedTime();
        this.running = false;
      },
      getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
      },
      getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
        }
        if (this.running) {
          var newTime = self.performance.now();
          diff = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    THREE.EventDispatcher = function() {};
    THREE.EventDispatcher.prototype = {
      constructor: THREE.EventDispatcher,
      apply: function(object) {
        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
      },
      addEventListener: function(type, listener) {
        if (this._listeners === undefined)
          this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
          return true;
        }
        return false;
      },
      removeEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
          var index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      },
      dispatchEvent: function(event) {
        if (this._listeners === undefined)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
          event.target = this;
          var array = [];
          var length = listenerArray.length;
          for (var i = 0; i < length; i++) {
            array[i] = listenerArray[i];
          }
          for (var i = 0; i < length; i++) {
            array[i].call(this, event);
          }
        }
      }
    };
    (function(THREE) {
      THREE.Raycaster = function(origin, direction, near, far) {
        this.ray = new THREE.Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
          Mesh: {},
          Line: {},
          LOD: {},
          Points: {threshold: 1},
          Sprite: {}
        };
        Object.defineProperties(this.params, {PointCloud: {get: function() {
              console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
              return this.Points;
            }}});
      };
      function descSort(a, b) {
        return a.distance - b.distance;
      }
      function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false)
          return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
          var children = object.children;
          for (var i = 0,
              l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects, true);
          }
        }
      }
      THREE.Raycaster.prototype = {
        constructor: THREE.Raycaster,
        linePrecision: 1,
        set: function(origin, direction) {
          this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
          if (camera instanceof THREE.PerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          } else if (camera instanceof THREE.OrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          } else {
            console.error('THREE.Raycaster: Unsupported camera type.');
          }
        },
        intersectObject: function(object, recursive) {
          var intersects = [];
          intersectObject(object, this, intersects, recursive);
          intersects.sort(descSort);
          return intersects;
        },
        intersectObjects: function(objects, recursive) {
          var intersects = [];
          if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects;
          }
          for (var i = 0,
              l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects, recursive);
          }
          intersects.sort(descSort);
          return intersects;
        }
      };
    }(THREE));
    THREE.Object3D = function() {
      Object.defineProperty(this, 'id', {value: THREE.Object3DIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Object3D';
      this.parent = null;
      this.channels = new THREE.Channels();
      this.children = [];
      this.up = THREE.Object3D.DefaultUp.clone();
      var position = new THREE.Vector3();
      var rotation = new THREE.Euler();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
      }
      rotation.onChange(onRotationChange);
      quaternion.onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          enumerable: true,
          value: position
        },
        rotation: {
          enumerable: true,
          value: rotation
        },
        quaternion: {
          enumerable: true,
          value: quaternion
        },
        scale: {
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {value: new THREE.Matrix4()},
        normalMatrix: {value: new THREE.Matrix3()}
      });
      this.rotationAutoUpdate = true;
      this.matrix = new THREE.Matrix4();
      this.matrixWorld = new THREE.Matrix4();
      this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.userData = {};
    };
    THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
    THREE.Object3D.DefaultMatrixAutoUpdate = true;
    THREE.Object3D.prototype = {
      constructor: THREE.Object3D,
      get eulerOrder() {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
        return this.rotation.order;
      },
      set eulerOrder(value) {
        console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
        this.rotation.order = value;
      },
      get useQuaternion() {
        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set useQuaternion(value) {
        console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set renderDepth(value) {
        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
      },
      applyMatrix: function(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
      },
      setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function() {
        var q1 = new THREE.Quaternion();
        return function(axis, angle) {
          q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(q1);
          return this;
        };
      }(),
      rotateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      translateOnAxis: function() {
        var v1 = new THREE.Vector3();
        return function(axis, distance) {
          v1.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(v1.multiplyScalar(distance));
          return this;
        };
      }(),
      translate: function(distance, axis) {
        console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
      },
      translateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
      }(),
      lookAt: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          m1.lookAt(vector, this.position, this.up);
          this.quaternion.setFromRotationMatrix(m1);
        };
      }(),
      add: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object instanceof THREE.Object3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          object.dispatchEvent({type: 'added'});
          this.children.push(object);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          object.dispatchEvent({type: 'removed'});
          this.children.splice(index, 1);
        }
      },
      getChildByName: function(name) {
        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
      },
      getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
      },
      getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
      },
      getObjectByProperty: function(name, value) {
        if (this[name] === value)
          return this;
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          var child = this.children[i];
          var object = child.getObjectByProperty(name, value);
          if (object !== undefined) {
            return object;
          }
        }
        return undefined;
      },
      getWorldPosition: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function() {
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Quaternion();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, result, scale);
          return result;
        };
      }(),
      getWorldRotation: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Euler();
          this.getWorldQuaternion(quaternion);
          return result.setFromQuaternion(quaternion, this.rotation.order, false);
        };
      }(),
      getWorldScale: function() {
        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, quaternion, result);
          return result;
        };
      }(),
      getWorldDirection: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.getWorldQuaternion(quaternion);
          return result.set(0, 0, 1).applyQuaternion(quaternion);
        };
      }(),
      raycast: function() {},
      traverse: function(callback) {
        callback(this);
        var children = this.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          children[i].traverse(callback);
        }
      },
      traverseVisible: function(callback) {
        if (this.visible === false)
          return;
        callback(this);
        var children = this.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          children[i].traverseVisible(callback);
        }
      },
      traverseAncestors: function(callback) {
        var parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate === true)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].updateMatrixWorld(force);
        }
      },
      toJSON: function(meta) {
        var isRootObject = (meta === undefined);
        var output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {}
          };
          output.metadata = {
            version: 4.4,
            type: 'Object',
            generator: 'Object3D.toJSON'
          };
        }
        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '')
          object.name = this.name;
        if (JSON.stringify(this.userData) !== '{}')
          object.userData = this.userData;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        object.matrix = this.matrix.toArray();
        if (this.geometry !== undefined) {
          if (meta.geometries[this.geometry.uuid] === undefined) {
            meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta);
          }
          object.geometry = this.geometry.uuid;
        }
        if (this.material !== undefined) {
          if (meta.materials[this.material.uuid] === undefined) {
            meta.materials[this.material.uuid] = this.material.toJSON(meta);
          }
          object.material = this.material.uuid;
        }
        if (this.children.length > 0) {
          object.children = [];
          for (var i = 0; i < this.children.length; i++) {
            object.children.push(this.children[i].toJSON(meta).object);
          }
        }
        if (isRootObject) {
          var geometries = extractFromCache(meta.geometries);
          var materials = extractFromCache(meta.materials);
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      },
      clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
      },
      copy: function(source, recursive) {
        if (recursive === undefined)
          recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.rotationAutoUpdate = source.rotationAutoUpdate;
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (var i = 0; i < source.children.length; i++) {
            var child = source.children[i];
            this.add(child.clone());
          }
        }
        return this;
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
    THREE.Object3DIdCount = 0;
    THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
      this.vertexNormals = Array.isArray(normal) ? normal : [];
      this.color = color instanceof THREE.Color ? color : new THREE.Color();
      this.vertexColors = Array.isArray(color) ? color : [];
      this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    };
    THREE.Face3.prototype = {
      constructor: THREE.Face3,
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for (var i = 0,
            il = source.vertexNormals.length; i < il; i++) {
          this.vertexNormals[i] = source.vertexNormals[i].clone();
        }
        for (var i = 0,
            il = source.vertexColors.length; i < il; i++) {
          this.vertexColors[i] = source.vertexColors[i].clone();
        }
        return this;
      }
    };
    THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {
      console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
      return new THREE.Face3(a, b, c, normal, color, materialIndex);
    };
    THREE.BufferAttribute = function(array, itemSize) {
      this.uuid = THREE.Math.generateUUID();
      this.array = array;
      this.itemSize = itemSize;
      this.dynamic = false;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    };
    THREE.BufferAttribute.prototype = {
      constructor: THREE.BufferAttribute,
      get length() {
        console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
        return this.array.length;
      },
      get count() {
        return this.array.length / this.itemSize;
      },
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      },
      setDynamic: function(value) {
        this.dynamic = value;
        return this;
      },
      copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.dynamic = source.dynamic;
        return this;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0,
            l = this.itemSize; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      },
      copyArray: function(array) {
        this.array.set(array);
        return this;
      },
      copyColorsArray: function(colors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = colors.length; i < l; i++) {
          var color = colors[i];
          if (color === undefined) {
            console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
            color = new THREE.Color();
          }
          array[offset++] = color.r;
          array[offset++] = color.g;
          array[offset++] = color.b;
        }
        return this;
      },
      copyIndicesArray: function(indices) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = indices.length; i < l; i++) {
          var index = indices[i];
          array[offset++] = index.a;
          array[offset++] = index.b;
          array[offset++] = index.c;
        }
        return this;
      },
      copyVector2sArray: function(vectors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = vectors.length; i < l; i++) {
          var vector = vectors[i];
          if (vector === undefined) {
            console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
            vector = new THREE.Vector2();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
        }
        return this;
      },
      copyVector3sArray: function(vectors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = vectors.length; i < l; i++) {
          var vector = vectors[i];
          if (vector === undefined) {
            console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
            vector = new THREE.Vector3();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
        }
        return this;
      },
      copyVector4sArray: function(vectors) {
        var array = this.array,
            offset = 0;
        for (var i = 0,
            l = vectors.length; i < l; i++) {
          var vector = vectors[i];
          if (vector === undefined) {
            console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
            vector = new THREE.Vector4();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
          array[offset++] = vector.w;
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === undefined)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      getX: function(index) {
        return this.array[index * this.itemSize];
      },
      setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
      },
      getY: function(index) {
        return this.array[index * this.itemSize + 1];
      },
      setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
      },
      getZ: function(index) {
        return this.array[index * this.itemSize + 2];
      },
      setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      },
      getW: function(index) {
        return this.array[index * this.itemSize + 3];
      },
      setW: function(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
      },
      setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    };
    THREE.Int8Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Int8Array(array), itemSize);
    };
    THREE.Uint8Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint8Array(array), itemSize);
    };
    THREE.Uint8ClampedAttribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint8ClampedArray(array), itemSize);
    };
    THREE.Int16Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Int16Array(array), itemSize);
    };
    THREE.Uint16Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint16Array(array), itemSize);
    };
    THREE.Int32Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Int32Array(array), itemSize);
    };
    THREE.Uint32Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Uint32Array(array), itemSize);
    };
    THREE.Float32Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Float32Array(array), itemSize);
    };
    THREE.Float64Attribute = function(array, itemSize) {
      return new THREE.BufferAttribute(new Float64Array(array), itemSize);
    };
    THREE.DynamicBufferAttribute = function(array, itemSize) {
      console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
      return new THREE.BufferAttribute(array, itemSize).setDynamic(true);
    };
    THREE.InstancedBufferAttribute = function(array, itemSize, meshPerAttribute) {
      THREE.BufferAttribute.call(this, array, itemSize);
      this.meshPerAttribute = meshPerAttribute || 1;
    };
    THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
    THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
    THREE.InstancedBufferAttribute.prototype.copy = function(source) {
      THREE.BufferAttribute.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    };
    THREE.InterleavedBuffer = function(array, stride) {
      this.uuid = THREE.Math.generateUUID();
      this.array = array;
      this.stride = stride;
      this.dynamic = false;
      this.updateRange = {
        offset: 0,
        count: -1
      };
      this.version = 0;
    };
    THREE.InterleavedBuffer.prototype = {
      constructor: THREE.InterleavedBuffer,
      get length() {
        return this.array.length;
      },
      get count() {
        return this.array.length / this.stride;
      },
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      },
      setDynamic: function(value) {
        this.dynamic = value;
        return this;
      },
      copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.stride = source.stride;
        this.dynamic = source.dynamic;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i = 0,
            l = this.stride; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === undefined)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    };
    THREE.InstancedInterleavedBuffer = function(array, stride, meshPerAttribute) {
      THREE.InterleavedBuffer.call(this, array, stride);
      this.meshPerAttribute = meshPerAttribute || 1;
    };
    THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
    THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
    THREE.InstancedInterleavedBuffer.prototype.copy = function(source) {
      THREE.InterleavedBuffer.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    };
    THREE.InterleavedBufferAttribute = function(interleavedBuffer, itemSize, offset) {
      this.uuid = THREE.Math.generateUUID();
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
    };
    THREE.InterleavedBufferAttribute.prototype = {
      constructor: THREE.InterleavedBufferAttribute,
      get length() {
        console.warn('THREE.BufferAttribute: .length has been deprecated. Please use .count.');
        return this.array.length;
      },
      get count() {
        return this.data.array.length / this.data.stride;
      },
      setX: function(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
      },
      setY: function(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
      },
      setZ: function(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
      },
      setW: function(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      },
      getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
      },
      getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
      },
      getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
      },
      getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
      },
      setXY: function(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
      }
    };
    THREE.Geometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Geometry';
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.elementsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.lineDistancesNeedUpdate = false;
      this.groupsNeedUpdate = false;
    };
    THREE.Geometry.prototype = {
      constructor: THREE.Geometry,
      applyMatrix: function(matrix) {
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        for (var i = 0,
            il = this.vertices.length; i < il; i++) {
          var vertex = this.vertices[i];
          vertex.applyMatrix4(matrix);
        }
        for (var i = 0,
            il = this.faces.length; i < il; i++) {
          var face = this.faces[i];
          face.normal.applyMatrix3(normalMatrix).normalize();
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
          }
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
      },
      rotateX: function() {
        var m1;
        return function rotateX(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationX(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateY: function() {
        var m1;
        return function rotateY(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationY(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateZ: function() {
        var m1;
        return function rotateZ(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationZ(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      translate: function() {
        var m1;
        return function translate(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeTranslation(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      scale: function() {
        var m1;
        return function scale(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeScale(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      lookAt: function() {
        var obj;
        return function lookAt(vector) {
          if (obj === undefined)
            obj = new THREE.Object3D();
          obj.lookAt(vector);
          obj.updateMatrix();
          this.applyMatrix(obj.matrix);
        };
      }(),
      fromBufferGeometry: function(geometry) {
        var scope = this;
        var indices = geometry.index !== null ? geometry.index.array : undefined;
        var attributes = geometry.attributes;
        var vertices = attributes.position.array;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
        if (uvs2 !== undefined)
          this.faceVertexUvs[1] = [];
        var tempNormals = [];
        var tempUVs = [];
        var tempUVs2 = [];
        for (var i = 0,
            j = 0,
            k = 0; i < vertices.length; i += 3, j += 2, k += 4) {
          scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
          if (normals !== undefined) {
            tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
          }
          if (colors !== undefined) {
            scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
          }
          if (uvs !== undefined) {
            tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
          }
          if (uvs2 !== undefined) {
            tempUVs2.push(new THREE.Vector2(uvs2[j], uvs2[j + 1]));
          }
        }
        function addFace(a, b, c) {
          var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
          var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
          var face = new THREE.Face3(a, b, c, vertexNormals, vertexColors);
          scope.faces.push(face);
          if (uvs !== undefined) {
            scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
          }
          if (uvs2 !== undefined) {
            scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
          }
        }
        ;
        if (indices !== undefined) {
          var groups = geometry.groups;
          if (groups.length > 0) {
            for (var i = 0; i < groups.length; i++) {
              var group = groups[i];
              var start = group.start;
              var count = group.count;
              for (var j = start,
                  jl = start + count; j < jl; j += 3) {
                addFace(indices[j], indices[j + 1], indices[j + 2]);
              }
            }
          } else {
            for (var i = 0; i < indices.length; i += 3) {
              addFace(indices[i], indices[i + 1], indices[i + 2]);
            }
          }
        } else {
          for (var i = 0; i < vertices.length / 3; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
      },
      normalize: function() {
        this.computeBoundingSphere();
        var center = this.boundingSphere.center;
        var radius = this.boundingSphere.radius;
        var s = radius === 0 ? 1 : 1.0 / radius;
        var matrix = new THREE.Matrix4();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix(matrix);
        return this;
      },
      computeFaceNormals: function() {
        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();
        for (var f = 0,
            fl = this.faces.length; f < fl; f++) {
          var face = this.faces[f];
          var vA = this.vertices[face.a];
          var vB = this.vertices[face.b];
          var vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          cb.normalize();
          face.normal.copy(cb);
        }
      },
      computeVertexNormals: function(areaWeighted) {
        var v,
            vl,
            f,
            fl,
            face,
            vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v] = new THREE.Vector3();
        }
        if (areaWeighted) {
          var vA,
              vB,
              vC;
          var cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vA = this.vertices[face.a];
            vB = this.vertices[face.b];
            vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            vertices[face.a].add(cb);
            vertices[face.b].add(cb);
            vertices[face.c].add(cb);
          }
        } else {
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vertices[face.a].add(face.normal);
            vertices[face.b].add(face.normal);
            vertices[face.c].add(face.normal);
          }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            vertexNormals[0].copy(vertices[face.a]);
            vertexNormals[1].copy(vertices[face.b]);
            vertexNormals[2].copy(vertices[face.c]);
          } else {
            vertexNormals[0] = vertices[face.a].clone();
            vertexNormals[1] = vertices[face.b].clone();
            vertexNormals[2] = vertices[face.c].clone();
          }
        }
      },
      computeMorphNormals: function() {
        var i,
            il,
            f,
            fl,
            face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          if (!face.__originalFaceNormal) {
            face.__originalFaceNormal = face.normal.clone();
          } else {
            face.__originalFaceNormal.copy(face.normal);
          }
          if (!face.__originalVertexNormals)
            face.__originalVertexNormals = [];
          for (i = 0, il = face.vertexNormals.length; i < il; i++) {
            if (!face.__originalVertexNormals[i]) {
              face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            } else {
              face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
            }
          }
        }
        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
          if (!this.morphNormals[i]) {
            this.morphNormals[i] = {};
            this.morphNormals[i].faceNormals = [];
            this.morphNormals[i].vertexNormals = [];
            var dstNormalsFace = this.morphNormals[i].faceNormals;
            var dstNormalsVertex = this.morphNormals[i].vertexNormals;
            var faceNormal,
                vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
              faceNormal = new THREE.Vector3();
              vertexNormals = {
                a: new THREE.Vector3(),
                b: new THREE.Vector3(),
                c: new THREE.Vector3()
              };
              dstNormalsFace.push(faceNormal);
              dstNormalsVertex.push(vertexNormals);
            }
          }
          var morphNormals = this.morphNormals[i];
          tmpGeo.vertices = this.morphTargets[i].vertices;
          tmpGeo.computeFaceNormals();
          tmpGeo.computeVertexNormals();
          var faceNormal,
              vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            faceNormal = morphNormals.faceNormals[f];
            vertexNormals = morphNormals.vertexNormals[f];
            faceNormal.copy(face.normal);
            vertexNormals.a.copy(face.vertexNormals[0]);
            vertexNormals.b.copy(face.vertexNormals[1]);
            vertexNormals.c.copy(face.vertexNormals[2]);
          }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.normal = face.__originalFaceNormal;
          face.vertexNormals = face.__originalVertexNormals;
        }
      },
      computeTangents: function() {
        console.warn('THREE.Geometry: .computeTangents() has been removed.');
      },
      computeLineDistances: function() {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          if (i > 0) {
            d += vertices[i].distanceTo(vertices[i - 1]);
          }
          this.lineDistances[i] = d;
        }
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new THREE.Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new THREE.Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(geometry, matrix, materialIndexOffset) {
        if (geometry instanceof THREE.Geometry === false) {
          console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
          return;
        }
        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[0],
            uvs2 = geometry.faceVertexUvs[0];
        if (materialIndexOffset === undefined)
          materialIndexOffset = 0;
        if (matrix !== undefined) {
          normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        }
        for (var i = 0,
            il = vertices2.length; i < il; i++) {
          var vertex = vertices2[i];
          var vertexCopy = vertex.clone();
          if (matrix !== undefined)
            vertexCopy.applyMatrix4(matrix);
          vertices1.push(vertexCopy);
        }
        for (i = 0, il = faces2.length; i < il; i++) {
          var face = faces2[i],
              faceCopy,
              normal,
              color,
              faceVertexNormals = face.vertexNormals,
              faceVertexColors = face.vertexColors;
          faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
          faceCopy.normal.copy(face.normal);
          if (normalMatrix !== undefined) {
            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
          }
          for (var j = 0,
              jl = faceVertexNormals.length; j < jl; j++) {
            normal = faceVertexNormals[j].clone();
            if (normalMatrix !== undefined) {
              normal.applyMatrix3(normalMatrix).normalize();
            }
            faceCopy.vertexNormals.push(normal);
          }
          faceCopy.color.copy(face.color);
          for (var j = 0,
              jl = faceVertexColors.length; j < jl; j++) {
            color = faceVertexColors[j];
            faceCopy.vertexColors.push(color.clone());
          }
          faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
          faces1.push(faceCopy);
        }
        for (i = 0, il = uvs2.length; i < il; i++) {
          var uv = uvs2[i],
              uvCopy = [];
          if (uv === undefined) {
            continue;
          }
          for (var j = 0,
              jl = uv.length; j < jl; j++) {
            uvCopy.push(uv[j].clone());
          }
          uvs1.push(uvCopy);
        }
      },
      mergeMesh: function(mesh) {
        if (mesh instanceof THREE.Mesh === false) {
          console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
          return;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
      },
      mergeVertices: function() {
        var verticesMap = {};
        var unique = [],
            changes = [];
        var v,
            key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i,
            il,
            face;
        var indices,
            j,
            jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
          v = this.vertices[i];
          key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
          if (verticesMap[key] === undefined) {
            verticesMap[key] = i;
            unique.push(this.vertices[i]);
            changes[i] = unique.length - 1;
          } else {
            changes[i] = changes[verticesMap[key]];
          }
        }
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
          face = this.faces[i];
          face.a = changes[face.a];
          face.b = changes[face.b];
          face.c = changes[face.c];
          indices = [face.a, face.b, face.c];
          var dupIndex = -1;
          for (var n = 0; n < 3; n++) {
            if (indices[n] === indices[(n + 1) % 3]) {
              dupIndex = n;
              faceIndicesToRemove.push(i);
              break;
            }
          }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
          var idx = faceIndicesToRemove[i];
          this.faces.splice(idx, 1);
          for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
            this.faceVertexUvs[j].splice(idx, 1);
          }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
      },
      sortFacesByMaterialIndex: function() {
        var faces = this.faces;
        var length = faces.length;
        for (var i = 0; i < length; i++) {
          faces[i]._id = i;
        }
        function materialIndexSort(a, b) {
          return a.materialIndex - b.materialIndex;
        }
        faces.sort(materialIndexSort);
        var uvs1 = this.faceVertexUvs[0];
        var uvs2 = this.faceVertexUvs[1];
        var newUvs1,
            newUvs2;
        if (uvs1 && uvs1.length === length)
          newUvs1 = [];
        if (uvs2 && uvs2.length === length)
          newUvs2 = [];
        for (var i = 0; i < length; i++) {
          var id = faces[i]._id;
          if (newUvs1)
            newUvs1.push(uvs1[id]);
          if (newUvs2)
            newUvs2.push(uvs2[id]);
        }
        if (newUvs1)
          this.faceVertexUvs[0] = newUvs1;
        if (newUvs2)
          this.faceVertexUvs[1] = newUvs2;
      },
      toJSON: function() {
        var data = {metadata: {
            version: 4.4,
            type: 'Geometry',
            generator: 'Geometry.toJSON'
          }};
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
          data.name = this.name;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined)
              data[key] = parameters[key];
          }
          return data;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
          var vertex = this.vertices[i];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
          var face = this.faces[i];
          var hasMaterial = false;
          var hasFaceUv = false;
          var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
          var hasFaceNormal = face.normal.length() > 0;
          var hasFaceVertexNormal = face.vertexNormals.length > 0;
          var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
          var hasFaceVertexColor = face.vertexColors.length > 0;
          var faceType = 0;
          faceType = setBit(faceType, 0, 0);
          faceType = setBit(faceType, 1, hasMaterial);
          faceType = setBit(faceType, 2, hasFaceUv);
          faceType = setBit(faceType, 3, hasFaceVertexUv);
          faceType = setBit(faceType, 4, hasFaceNormal);
          faceType = setBit(faceType, 5, hasFaceVertexNormal);
          faceType = setBit(faceType, 6, hasFaceColor);
          faceType = setBit(faceType, 7, hasFaceVertexColor);
          faces.push(faceType);
          faces.push(face.a, face.b, face.c);
          if (hasFaceVertexUv) {
            var faceVertexUvs = this.faceVertexUvs[0][i];
            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
          }
          if (hasFaceNormal) {
            faces.push(getNormalIndex(face.normal));
          }
          if (hasFaceVertexNormal) {
            var vertexNormals = face.vertexNormals;
            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
          }
          if (hasFaceColor) {
            faces.push(getColorIndex(face.color));
          }
          if (hasFaceVertexColor) {
            var vertexColors = face.vertexColors;
            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
          }
        }
        function setBit(value, position, enabled) {
          return enabled ? value | (1 << position) : value & (~(1 << position));
        }
        function getNormalIndex(normal) {
          var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
          if (normalsHash[hash] !== undefined) {
            return normalsHash[hash];
          }
          normalsHash[hash] = normals.length / 3;
          normals.push(normal.x, normal.y, normal.z);
          return normalsHash[hash];
        }
        function getColorIndex(color) {
          var hash = color.r.toString() + color.g.toString() + color.b.toString();
          if (colorsHash[hash] !== undefined) {
            return colorsHash[hash];
          }
          colorsHash[hash] = colors.length;
          colors.push(color.getHex());
          return colorsHash[hash];
        }
        function getUvIndex(uv) {
          var hash = uv.x.toString() + uv.y.toString();
          if (uvsHash[hash] !== undefined) {
            return uvsHash[hash];
          }
          uvsHash[hash] = uvs.length / 2;
          uvs.push(uv.x, uv.y);
          return uvsHash[hash];
        }
        data.data = {};
        data.data.vertices = vertices;
        data.data.normals = normals;
        if (colors.length > 0)
          data.data.colors = colors;
        if (uvs.length > 0)
          data.data.uvs = [uvs];
        data.data.faces = faces;
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.vertices = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        var vertices = source.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          this.vertices.push(vertices[i].clone());
        }
        var faces = source.faces;
        for (var i = 0,
            il = faces.length; i < il; i++) {
          this.faces.push(faces[i].clone());
        }
        for (var i = 0,
            il = source.faceVertexUvs.length; i < il; i++) {
          var faceVertexUvs = source.faceVertexUvs[i];
          if (this.faceVertexUvs[i] === undefined) {
            this.faceVertexUvs[i] = [];
          }
          for (var j = 0,
              jl = faceVertexUvs.length; j < jl; j++) {
            var uvs = faceVertexUvs[j],
                uvsCopy = [];
            for (var k = 0,
                kl = uvs.length; k < kl; k++) {
              var uv = uvs[k];
              uvsCopy.push(uv.clone());
            }
            this.faceVertexUvs[i].push(uvsCopy);
          }
        }
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
    THREE.GeometryIdCount = 0;
    THREE.DirectGeometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'DirectGeometry';
      this.indices = [];
      this.vertices = [];
      this.normals = [];
      this.colors = [];
      this.uvs = [];
      this.uvs2 = [];
      this.groups = [];
      this.morphTargets = {};
      this.skinWeights = [];
      this.skinIndices = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.verticesNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.groupsNeedUpdate = false;
    };
    THREE.DirectGeometry.prototype = {
      constructor: THREE.DirectGeometry,
      computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
      computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
      computeFaceNormals: function() {
        console.warn('THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.');
      },
      computeVertexNormals: function() {
        console.warn('THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.');
      },
      computeGroups: function(geometry) {
        var group;
        var groups = [];
        var materialIndex;
        var faces = geometry.faces;
        for (var i = 0; i < faces.length; i++) {
          var face = faces[i];
          if (face.materialIndex !== materialIndex) {
            materialIndex = face.materialIndex;
            if (group !== undefined) {
              group.count = (i * 3) - group.start;
              groups.push(group);
            }
            group = {
              start: i * 3,
              materialIndex: materialIndex
            };
          }
        }
        if (group !== undefined) {
          group.count = (i * 3) - group.start;
          groups.push(group);
        }
        this.groups = groups;
      },
      fromGeometry: function(geometry) {
        var faces = geometry.faces;
        var vertices = geometry.vertices;
        var faceVertexUvs = geometry.faceVertexUvs;
        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        var morphTargets = geometry.morphTargets;
        var morphTargetsLength = morphTargets.length;
        if (morphTargetsLength > 0) {
          var morphTargetsPosition = [];
          for (var i = 0; i < morphTargetsLength; i++) {
            morphTargetsPosition[i] = [];
          }
          this.morphTargets.position = morphTargetsPosition;
        }
        var morphNormals = geometry.morphNormals;
        var morphNormalsLength = morphNormals.length;
        if (morphNormalsLength > 0) {
          var morphTargetsNormal = [];
          for (var i = 0; i < morphNormalsLength; i++) {
            morphTargetsNormal[i] = [];
          }
          this.morphTargets.normal = morphTargetsNormal;
        }
        var skinIndices = geometry.skinIndices;
        var skinWeights = geometry.skinWeights;
        var hasSkinIndices = skinIndices.length === vertices.length;
        var hasSkinWeights = skinWeights.length === vertices.length;
        for (var i = 0; i < faces.length; i++) {
          var face = faces[i];
          this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
          var vertexNormals = face.vertexNormals;
          if (vertexNormals.length === 3) {
            this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
          } else {
            var normal = face.normal;
            this.normals.push(normal, normal, normal);
          }
          var vertexColors = face.vertexColors;
          if (vertexColors.length === 3) {
            this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
          } else {
            var color = face.color;
            this.colors.push(color, color, color);
          }
          if (hasFaceVertexUv === true) {
            var vertexUvs = faceVertexUvs[0][i];
            if (vertexUvs !== undefined) {
              this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
              this.uvs.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
            }
          }
          if (hasFaceVertexUv2 === true) {
            var vertexUvs = faceVertexUvs[1][i];
            if (vertexUvs !== undefined) {
              this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
            } else {
              console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
              this.uvs2.push(new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2());
            }
          }
          for (var j = 0; j < morphTargetsLength; j++) {
            var morphTarget = morphTargets[j].vertices;
            morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
          }
          for (var j = 0; j < morphNormalsLength; j++) {
            var morphNormal = morphNormals[j].vertexNormals[i];
            morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
          }
          if (hasSkinIndices) {
            this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
          }
          if (hasSkinWeights) {
            this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
          }
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype);
    THREE.BufferGeometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'BufferGeometry';
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = {
        start: 0,
        count: Infinity
      };
    };
    THREE.BufferGeometry.prototype = {
      constructor: THREE.BufferGeometry,
      addIndex: function(index) {
        console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
        this.setIndex(index);
      },
      getIndex: function() {
        return this.index;
      },
      setIndex: function(index) {
        this.index = index;
      },
      addAttribute: function(name, attribute) {
        if (attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false) {
          console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
          this.addAttribute(name, new THREE.BufferAttribute(arguments[1], arguments[2]));
          return;
        }
        if (name === 'index') {
          console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
          this.setIndex(attribute);
          return;
        }
        this.attributes[name] = attribute;
      },
      getAttribute: function(name) {
        return this.attributes[name];
      },
      removeAttribute: function(name) {
        delete this.attributes[name];
      },
      get drawcalls() {
        console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
        return this.groups;
      },
      get offsets() {
        console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
        return this.groups;
      },
      addDrawCall: function(start, count, indexOffset) {
        if (indexOffset !== undefined) {
          console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
        }
        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
        this.addGroup(start, count);
      },
      clearDrawCalls: function() {
        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
        this.clearGroups();
      },
      addGroup: function(start, count, materialIndex) {
        this.groups.push({
          start: start,
          count: count,
          materialIndex: materialIndex !== undefined ? materialIndex : 0
        });
      },
      clearGroups: function() {
        this.groups = [];
      },
      setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      },
      applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
          matrix.applyToVector3Array(position.array);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
          var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
          normalMatrix.applyToVector3Array(normal.array);
          normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
      },
      rotateX: function() {
        var m1;
        return function rotateX(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationX(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateY: function() {
        var m1;
        return function rotateY(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationY(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      rotateZ: function() {
        var m1;
        return function rotateZ(angle) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeRotationZ(angle);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      translate: function() {
        var m1;
        return function translate(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeTranslation(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      scale: function() {
        var m1;
        return function scale(x, y, z) {
          if (m1 === undefined)
            m1 = new THREE.Matrix4();
          m1.makeScale(x, y, z);
          this.applyMatrix(m1);
          return this;
        };
      }(),
      lookAt: function() {
        var obj;
        return function lookAt(vector) {
          if (obj === undefined)
            obj = new THREE.Object3D();
          obj.lookAt(vector);
          obj.updateMatrix();
          this.applyMatrix(obj.matrix);
        };
      }(),
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.translate(offset.x, offset.y, offset.z);
        return offset;
      },
      setFromObject: function(object) {
        var geometry = object.geometry;
        if (object instanceof THREE.Points || object instanceof THREE.Line) {
          var positions = new THREE.Float32Attribute(geometry.vertices.length * 3, 3);
          var colors = new THREE.Float32Attribute(geometry.colors.length * 3, 3);
          this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
          this.addAttribute('color', colors.copyColorsArray(geometry.colors));
          if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
            var lineDistances = new THREE.Float32Attribute(geometry.lineDistances.length, 1);
            this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
          }
          if (geometry.boundingSphere !== null) {
            this.boundingSphere = geometry.boundingSphere.clone();
          }
          if (geometry.boundingBox !== null) {
            this.boundingBox = geometry.boundingBox.clone();
          }
        } else if (object instanceof THREE.Mesh) {
          if (geometry instanceof THREE.Geometry) {
            this.fromGeometry(geometry);
          }
        }
        return this;
      },
      updateFromObject: function(object) {
        var geometry = object.geometry;
        if (object instanceof THREE.Mesh) {
          var direct = geometry.__directGeometry;
          if (direct === undefined) {
            return this.fromGeometry(geometry);
          }
          direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
          direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
          direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
          direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
          direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
          geometry.verticesNeedUpdate = false;
          geometry.normalsNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.uvsNeedUpdate = false;
          geometry.groupsNeedUpdate = false;
          geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
          var attribute = this.attributes.position;
          if (attribute !== undefined) {
            attribute.copyVector3sArray(geometry.vertices);
            attribute.needsUpdate = true;
          }
          geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
          var attribute = this.attributes.normal;
          if (attribute !== undefined) {
            attribute.copyVector3sArray(geometry.normals);
            attribute.needsUpdate = true;
          }
          geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
          var attribute = this.attributes.color;
          if (attribute !== undefined) {
            attribute.copyColorsArray(geometry.colors);
            attribute.needsUpdate = true;
          }
          geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
          var attribute = this.attributes.uv;
          if (attribute !== undefined) {
            attribute.copyVector2sArray(geometry.uvs);
            attribute.needsUpdate = true;
          }
          geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
          var attribute = this.attributes.lineDistance;
          if (attribute !== undefined) {
            attribute.copyArray(geometry.lineDistances);
            attribute.needsUpdate = true;
          }
          geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
          geometry.computeGroups(object.geometry);
          this.groups = geometry.groups;
          geometry.groupsNeedUpdate = false;
        }
        return this;
      },
      fromGeometry: function(geometry) {
        geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
      },
      fromDirectGeometry: function(geometry) {
        var positions = new Float32Array(geometry.vertices.length * 3);
        this.addAttribute('position', new THREE.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
          var normals = new Float32Array(geometry.normals.length * 3);
          this.addAttribute('normal', new THREE.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
          var colors = new Float32Array(geometry.colors.length * 3);
          this.addAttribute('color', new THREE.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
          var uvs = new Float32Array(geometry.uvs.length * 2);
          this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
          var uvs2 = new Float32Array(geometry.uvs2.length * 2);
          this.addAttribute('uv2', new THREE.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        if (geometry.indices.length > 0) {
          var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
          var indices = new TypeArray(geometry.indices.length * 3);
          this.setIndex(new THREE.BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
        }
        this.groups = geometry.groups;
        for (var name in geometry.morphTargets) {
          var array = [];
          var morphTargets = geometry.morphTargets[name];
          for (var i = 0,
              l = morphTargets.length; i < l; i++) {
            var morphTarget = morphTargets[i];
            var attribute = new THREE.Float32Attribute(morphTarget.length * 3, 3);
            array.push(attribute.copyVector3sArray(morphTarget));
          }
          this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
          var skinIndices = new THREE.Float32Attribute(geometry.skinIndices.length * 4, 4);
          this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
          var skinWeights = new THREE.Float32Attribute(geometry.skinWeights.length * 4, 4);
          this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        return this;
      },
      computeBoundingBox: function() {
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingBox === null) {
            this.boundingBox = new THREE.Box3();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            var bb = this.boundingBox;
            bb.makeEmpty();
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.fromArray(positions, i);
              bb.expandByPoint(vector);
            }
          }
          if (positions === undefined || positions.length === 0) {
            this.boundingBox.min.set(0, 0, 0);
            this.boundingBox.max.set(0, 0, 0);
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
          }
        };
      }(),
      computeBoundingSphere: function() {
        var box = new THREE.Box3();
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            box.makeEmpty();
            var center = this.boundingSphere.center;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.fromArray(positions, i);
              box.expandByPoint(vector);
            }
            box.center(center);
            var maxRadiusSq = 0;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.fromArray(positions, i);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
          }
        };
      }(),
      computeFaceNormals: function() {},
      computeVertexNormals: function() {
        var index = this.index;
        var attributes = this.attributes;
        var groups = this.groups;
        if (attributes.position) {
          var positions = attributes.position.array;
          if (attributes.normal === undefined) {
            this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
          } else {
            var normals = attributes.normal.array;
            for (var i = 0,
                il = normals.length; i < il; i++) {
              normals[i] = 0;
            }
          }
          var normals = attributes.normal.array;
          var vA,
              vB,
              vC,
              pA = new THREE.Vector3(),
              pB = new THREE.Vector3(),
              pC = new THREE.Vector3(),
              cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          if (index) {
            var indices = index.array;
            if (groups.length === 0) {
              this.addGroup(0, indices.length);
            }
            for (var j = 0,
                jl = groups.length; j < jl; ++j) {
              var group = groups[j];
              var start = group.start;
              var count = group.count;
              for (var i = start,
                  il = start + count; i < il; i += 3) {
                vA = indices[i + 0] * 3;
                vB = indices[i + 1] * 3;
                vC = indices[i + 2] * 3;
                pA.fromArray(positions, vA);
                pB.fromArray(positions, vB);
                pC.fromArray(positions, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normals[vA] += cb.x;
                normals[vA + 1] += cb.y;
                normals[vA + 2] += cb.z;
                normals[vB] += cb.x;
                normals[vB + 1] += cb.y;
                normals[vB + 2] += cb.z;
                normals[vC] += cb.x;
                normals[vC + 1] += cb.y;
                normals[vC + 2] += cb.z;
              }
            }
          } else {
            for (var i = 0,
                il = positions.length; i < il; i += 9) {
              pA.fromArray(positions, i);
              pB.fromArray(positions, i + 3);
              pC.fromArray(positions, i + 6);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[i] = cb.x;
              normals[i + 1] = cb.y;
              normals[i + 2] = cb.z;
              normals[i + 3] = cb.x;
              normals[i + 4] = cb.y;
              normals[i + 5] = cb.z;
              normals[i + 6] = cb.x;
              normals[i + 7] = cb.y;
              normals[i + 8] = cb.z;
            }
          }
          this.normalizeNormals();
          attributes.normal.needsUpdate = true;
        }
      },
      computeTangents: function() {
        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
      },
      computeOffsets: function(size) {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
      },
      merge: function(geometry, offset) {
        if (geometry instanceof THREE.BufferGeometry === false) {
          console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
          return;
        }
        if (offset === undefined)
          offset = 0;
        var attributes = this.attributes;
        for (var key in attributes) {
          if (geometry.attributes[key] === undefined)
            continue;
          var attribute1 = attributes[key];
          var attributeArray1 = attribute1.array;
          var attribute2 = geometry.attributes[key];
          var attributeArray2 = attribute2.array;
          var attributeSize = attribute2.itemSize;
          for (var i = 0,
              j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
            attributeArray1[j] = attributeArray2[i];
          }
        }
        return this;
      },
      normalizeNormals: function() {
        var normals = this.attributes.normal.array;
        var x,
            y,
            z,
            n;
        for (var i = 0,
            il = normals.length; i < il; i += 3) {
          x = normals[i];
          y = normals[i + 1];
          z = normals[i + 2];
          n = 1.0 / Math.sqrt(x * x + y * y + z * z);
          normals[i] *= n;
          normals[i + 1] *= n;
          normals[i + 2] *= n;
        }
      },
      toJSON: function() {
        var data = {metadata: {
            version: 4.4,
            type: 'BufferGeometry',
            generator: 'BufferGeometry.toJSON'
          }};
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
          data.name = this.name;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = {attributes: {}};
        var index = this.index;
        if (index !== null) {
          var array = Array.prototype.slice.call(index.array);
          data.data.index = {
            type: index.array.constructor.name,
            array: array
          };
        }
        var attributes = this.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var array = Array.prototype.slice.call(attribute.array);
          data.data.attributes[key] = {
            itemSize: attribute.itemSize,
            type: attribute.array.constructor.name,
            array: array
          };
        }
        var groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        var index = source.index;
        if (index !== null) {
          this.setIndex(index.clone());
        }
        var attributes = source.attributes;
        for (var name in attributes) {
          var attribute = attributes[name];
          this.addAttribute(name, attribute.clone());
        }
        var groups = source.groups;
        for (var i = 0,
            l = groups.length; i < l; i++) {
          var group = groups[i];
          this.addGroup(group.start, group.count);
        }
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
    THREE.BufferGeometry.MaxIndex = 65535;
    THREE.InstancedBufferGeometry = function() {
      THREE.BufferGeometry.call(this);
      this.type = 'InstancedBufferGeometry';
      this.maxInstancedCount = undefined;
    };
    THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
    THREE.InstancedBufferGeometry.prototype.addGroup = function(start, count, instances) {
      this.groups.push({
        start: start,
        count: count,
        instances: instances
      });
    };
    THREE.InstancedBufferGeometry.prototype.copy = function(source) {
      var index = source.index;
      if (index !== null) {
        this.setIndex(index.clone());
      }
      var attributes = source.attributes;
      for (var name in attributes) {
        var attribute = attributes[name];
        this.addAttribute(name, attribute.clone());
      }
      var groups = source.groups;
      for (var i = 0,
          l = groups.length; i < l; i++) {
        var group = groups[i];
        this.addGroup(group.start, group.count, group.instances);
      }
      return this;
    };
    THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype);
    THREE.AnimationAction = function(clip, startTime, timeScale, weight, loop) {
      if (clip === undefined)
        throw new Error('clip is null');
      this.clip = clip;
      this.localRoot = null;
      this.startTime = startTime || 0;
      this.timeScale = timeScale || 1;
      this.weight = weight || 1;
      this.loop = loop || THREE.LoopRepeat;
      this.loopCount = 0;
      this.enabled = true;
      this.actionTime = -this.startTime;
      this.clipTime = 0;
      this.propertyBindings = [];
    };
    THREE.AnimationAction.prototype = {
      constructor: THREE.AnimationAction,
      setLocalRoot: function(localRoot) {
        this.localRoot = localRoot;
        return this;
      },
      updateTime: function(clipDeltaTime) {
        var previousClipTime = this.clipTime;
        var previousLoopCount = this.loopCount;
        var previousActionTime = this.actionTime;
        var duration = this.clip.duration;
        this.actionTime = this.actionTime + clipDeltaTime;
        if (this.loop === THREE.LoopOnce) {
          this.loopCount = 0;
          this.clipTime = Math.min(Math.max(this.actionTime, 0), duration);
          if (this.clipTime !== previousClipTime) {
            if (this.clipTime === duration) {
              this.mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: 1
              });
            } else if (this.clipTime === 0) {
              this.mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: -1
              });
            }
          }
          return this.clipTime;
        }
        this.loopCount = Math.floor(this.actionTime / duration);
        var newClipTime = this.actionTime - this.loopCount * duration;
        newClipTime = newClipTime % duration;
        if (this.loop == THREE.LoopPingPong) {
          if (Math.abs(this.loopCount % 2) === 1) {
            newClipTime = duration - newClipTime;
          }
        }
        this.clipTime = newClipTime;
        if (this.loopCount !== previousLoopCount) {
          this.mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: (this.loopCount - this.loopCount)
          });
        }
        return this.clipTime;
      },
      syncWith: function(action) {
        this.actionTime = action.actionTime;
        this.timeScale = action.timeScale;
        return this;
      },
      warpToDuration: function(duration) {
        this.timeScale = this.clip.duration / duration;
        return this;
      },
      init: function(time) {
        this.clipTime = time - this.startTime;
        return this;
      },
      update: function(clipDeltaTime) {
        this.updateTime(clipDeltaTime);
        var clipResults = this.clip.getAt(this.clipTime);
        return clipResults;
      },
      getTimeScaleAt: function(time) {
        if (this.timeScale.getAt) {
          return this.timeScale.getAt(time);
        }
        return this.timeScale;
      },
      getWeightAt: function(time) {
        if (this.weight.getAt) {
          return this.weight.getAt(time);
        }
        return this.weight;
      }
    };
    THREE.AnimationClip = function(name, duration, tracks) {
      this.name = name;
      this.tracks = tracks;
      this.duration = (duration !== undefined) ? duration : -1;
      if (this.duration < 0) {
        for (var i = 0; i < this.tracks.length; i++) {
          var track = this.tracks[i];
          this.duration = Math.max(track.keys[track.keys.length - 1].time);
        }
      }
      this.trim();
      this.optimize();
      this.results = [];
    };
    THREE.AnimationClip.prototype = {
      constructor: THREE.AnimationClip,
      getAt: function(clipTime) {
        clipTime = Math.max(0, Math.min(clipTime, this.duration));
        for (var i = 0; i < this.tracks.length; i++) {
          var track = this.tracks[i];
          this.results[i] = track.getAt(clipTime);
        }
        return this.results;
      },
      trim: function() {
        for (var i = 0; i < this.tracks.length; i++) {
          this.tracks[i].trim(0, this.duration);
        }
        return this;
      },
      optimize: function() {
        for (var i = 0; i < this.tracks.length; i++) {
          this.tracks[i].optimize();
        }
        return this;
      }
    };
    THREE.AnimationClip.CreateFromMorphTargetSequence = function(name, morphTargetSequence, fps) {
      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];
      for (var i = 0; i < numMorphTargets; i++) {
        var keys = [];
        keys.push({
          time: (i + numMorphTargets - 1) % numMorphTargets,
          value: 0
        });
        keys.push({
          time: i,
          value: 1
        });
        keys.push({
          time: (i + 1) % numMorphTargets,
          value: 0
        });
        keys.sort(THREE.KeyframeTrack.keyComparer);
        if (keys[0].time === 0) {
          keys.push({
            time: numMorphTargets,
            value: keys[0].value
          });
        }
        tracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', keys).scale(1.0 / fps));
      }
      return new THREE.AnimationClip(name, -1, tracks);
    };
    THREE.AnimationClip.findByName = function(clipArray, name) {
      for (var i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    };
    THREE.AnimationClip.CreateClipsFromMorphTargetSequences = function(morphTargets, fps) {
      var animationToMorphTargets = {};
      var pattern = /^([\w-]*?)([\d]+)$/;
      for (var i = 0,
          il = morphTargets.length; i < il; i++) {
        var morphTarget = morphTargets[i];
        var parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          var name = parts[1];
          var animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      var clips = [];
      for (var name in animationToMorphTargets) {
        clips.push(THREE.AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps));
      }
      return clips;
    };
    THREE.AnimationClip.parse = function(json) {
      var tracks = [];
      for (var i = 0; i < json.tracks.length; i++) {
        tracks.push(THREE.KeyframeTrack.parse(json.tracks[i]).scale(1.0 / json.fps));
      }
      return new THREE.AnimationClip(json.name, json.duration, tracks);
    };
    THREE.AnimationClip.parseAnimation = function(animation, bones, nodeName) {
      if (!animation) {
        console.error("  no animation in JSONLoader data");
        return null;
      }
      var convertTrack = function(trackName, animationKeys, propertyName, trackType, animationKeyToValueFunc) {
        var keys = [];
        for (var k = 0; k < animationKeys.length; k++) {
          var animationKey = animationKeys[k];
          if (animationKey[propertyName] !== undefined) {
            keys.push({
              time: animationKey.time,
              value: animationKeyToValueFunc(animationKey)
            });
          }
        }
        if (keys.length > 0) {
          return new trackType(trackName, keys);
        }
        return null;
      };
      var tracks = [];
      var clipName = animation.name || 'default';
      var duration = animation.length || -1;
      var fps = animation.fps || 30;
      var hierarchyTracks = animation.hierarchy || [];
      for (var h = 0; h < hierarchyTracks.length; h++) {
        var animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length == 0) {
          continue;
        }
        if (animationKeys[0].morphTargets) {
          var morphTargetNames = {};
          for (var k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }
          for (var morphTargetName in morphTargetNames) {
            var keys = [];
            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
              var animationKey = animationKeys[k];
              keys.push({
                time: animationKey.time,
                value: ((animationKey.morphTarget === morphTargetName) ? 1 : 0)
              });
            }
            tracks.push(new THREE.NumberKeyframeTrack(nodeName + '.morphTargetInfluence[' + morphTargetName + ']', keys));
          }
          duration = morphTargetNames.length * (fps || 1.0);
        } else {
          var boneName = nodeName + '.bones[' + bones[h].name + ']';
          var positionTrack = convertTrack(boneName + '.position', animationKeys, 'pos', THREE.VectorKeyframeTrack, function(animationKey) {
            return new THREE.Vector3().fromArray(animationKey.pos);
          });
          if (positionTrack)
            tracks.push(positionTrack);
          var quaternionTrack = convertTrack(boneName + '.quaternion', animationKeys, 'rot', THREE.QuaternionKeyframeTrack, function(animationKey) {
            if (animationKey.rot.slerp) {
              return animationKey.rot.clone();
            } else {
              return new THREE.Quaternion().fromArray(animationKey.rot);
            }
          });
          if (quaternionTrack)
            tracks.push(quaternionTrack);
          var scaleTrack = convertTrack(boneName + '.scale', animationKeys, 'scl', THREE.VectorKeyframeTrack, function(animationKey) {
            return new THREE.Vector3().fromArray(animationKey.scl);
          });
          if (scaleTrack)
            tracks.push(scaleTrack);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      var clip = new THREE.AnimationClip(clipName, duration, tracks);
      return clip;
    };
    THREE.AnimationMixer = function(root) {
      this.root = root;
      this.time = 0;
      this.timeScale = 1.0;
      this.actions = [];
      this.propertyBindingMap = {};
    };
    THREE.AnimationMixer.prototype = {
      constructor: THREE.AnimationMixer,
      addAction: function(action) {
        this.actions.push(action);
        action.init(this.time);
        action.mixer = this;
        var tracks = action.clip.tracks;
        var root = action.localRoot || this.root;
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          var propertyBindingKey = root.uuid + '-' + track.name;
          var propertyBinding = this.propertyBindingMap[propertyBindingKey];
          if (propertyBinding === undefined) {
            propertyBinding = new THREE.PropertyBinding(root, track.name);
            this.propertyBindingMap[propertyBindingKey] = propertyBinding;
          }
          action.propertyBindings.push(propertyBinding);
          propertyBinding.referenceCount += 1;
        }
      },
      removeAllActions: function() {
        for (var i = 0; i < this.actions.length; i++) {
          this.actions[i].mixer = null;
        }
        for (var properyBindingKey in this.propertyBindingMap) {
          this.propertyBindingMap[properyBindingKey].unbind();
        }
        this.actions = [];
        this.propertyBindingMap = {};
        return this;
      },
      removeAction: function(action) {
        var index = this.actions.indexOf(action);
        if (index !== -1) {
          this.actions.splice(index, 1);
          action.mixer = null;
        }
        var root = action.localRoot || this.root;
        var tracks = action.clip.tracks;
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          var propertyBindingKey = root.uuid + '-' + track.name;
          var propertyBinding = this.propertyBindingMap[propertyBindingKey];
          propertyBinding.referenceCount -= 1;
          if (propertyBinding.referenceCount <= 0) {
            propertyBinding.unbind();
            delete this.propertyBindingMap[propertyBindingKey];
          }
        }
        return this;
      },
      findActionByName: function(name) {
        for (var i = 0; i < this.actions.length; i++) {
          if (this.actions[i].name === name)
            return this.actions[i];
        }
        return null;
      },
      play: function(action, optionalFadeInDuration) {
        action.startTime = this.time;
        this.addAction(action);
        return this;
      },
      fadeOut: function(action, duration) {
        var keys = [];
        keys.push({
          time: this.time,
          value: 1
        });
        keys.push({
          time: this.time + duration,
          value: 0
        });
        action.weight = new THREE.NumberKeyframeTrack("weight", keys);
        return this;
      },
      fadeIn: function(action, duration) {
        var keys = [];
        keys.push({
          time: this.time,
          value: 0
        });
        keys.push({
          time: this.time + duration,
          value: 1
        });
        action.weight = new THREE.NumberKeyframeTrack("weight", keys);
        return this;
      },
      warp: function(action, startTimeScale, endTimeScale, duration) {
        var keys = [];
        keys.push({
          time: this.time,
          value: startTimeScale
        });
        keys.push({
          time: this.time + duration,
          value: endTimeScale
        });
        action.timeScale = new THREE.NumberKeyframeTrack("timeScale", keys);
        return this;
      },
      crossFade: function(fadeOutAction, fadeInAction, duration, warp) {
        this.fadeOut(fadeOutAction, duration);
        this.fadeIn(fadeInAction, duration);
        if (warp) {
          var startEndRatio = fadeOutAction.clip.duration / fadeInAction.clip.duration;
          var endStartRatio = 1.0 / startEndRatio;
          this.warp(fadeOutAction, 1.0, startEndRatio, duration);
          this.warp(fadeInAction, endStartRatio, 1.0, duration);
        }
        return this;
      },
      update: function(deltaTime) {
        var mixerDeltaTime = deltaTime * this.timeScale;
        this.time += mixerDeltaTime;
        for (var i = 0; i < this.actions.length; i++) {
          var action = this.actions[i];
          var weight = action.getWeightAt(this.time);
          var actionTimeScale = action.getTimeScaleAt(this.time);
          var actionDeltaTime = mixerDeltaTime * actionTimeScale;
          var actionResults = action.update(actionDeltaTime);
          if (action.weight <= 0 || !action.enabled)
            continue;
          for (var j = 0; j < actionResults.length; j++) {
            var name = action.clip.tracks[j].name;
            action.propertyBindings[j].accumulate(actionResults[j], weight);
          }
        }
        for (var propertyBindingKey in this.propertyBindingMap) {
          this.propertyBindingMap[propertyBindingKey].apply();
        }
        return this;
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype);
    THREE.AnimationUtils = {
      getEqualsFunc: function(exemplarValue) {
        if (exemplarValue.equals) {
          return function equals_object(a, b) {
            return a.equals(b);
          };
        }
        return function equals_primitive(a, b) {
          return (a === b);
        };
      },
      clone: function(exemplarValue) {
        var typeName = typeof exemplarValue;
        if (typeName === "object") {
          if (exemplarValue.clone) {
            return exemplarValue.clone();
          }
          console.error("can not figure out how to copy exemplarValue", exemplarValue);
        }
        return exemplarValue;
      },
      lerp: function(a, b, alpha, interTrack) {
        var lerpFunc = THREE.AnimationUtils.getLerpFunc(a, interTrack);
        return lerpFunc(a, b, alpha);
      },
      lerp_object: function(a, b, alpha) {
        return a.lerp(b, alpha);
      },
      slerp_object: function(a, b, alpha) {
        return a.slerp(b, alpha);
      },
      lerp_number: function(a, b, alpha) {
        return a * (1 - alpha) + b * alpha;
      },
      lerp_boolean: function(a, b, alpha) {
        return (alpha < 0.5) ? a : b;
      },
      lerp_boolean_immediate: function(a, b, alpha) {
        return a;
      },
      lerp_string: function(a, b, alpha) {
        return (alpha < 0.5) ? a : b;
      },
      lerp_string_immediate: function(a, b, alpha) {
        return a;
      },
      getLerpFunc: function(exemplarValue, interTrack) {
        if (exemplarValue === undefined || exemplarValue === null)
          throw new Error("examplarValue is null");
        var typeName = typeof exemplarValue;
        switch (typeName) {
          case "object":
            if (exemplarValue.lerp) {
              return THREE.AnimationUtils.lerp_object;
            }
            if (exemplarValue.slerp) {
              return THREE.AnimationUtils.slerp_object;
            }
            break;
          case "number":
            return THREE.AnimationUtils.lerp_number;
          case "boolean":
            if (interTrack) {
              return THREE.AnimationUtils.lerp_boolean;
            } else {
              return THREE.AnimationUtils.lerp_boolean_immediate;
            }
          case "string":
            if (interTrack) {
              return THREE.AnimationUtils.lerp_string;
            } else {
              return THREE.AnimationUtils.lerp_string_immediate;
            }
        }
      }
    };
    THREE.KeyframeTrack = function(name, keys) {
      if (name === undefined)
        throw new Error("track name is undefined");
      if (keys === undefined || keys.length === 0)
        throw new Error("no keys in track named " + name);
      this.name = name;
      this.keys = keys;
      this.lastIndex = 0;
      this.validate();
      this.optimize();
    };
    THREE.KeyframeTrack.prototype = {
      constructor: THREE.KeyframeTrack,
      getAt: function(time) {
        while ((this.lastIndex < this.keys.length) && (time >= this.keys[this.lastIndex].time)) {
          this.lastIndex++;
        }
        ;
        while ((this.lastIndex > 0) && (time < this.keys[this.lastIndex - 1].time)) {
          this.lastIndex--;
        }
        if (this.lastIndex >= this.keys.length) {
          this.setResult(this.keys[this.keys.length - 1].value);
          return this.result;
        }
        if (this.lastIndex === 0) {
          this.setResult(this.keys[0].value);
          return this.result;
        }
        var prevKey = this.keys[this.lastIndex - 1];
        this.setResult(prevKey.value);
        if (prevKey.constantToNext) {
          return this.result;
        }
        var currentKey = this.keys[this.lastIndex];
        var alpha = (time - prevKey.time) / (currentKey.time - prevKey.time);
        this.result = this.lerpValues(this.result, currentKey.value, alpha);
        return this.result;
      },
      shift: function(timeOffset) {
        if (timeOffset !== 0.0) {
          for (var i = 0; i < this.keys.length; i++) {
            this.keys[i].time += timeOffset;
          }
        }
        return this;
      },
      scale: function(timeScale) {
        if (timeScale !== 1.0) {
          for (var i = 0; i < this.keys.length; i++) {
            this.keys[i].time *= timeScale;
          }
        }
        return this;
      },
      trim: function(startTime, endTime) {
        var firstKeysToRemove = 0;
        for (var i = 1; i < this.keys.length; i++) {
          if (this.keys[i] <= startTime) {
            firstKeysToRemove++;
          }
        }
        var lastKeysToRemove = 0;
        for (var i = this.keys.length - 2; i > 0; i++) {
          if (this.keys[i] >= endTime) {
            lastKeysToRemove++;
          } else {
            break;
          }
        }
        if ((firstKeysToRemove + lastKeysToRemove) > 0) {
          this.keys = this.keys.splice(firstKeysToRemove, this.keys.length - lastKeysToRemove - firstKeysToRemove);
          ;
        }
        return this;
      },
      validate: function() {
        var prevKey = null;
        if (this.keys.length === 0) {
          console.error("  track is empty, no keys", this);
          return;
        }
        for (var i = 0; i < this.keys.length; i++) {
          var currKey = this.keys[i];
          if (!currKey) {
            console.error("  key is null in track", this, i);
            return;
          }
          if ((typeof currKey.time) !== 'number' || isNaN(currKey.time)) {
            console.error("  key.time is not a valid number", this, i, currKey);
            return;
          }
          if (currKey.value === undefined || currKey.value === null) {
            console.error("  key.value is null in track", this, i, currKey);
            return;
          }
          if (prevKey && prevKey.time > currKey.time) {
            console.error("  key.time is less than previous key time, out of order keys", this, i, currKey, prevKey);
            return;
          }
          prevKey = currKey;
        }
        return this;
      },
      optimize: function() {
        var newKeys = [];
        var prevKey = this.keys[0];
        newKeys.push(prevKey);
        var equalsFunc = THREE.AnimationUtils.getEqualsFunc(prevKey.value);
        for (var i = 1; i < this.keys.length - 1; i++) {
          var currKey = this.keys[i];
          var nextKey = this.keys[i + 1];
          if ((prevKey.time === currKey.time)) {
            continue;
          }
          if (this.compareValues(prevKey.value, currKey.value) && this.compareValues(currKey.value, nextKey.value)) {
            continue;
          }
          prevKey.constantToNext = this.compareValues(prevKey.value, currKey.value);
          newKeys.push(currKey);
          prevKey = currKey;
        }
        newKeys.push(this.keys[this.keys.length - 1]);
        this.keys = newKeys;
        return this;
      }
    };
    THREE.KeyframeTrack.keyComparer = function keyComparator(key0, key1) {
      return key0.time - key1.time;
    };
    THREE.KeyframeTrack.parse = function(json) {
      if (json.type === undefined)
        throw new Error("track type undefined, can not parse");
      var trackType = THREE.KeyframeTrack.GetTrackTypeForTypeName(json.type);
      return trackType.parse(json);
    };
    THREE.KeyframeTrack.GetTrackTypeForTypeName = function(typeName) {
      switch (typeName.toLowerCase()) {
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return THREE.VectorKeyframeTrack;
        case "quaternion":
          return THREE.QuaternionKeyframeTrack;
        case "integer":
        case "scalar":
        case "double":
        case "float":
        case "number":
          return THREE.NumberKeyframeTrack;
        case "bool":
        case "boolean":
          return THREE.BooleanKeyframeTrack;
        case "string":
          return THREE.StringKeyframeTrack;
      }
      ;
      throw new Error("Unsupported typeName: " + typeName);
    };
    THREE.PropertyBinding = function(rootNode, trackName) {
      this.rootNode = rootNode;
      this.trackName = trackName;
      this.referenceCount = 0;
      this.originalValue = null;
      var parseResults = THREE.PropertyBinding.parseTrackName(trackName);
      this.directoryName = parseResults.directoryName;
      this.nodeName = parseResults.nodeName;
      this.objectName = parseResults.objectName;
      this.objectIndex = parseResults.objectIndex;
      this.propertyName = parseResults.propertyName;
      this.propertyIndex = parseResults.propertyIndex;
      this.node = THREE.PropertyBinding.findNode(rootNode, this.nodeName) || rootNode;
      this.cumulativeValue = null;
      this.cumulativeWeight = 0;
    };
    THREE.PropertyBinding.prototype = {
      constructor: THREE.PropertyBinding,
      reset: function() {
        this.cumulativeValue = null;
        this.cumulativeWeight = 0;
      },
      accumulate: function(value, weight) {
        if (!this.isBound)
          this.bind();
        if (this.cumulativeWeight === 0) {
          if (weight > 0) {
            if (this.cumulativeValue === null) {
              this.cumulativeValue = THREE.AnimationUtils.clone(value);
            }
            this.cumulativeWeight = weight;
          }
        } else {
          var lerpAlpha = weight / (this.cumulativeWeight + weight);
          this.cumulativeValue = this.lerpValue(this.cumulativeValue, value, lerpAlpha);
          this.cumulativeWeight += weight;
        }
      },
      unbind: function() {
        if (!this.isBound)
          return;
        this.setValue(this.originalValue);
        this.setValue = null;
        this.getValue = null;
        this.lerpValue = null;
        this.equalsValue = null;
        this.triggerDirty = null;
        this.isBound = false;
      },
      bind: function() {
        if (this.isBound)
          return;
        var targetObject = this.node;
        if (!targetObject) {
          console.error("  trying to update node for track: " + this.trackName + " but it wasn't found.");
          return;
        }
        if (this.objectName) {
          if (this.objectName === "materials") {
            if (!targetObject.material) {
              console.error('  can not bind to material as node does not have a material', this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error('  can not bind to material.materials as node.material does not have a materials array', this);
              return;
            }
            targetObject = targetObject.material.materials;
          } else if (this.objectName === "bones") {
            if (!targetObject.skeleton) {
              console.error('  can not bind to bones as node does not have a skeleton', this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (var i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === this.objectIndex) {
                this.objectIndex = i;
                break;
              }
            }
          } else {
            if (targetObject[this.objectName] === undefined) {
              console.error('  can not bind to objectName of node, undefined', this);
              return;
            }
            targetObject = targetObject[this.objectName];
          }
          if (this.objectIndex !== undefined) {
            if (targetObject[this.objectIndex] === undefined) {
              console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
              return;
            }
            targetObject = targetObject[this.objectIndex];
          }
        }
        var nodeProperty = targetObject[this.propertyName];
        if (!nodeProperty) {
          console.error("  trying to update property for track: " + this.nodeName + '.' + this.propertyName + " but it wasn't found.", targetObject);
          return;
        }
        if (this.propertyIndex !== undefined) {
          if (this.propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry', this);
            }
            if (!targetObject.geometry.morphTargets) {
              console.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this);
            }
            for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
              if (targetObject.geometry.morphTargets[i].name === this.propertyIndex) {
                this.propertyIndex = i;
                break;
              }
            }
          }
          this.setValue = function setValue_propertyIndexed(value) {
            if (!this.equalsValue(nodeProperty[this.propertyIndex], value)) {
              nodeProperty[this.propertyIndex] = value;
              return true;
            }
            return false;
          };
          this.getValue = function getValue_propertyIndexed() {
            return nodeProperty[this.propertyIndex];
          };
        } else if (nodeProperty.copy) {
          this.setValue = function setValue_propertyObject(value) {
            if (!this.equalsValue(nodeProperty, value)) {
              nodeProperty.copy(value);
              return true;
            }
            return false;
          };
          this.getValue = function getValue_propertyObject() {
            return nodeProperty;
          };
        } else {
          this.setValue = function setValue_property(value) {
            if (!this.equalsValue(targetObject[this.propertyName], value)) {
              targetObject[this.propertyName] = value;
              return true;
            }
            return false;
          };
          this.getValue = function getValue_property() {
            return targetObject[this.propertyName];
          };
        }
        if (targetObject.needsUpdate !== undefined) {
          this.triggerDirty = function triggerDirty_needsUpdate() {
            this.node.needsUpdate = true;
          };
        } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
          this.triggerDirty = function triggerDirty_matrixWorldNeedsUpdate() {
            targetObject.matrixWorldNeedsUpdate = true;
          };
        }
        this.originalValue = this.getValue();
        this.equalsValue = THREE.AnimationUtils.getEqualsFunc(this.originalValue);
        this.lerpValue = THREE.AnimationUtils.getLerpFunc(this.originalValue, true);
        this.isBound = true;
      },
      apply: function() {
        if (!this.isBound)
          this.bind();
        if (this.cumulativeWeight > 0) {
          if (this.cumulativeWeight < 1) {
            var remainingWeight = 1 - this.cumulativeWeight;
            var lerpAlpha = remainingWeight / (this.cumulativeWeight + remainingWeight);
            this.cumulativeValue = this.lerpValue(this.cumulativeValue, this.originalValue, lerpAlpha);
          }
          var valueChanged = this.setValue(this.cumulativeValue);
          if (valueChanged && this.triggerDirty) {
            this.triggerDirty();
          }
          this.cumulativeValue = null;
          this.cumulativeWeight = 0;
        }
      }
    };
    THREE.PropertyBinding.parseTrackName = function(trackName) {
      var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
      var matches = re.exec(trackName);
      if (!matches) {
        throw new Error("cannot parse trackName at all: " + trackName);
      }
      if (matches.index === re.lastIndex) {
        re.lastIndex++;
      }
      var results = {
        directoryName: matches[1],
        nodeName: matches[3],
        objectName: matches[5],
        objectIndex: matches[7],
        propertyName: matches[9],
        propertyIndex: matches[11]
      };
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("can not parse propertyName from trackName: " + trackName);
      }
      return results;
    };
    THREE.PropertyBinding.findNode = function(root, nodeName) {
      function searchSkeleton(skeleton) {
        for (var i = 0; i < skeleton.bones.length; i++) {
          var bone = skeleton.bones[i];
          if (bone.name === nodeName) {
            return bone;
          }
        }
        return null;
      }
      function searchNodeSubtree(children) {
        for (var i = 0; i < children.length; i++) {
          var childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          var result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      }
      if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        var bone = searchSkeleton(root.skeleton);
        if (bone) {
          return bone;
        }
      }
      if (root.children) {
        var subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    };
    THREE.VectorKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value.clone();
    };
    THREE.VectorKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.VectorKeyframeTrack.prototype.constructor = THREE.VectorKeyframeTrack;
    THREE.VectorKeyframeTrack.prototype.setResult = function(value) {
      this.result.copy(value);
    };
    THREE.VectorKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return value0.lerp(value1, alpha);
    };
    THREE.VectorKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return value0.equals(value1);
    };
    THREE.VectorKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value.clone()
        });
      }
      return new THREE.VectorKeyframeTrack(this.name, clonedKeys);
    };
    THREE.VectorKeyframeTrack.parse = function(json) {
      var elementCount = json.keys[0].value.length;
      var valueType = THREE['Vector' + elementCount];
      var keys = [];
      for (var i = 0; i < json.keys.length; i++) {
        var jsonKey = json.keys[i];
        keys.push({
          value: new valueType().fromArray(jsonKey.value),
          time: jsonKey.time
        });
      }
      return new THREE.VectorKeyframeTrack(json.name, keys);
    };
    THREE.QuaternionKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value.clone();
    };
    THREE.QuaternionKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.QuaternionKeyframeTrack.prototype.constructor = THREE.QuaternionKeyframeTrack;
    THREE.QuaternionKeyframeTrack.prototype.setResult = function(value) {
      this.result.copy(value);
    };
    THREE.QuaternionKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return value0.slerp(value1, alpha);
    };
    THREE.QuaternionKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return value0.equals(value1);
    };
    THREE.QuaternionKeyframeTrack.prototype.multiply = function(quat) {
      for (var i = 0; i < this.keys.length; i++) {
        this.keys[i].value.multiply(quat);
      }
      return this;
    };
    THREE.QuaternionKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value.clone()
        });
      }
      return new THREE.QuaternionKeyframeTrack(this.name, clonedKeys);
    };
    THREE.QuaternionKeyframeTrack.parse = function(json) {
      var keys = [];
      for (var i = 0; i < json.keys.length; i++) {
        var jsonKey = json.keys[i];
        keys.push({
          value: new THREE.Quaternion().fromArray(jsonKey.value),
          time: jsonKey.time
        });
      }
      return new THREE.QuaternionKeyframeTrack(json.name, keys);
    };
    THREE.StringKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value;
    };
    THREE.StringKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.StringKeyframeTrack.prototype.constructor = THREE.StringKeyframeTrack;
    THREE.StringKeyframeTrack.prototype.setResult = function(value) {
      this.result = value;
    };
    THREE.StringKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return (alpha < 1.0) ? value0 : value1;
    };
    THREE.StringKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return (value0 === value1);
    };
    THREE.StringKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value
        });
      }
      return new THREE.StringKeyframeTrack(this.name, clonedKeys);
    };
    THREE.StringKeyframeTrack.parse = function(json) {
      return new THREE.StringKeyframeTrack(json.name, json.keys);
    };
    THREE.BooleanKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value;
    };
    THREE.BooleanKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.BooleanKeyframeTrack.prototype.constructor = THREE.BooleanKeyframeTrack;
    THREE.BooleanKeyframeTrack.prototype.setResult = function(value) {
      this.result = value;
    };
    THREE.BooleanKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return (alpha < 1.0) ? value0 : value1;
    };
    THREE.BooleanKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return (value0 === value1);
    };
    THREE.BooleanKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value
        });
      }
      return new THREE.BooleanKeyframeTrack(this.name, clonedKeys);
    };
    THREE.BooleanKeyframeTrack.parse = function(json) {
      return new THREE.BooleanKeyframeTrack(json.name, json.keys);
    };
    THREE.NumberKeyframeTrack = function(name, keys) {
      THREE.KeyframeTrack.call(this, name, keys);
      this.result = this.keys[0].value;
    };
    THREE.NumberKeyframeTrack.prototype = Object.create(THREE.KeyframeTrack.prototype);
    THREE.NumberKeyframeTrack.prototype.constructor = THREE.NumberKeyframeTrack;
    THREE.NumberKeyframeTrack.prototype.setResult = function(value) {
      this.result = value;
    };
    THREE.NumberKeyframeTrack.prototype.lerpValues = function(value0, value1, alpha) {
      return value0 * (1 - alpha) + value1 * alpha;
    };
    THREE.NumberKeyframeTrack.prototype.compareValues = function(value0, value1) {
      return (value0 === value1);
    };
    THREE.NumberKeyframeTrack.prototype.clone = function() {
      var clonedKeys = [];
      for (var i = 0; i < this.keys.length; i++) {
        var key = this.keys[i];
        clonedKeys.push({
          time: key.time,
          value: key.value
        });
      }
      return new THREE.NumberKeyframeTrack(this.name, clonedKeys);
    };
    THREE.NumberKeyframeTrack.parse = function(json) {
      return new THREE.NumberKeyframeTrack(json.name, json.keys);
    };
    THREE.Camera = function() {
      THREE.Object3D.call(this);
      this.type = 'Camera';
      this.matrixWorldInverse = new THREE.Matrix4();
      this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Camera.prototype.constructor = THREE.Camera;
    THREE.Camera.prototype.getWorldDirection = function() {
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
      };
    }();
    THREE.Camera.prototype.lookAt = function() {
      var m1 = new THREE.Matrix4();
      return function(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
      };
    }();
    THREE.Camera.prototype.clone = function() {
      return new this.constructor().copy(this);
    };
    THREE.Camera.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      return this;
    };
    THREE.CubeCamera = function(near, far, cubeResolution) {
      THREE.Object3D.call(this);
      this.type = 'CubeCamera';
      var fov = 90,
          aspect = 1;
      var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
      this.add(cameraPX);
      var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
      this.add(cameraNX);
      var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
      this.add(cameraPY);
      var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
      this.add(cameraNY);
      var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
      this.add(cameraPZ);
      var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
      this.add(cameraNZ);
      this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
      });
      this.updateCubeMap = function(renderer, scene) {
        if (this.parent === null)
          this.updateMatrixWorld();
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
        renderer.setRenderTarget(null);
      };
    };
    THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
    THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
      THREE.Camera.call(this);
      this.type = 'OrthographicCamera';
      this.zoom = 1;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = (near !== undefined) ? near : 0.1;
      this.far = (far !== undefined) ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
    THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
    };
    THREE.OrthographicCamera.prototype.copy = function(source) {
      THREE.Camera.prototype.copy.call(this, source);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      return this;
    };
    THREE.OrthographicCamera.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      return data;
    };
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
      THREE.Camera.call(this);
      this.type = 'PerspectiveCamera';
      this.zoom = 1;
      this.fov = fov !== undefined ? fov : 50;
      this.aspect = aspect !== undefined ? aspect : 1;
      this.near = near !== undefined ? near : 0.1;
      this.far = far !== undefined ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {
      if (frameHeight === undefined)
        frameHeight = 24;
      this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
      this.fullWidth = fullWidth;
      this.fullHeight = fullHeight;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
      var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));
      if (this.fullWidth) {
        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs(right - left);
        var height = Math.abs(top - bottom);
        this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
      } else {
        this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
      }
    };
    THREE.PerspectiveCamera.prototype.copy = function(source) {
      THREE.Camera.prototype.copy.call(this, source);
      this.fov = source.fov;
      this.aspect = source.aspect;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      return this;
    };
    THREE.PerspectiveCamera.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.fov = this.fov;
      data.object.aspect = this.aspect;
      data.object.near = this.near;
      data.object.far = this.far;
      return data;
    };
    THREE.Light = function(color) {
      THREE.Object3D.call(this);
      this.type = 'Light';
      this.color = new THREE.Color(color);
      this.receiveShadow = undefined;
    };
    THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Light.prototype.constructor = THREE.Light;
    Object.defineProperties(THREE.Light.prototype, {
      onlyShadow: {set: function(value) {
          console.warn('THREE.Light: .onlyShadow has been removed.');
        }},
      shadowCameraFov: {set: function(value) {
          this.shadow.camera.fov = value;
        }},
      shadowCameraLeft: {set: function(value) {
          this.shadow.camera.left = value;
        }},
      shadowCameraRight: {set: function(value) {
          this.shadow.camera.right = value;
        }},
      shadowCameraTop: {set: function(value) {
          this.shadow.camera.top = value;
        }},
      shadowCameraBottom: {set: function(value) {
          this.shadow.camera.bottom = value;
        }},
      shadowCameraNear: {set: function(value) {
          this.shadow.camera.near = value;
        }},
      shadowCameraFar: {set: function(value) {
          this.shadow.camera.far = value;
        }},
      shadowCameraVisible: {set: function(value) {
          console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow ) instead.');
        }},
      shadowBias: {set: function(value) {
          this.shadow.bias = value;
        }},
      shadowDarkness: {set: function(value) {
          this.shadow.darkness = value;
        }},
      shadowMapWidth: {set: function(value) {
          this.shadow.mapSize.width = value;
        }},
      shadowMapHeight: {set: function(value) {
          this.shadow.mapSize.height = value;
        }}
    });
    THREE.Light.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.color.copy(source.color);
      return this;
    };
    THREE.Light.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.color = this.color.getHex();
      if (this.groundColor !== undefined)
        data.object.groundColor = this.groundColor.getHex();
      if (this.intensity !== undefined)
        data.object.intensity = this.intensity;
      if (this.distance !== undefined)
        data.object.distance = this.distance;
      if (this.angle !== undefined)
        data.object.angle = this.angle;
      if (this.decay !== undefined)
        data.object.decay = this.decay;
      if (this.exponent !== undefined)
        data.object.exponent = this.exponent;
      return data;
    };
    THREE.LightShadow = function(camera) {
      this.camera = camera;
      this.bias = 0;
      this.darkness = 1;
      this.mapSize = new THREE.Vector2(512, 512);
      this.map = null;
      this.matrix = null;
    };
    THREE.LightShadow.prototype = {
      constructor: THREE.LightShadow,
      copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.darkness = source.darkness;
        this.mapSize.copy(source.mapSize);
      },
      clone: function() {
        return new this.constructor().copy(this);
      }
    };
    THREE.AmbientLight = function(color) {
      THREE.Light.call(this, color);
      this.type = 'AmbientLight';
      this.castShadow = undefined;
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
    THREE.DirectionalLight = function(color, intensity) {
      THREE.Light.call(this, color);
      this.type = 'DirectionalLight';
      this.position.set(0, 1, 0);
      this.updateMatrix();
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-500, 500, 500, -500, 50, 5000));
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
    THREE.DirectionalLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.intensity = source.intensity;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    };
    THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
      THREE.Light.call(this, skyColor);
      this.type = 'HemisphereLight';
      this.castShadow = undefined;
      this.position.set(0, 1, 0);
      this.updateMatrix();
      this.groundColor = new THREE.Color(groundColor);
      this.intensity = (intensity !== undefined) ? intensity : 1;
    };
    THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
    THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
    THREE.HemisphereLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      this.intensity = source.intensity;
      return this;
    };
    THREE.PointLight = function(color, intensity, distance, decay) {
      THREE.Light.call(this, color);
      this.type = 'PointLight';
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.decay = (decay !== undefined) ? decay : 1;
      this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, 1, 500));
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;
    THREE.PointLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.intensity = source.intensity;
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    };
    THREE.SpotLight = function(color, intensity, distance, angle, exponent, decay) {
      THREE.Light.call(this, color);
      this.type = 'SpotLight';
      this.position.set(0, 1, 0);
      this.updateMatrix();
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.angle = (angle !== undefined) ? angle : Math.PI / 3;
      this.exponent = (exponent !== undefined) ? exponent : 10;
      this.decay = (decay !== undefined) ? decay : 1;
      this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, 50, 5000));
    };
    THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
    THREE.SpotLight.prototype.constructor = THREE.SpotLight;
    THREE.SpotLight.prototype.copy = function(source) {
      THREE.Light.prototype.copy.call(this, source);
      this.intensity = source.intensity;
      this.distance = source.distance;
      this.angle = source.angle;
      this.exponent = source.exponent;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    };
    THREE.Cache = {
      enabled: false,
      files: {},
      add: function(key, file) {
        if (this.enabled === false)
          return;
        this.files[key] = file;
      },
      get: function(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    THREE.Loader = function() {
      this.onLoadStart = function() {};
      this.onLoadProgress = function() {};
      this.onLoadComplete = function() {};
    };
    THREE.Loader.prototype = {
      constructor: THREE.Loader,
      crossOrigin: undefined,
      extractUrlBase: function(url) {
        var parts = url.split('/');
        if (parts.length === 1)
          return './';
        parts.pop();
        return parts.join('/') + '/';
      },
      initMaterials: function(materials, texturePath, crossOrigin) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
          array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
        }
        return array;
      },
      createMaterial: (function() {
        var color,
            textureLoader,
            materialLoader;
        return function(m, texturePath, crossOrigin) {
          if (color === undefined)
            color = new THREE.Color();
          if (textureLoader === undefined)
            textureLoader = new THREE.TextureLoader();
          if (materialLoader === undefined)
            materialLoader = new THREE.MaterialLoader();
          var textures = {};
          function loadTexture(path, repeat, offset, wrap, anisotropy) {
            var fullPath = texturePath + path;
            var loader = THREE.Loader.Handlers.get(fullPath);
            var texture;
            if (loader !== null) {
              texture = loader.load(fullPath);
            } else {
              textureLoader.setCrossOrigin(crossOrigin);
              texture = textureLoader.load(fullPath);
            }
            if (repeat !== undefined) {
              texture.repeat.fromArray(repeat);
              if (repeat[0] !== 1)
                texture.wrapS = THREE.RepeatWrapping;
              if (repeat[1] !== 1)
                texture.wrapT = THREE.RepeatWrapping;
            }
            if (offset !== undefined) {
              texture.offset.fromArray(offset);
            }
            if (wrap !== undefined) {
              if (wrap[0] === 'repeat')
                texture.wrapS = THREE.RepeatWrapping;
              if (wrap[0] === 'mirror')
                texture.wrapS = THREE.MirroredRepeatWrapping;
              if (wrap[1] === 'repeat')
                texture.wrapT = THREE.RepeatWrapping;
              if (wrap[1] === 'mirror')
                texture.wrapT = THREE.MirroredRepeatWrapping;
            }
            if (anisotropy !== undefined) {
              texture.anisotropy = anisotropy;
            }
            var uuid = THREE.Math.generateUUID();
            textures[uuid] = texture;
            return uuid;
          }
          var json = {
            uuid: THREE.Math.generateUUID(),
            type: 'MeshLambertMaterial'
          };
          for (var name in m) {
            var value = m[name];
            switch (name) {
              case 'DbgColor':
                json.color = value;
                break;
              case 'DbgIndex':
              case 'opticalDensity':
              case 'illumination':
                break;
              case 'DbgName':
                json.name = value;
                break;
              case 'blending':
                json.blending = THREE[value];
                break;
              case 'colorDiffuse':
                json.color = color.fromArray(value).getHex();
                break;
              case 'colorSpecular':
                json.specular = color.fromArray(value).getHex();
                break;
              case 'colorEmissive':
                json.emissive = color.fromArray(value).getHex();
                break;
              case 'specularCoef':
                json.shininess = value;
                break;
              case 'shading':
                if (value.toLowerCase() === 'basic')
                  json.type = 'MeshBasicMaterial';
                if (value.toLowerCase() === 'phong')
                  json.type = 'MeshPhongMaterial';
                break;
              case 'mapDiffuse':
                json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                break;
              case 'mapDiffuseRepeat':
              case 'mapDiffuseOffset':
              case 'mapDiffuseWrap':
              case 'mapDiffuseAnisotropy':
                break;
              case 'mapLight':
                json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                break;
              case 'mapLightRepeat':
              case 'mapLightOffset':
              case 'mapLightWrap':
              case 'mapLightAnisotropy':
                break;
              case 'mapAO':
                json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                break;
              case 'mapAORepeat':
              case 'mapAOOffset':
              case 'mapAOWrap':
              case 'mapAOAnisotropy':
                break;
              case 'mapBump':
                json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                break;
              case 'mapBumpScale':
                json.bumpScale = value;
                break;
              case 'mapBumpRepeat':
              case 'mapBumpOffset':
              case 'mapBumpWrap':
              case 'mapBumpAnisotropy':
                break;
              case 'mapNormal':
                json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                break;
              case 'mapNormalFactor':
                json.normalScale = [value, value];
                break;
              case 'mapNormalRepeat':
              case 'mapNormalOffset':
              case 'mapNormalWrap':
              case 'mapNormalAnisotropy':
                break;
              case 'mapSpecular':
                json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                break;
              case 'mapSpecularRepeat':
              case 'mapSpecularOffset':
              case 'mapSpecularWrap':
              case 'mapSpecularAnisotropy':
                break;
              case 'mapAlpha':
                json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                break;
              case 'mapAlphaRepeat':
              case 'mapAlphaOffset':
              case 'mapAlphaWrap':
              case 'mapAlphaAnisotropy':
                break;
              case 'flipSided':
                json.side = THREE.BackSide;
                break;
              case 'doubleSided':
                json.side = THREE.DoubleSide;
                break;
              case 'transparency':
                console.warn('THREE.Loader: transparency has been renamed to opacity');
                json.opacity = value;
                break;
              case 'opacity':
              case 'transparent':
              case 'depthTest':
              case 'depthWrite':
              case 'transparent':
              case 'visible':
              case 'wireframe':
                json[name] = value;
                break;
              case 'vertexColors':
                if (value === true)
                  json.vertexColors = THREE.VertexColors;
                if (value === 'face')
                  json.vertexColors = THREE.FaceColors;
                break;
              default:
                console.error('Loader.createMaterial: Unsupported', name, value);
                break;
            }
          }
          if (json.type !== 'MeshPhongMaterial')
            delete json.specular;
          if (json.opacity < 1)
            json.transparent = true;
          materialLoader.setTextures(textures);
          return materialLoader.parse(json);
        };
      })()
    };
    THREE.Loader.Handlers = {
      handlers: [],
      add: function(regex, loader) {
        this.handlers.push(regex, loader);
      },
      get: function(file) {
        var handlers = this.handlers;
        for (var i = 0,
            l = handlers.length; i < l; i += 2) {
          var regex = handlers[i];
          var loader = handlers[i + 1];
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      }
    };
    THREE.XHRLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.XHRLoader.prototype = {
      constructor: THREE.XHRLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          if (onLoad) {
            setTimeout(function() {
              onLoad(cached);
            }, 0);
          }
          return cached;
        }
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.addEventListener('load', function(event) {
          var response = event.target.response;
          THREE.Cache.add(url, response);
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          request.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        request.addEventListener('error', function(event) {
          if (onError)
            onError(event);
          scope.manager.itemError(url);
        }, false);
        if (this.crossOrigin !== undefined)
          request.crossOrigin = this.crossOrigin;
        if (this.responseType !== undefined)
          request.responseType = this.responseType;
        if (this.withCredentials !== undefined)
          request.withCredentials = this.withCredentials;
        request.send(null);
        scope.manager.itemStart(url);
        return request;
      },
      setResponseType: function(value) {
        this.responseType = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      setWithCredentials: function(value) {
        this.withCredentials = value;
      }
    };
    THREE.ImageLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.ImageLoader.prototype = {
      constructor: THREE.ImageLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          scope.manager.itemStart(url);
          if (onLoad) {
            setTimeout(function() {
              onLoad(cached);
              scope.manager.itemEnd(url);
            }, 0);
          } else {
            scope.manager.itemEnd(url);
          }
          return cached;
        }
        var image = document.createElement('img');
        image.addEventListener('load', function(event) {
          THREE.Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          image.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        image.addEventListener('error', function(event) {
          if (onError)
            onError(event);
          scope.manager.itemError(url);
        }, false);
        if (this.crossOrigin !== undefined)
          image.crossOrigin = this.crossOrigin;
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.JSONLoader = function(manager) {
      if (typeof manager === 'boolean') {
        console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
        manager = undefined;
      }
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.withCredentials = false;
    };
    THREE.JSONLoader.prototype = {
      constructor: THREE.JSONLoader,
      get statusDomElement() {
        if (this._statusDomElement === undefined) {
          this._statusDomElement = document.createElement('div');
        }
        console.warn('THREE.JSONLoader: .statusDomElement has been removed.');
        return this._statusDomElement;
      },
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texturePath = this.texturePath && (typeof this.texturePath === "string") ? this.texturePath : THREE.Loader.prototype.extractUrlBase(url);
        var loader = new THREE.XHRLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text) {
          var json = JSON.parse(text);
          var metadata = json.metadata;
          if (metadata !== undefined) {
            if (metadata.type === 'object') {
              console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
              return;
            }
            if (metadata.type === 'scene') {
              console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
              return;
            }
          }
          var object = scope.parse(json, texturePath);
          onLoad(object.geometry, object.materials);
        });
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      setTexturePath: function(value) {
        this.texturePath = value;
      },
      parse: function(json, texturePath) {
        var geometry = new THREE.Geometry(),
            scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
        parseModel(scale);
        parseSkin();
        parseMorphing(scale);
        parseAnimations();
        geometry.computeFaceNormals();
        geometry.computeBoundingSphere();
        function parseModel(scale) {
          function isBitSet(value, position) {
            return value & (1 << position);
          }
          var i,
              j,
              fi,
              offset,
              zLength,
              colorIndex,
              normalIndex,
              uvIndex,
              materialIndex,
              type,
              isQuad,
              hasMaterial,
              hasFaceVertexUv,
              hasFaceNormal,
              hasFaceVertexNormal,
              hasFaceColor,
              hasFaceVertexColor,
              vertex,
              face,
              faceA,
              faceB,
              hex,
              normal,
              uvLayer,
              uv,
              u,
              v,
              faces = json.faces,
              vertices = json.vertices,
              normals = json.normals,
              colors = json.colors,
              nUvLayers = 0;
          if (json.uvs !== undefined) {
            for (i = 0; i < json.uvs.length; i++) {
              if (json.uvs[i].length)
                nUvLayers++;
            }
            for (i = 0; i < nUvLayers; i++) {
              geometry.faceVertexUvs[i] = [];
            }
          }
          offset = 0;
          zLength = vertices.length;
          while (offset < zLength) {
            vertex = new THREE.Vector3();
            vertex.x = vertices[offset++] * scale;
            vertex.y = vertices[offset++] * scale;
            vertex.z = vertices[offset++] * scale;
            geometry.vertices.push(vertex);
          }
          offset = 0;
          zLength = faces.length;
          while (offset < zLength) {
            type = faces[offset++];
            isQuad = isBitSet(type, 0);
            hasMaterial = isBitSet(type, 1);
            hasFaceVertexUv = isBitSet(type, 3);
            hasFaceNormal = isBitSet(type, 4);
            hasFaceVertexNormal = isBitSet(type, 5);
            hasFaceColor = isBitSet(type, 6);
            hasFaceVertexColor = isBitSet(type, 7);
            if (isQuad) {
              faceA = new THREE.Face3();
              faceA.a = faces[offset];
              faceA.b = faces[offset + 1];
              faceA.c = faces[offset + 3];
              faceB = new THREE.Face3();
              faceB.a = faces[offset + 1];
              faceB.b = faces[offset + 2];
              faceB.c = faces[offset + 3];
              offset += 4;
              if (hasMaterial) {
                materialIndex = faces[offset++];
                faceA.materialIndex = materialIndex;
                faceB.materialIndex = materialIndex;
              }
              fi = geometry.faces.length;
              if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                  uvLayer = json.uvs[i];
                  geometry.faceVertexUvs[i][fi] = [];
                  geometry.faceVertexUvs[i][fi + 1] = [];
                  for (j = 0; j < 4; j++) {
                    uvIndex = faces[offset++];
                    u = uvLayer[uvIndex * 2];
                    v = uvLayer[uvIndex * 2 + 1];
                    uv = new THREE.Vector2(u, v);
                    if (j !== 2)
                      geometry.faceVertexUvs[i][fi].push(uv);
                    if (j !== 0)
                      geometry.faceVertexUvs[i][fi + 1].push(uv);
                  }
                }
              }
              if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;
                faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                faceB.normal.copy(faceA.normal);
              }
              if (hasFaceVertexNormal) {
                for (i = 0; i < 4; i++) {
                  normalIndex = faces[offset++] * 3;
                  normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                  if (i !== 2)
                    faceA.vertexNormals.push(normal);
                  if (i !== 0)
                    faceB.vertexNormals.push(normal);
                }
              }
              if (hasFaceColor) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];
                faceA.color.setHex(hex);
                faceB.color.setHex(hex);
              }
              if (hasFaceVertexColor) {
                for (i = 0; i < 4; i++) {
                  colorIndex = faces[offset++];
                  hex = colors[colorIndex];
                  if (i !== 2)
                    faceA.vertexColors.push(new THREE.Color(hex));
                  if (i !== 0)
                    faceB.vertexColors.push(new THREE.Color(hex));
                }
              }
              geometry.faces.push(faceA);
              geometry.faces.push(faceB);
            } else {
              face = new THREE.Face3();
              face.a = faces[offset++];
              face.b = faces[offset++];
              face.c = faces[offset++];
              if (hasMaterial) {
                materialIndex = faces[offset++];
                face.materialIndex = materialIndex;
              }
              fi = geometry.faces.length;
              if (hasFaceVertexUv) {
                for (i = 0; i < nUvLayers; i++) {
                  uvLayer = json.uvs[i];
                  geometry.faceVertexUvs[i][fi] = [];
                  for (j = 0; j < 3; j++) {
                    uvIndex = faces[offset++];
                    u = uvLayer[uvIndex * 2];
                    v = uvLayer[uvIndex * 2 + 1];
                    uv = new THREE.Vector2(u, v);
                    geometry.faceVertexUvs[i][fi].push(uv);
                  }
                }
              }
              if (hasFaceNormal) {
                normalIndex = faces[offset++] * 3;
                face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              }
              if (hasFaceVertexNormal) {
                for (i = 0; i < 3; i++) {
                  normalIndex = faces[offset++] * 3;
                  normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                  face.vertexNormals.push(normal);
                }
              }
              if (hasFaceColor) {
                colorIndex = faces[offset++];
                face.color.setHex(colors[colorIndex]);
              }
              if (hasFaceVertexColor) {
                for (i = 0; i < 3; i++) {
                  colorIndex = faces[offset++];
                  face.vertexColors.push(new THREE.Color(colors[colorIndex]));
                }
              }
              geometry.faces.push(face);
            }
          }
        }
        ;
        function parseSkin() {
          var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
          if (json.skinWeights) {
            for (var i = 0,
                l = json.skinWeights.length; i < l; i += influencesPerVertex) {
              var x = json.skinWeights[i];
              var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
              var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
              var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
              geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
            }
          }
          if (json.skinIndices) {
            for (var i = 0,
                l = json.skinIndices.length; i < l; i += influencesPerVertex) {
              var a = json.skinIndices[i];
              var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
              var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
              var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
              geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
            }
          }
          geometry.bones = json.bones;
          if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
            console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
          }
        }
        ;
        function parseMorphing(scale) {
          if (json.morphTargets !== undefined) {
            for (var i = 0,
                l = json.morphTargets.length; i < l; i++) {
              geometry.morphTargets[i] = {};
              geometry.morphTargets[i].name = json.morphTargets[i].name;
              geometry.morphTargets[i].vertices = [];
              var dstVertices = geometry.morphTargets[i].vertices;
              var srcVertices = json.morphTargets[i].vertices;
              for (var v = 0,
                  vl = srcVertices.length; v < vl; v += 3) {
                var vertex = new THREE.Vector3();
                vertex.x = srcVertices[v] * scale;
                vertex.y = srcVertices[v + 1] * scale;
                vertex.z = srcVertices[v + 2] * scale;
                dstVertices.push(vertex);
              }
            }
          }
          if (json.morphColors !== undefined && json.morphColors.length > 0) {
            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
            var faces = geometry.faces;
            var morphColors = json.morphColors[0].colors;
            for (var i = 0,
                l = faces.length; i < l; i++) {
              faces[i].color.fromArray(morphColors, i * 3);
            }
          }
        }
        function parseAnimations() {
          var outputAnimations = [];
          var animations = [];
          if (json.animation !== undefined) {
            animations.push(json.animation);
          }
          if (json.animations !== undefined) {
            if (json.animations.length) {
              animations = animations.concat(json.animations);
            } else {
              animations.push(json.animations);
            }
          }
          for (var i = 0; i < animations.length; i++) {
            var clip = THREE.AnimationClip.parseAnimation(animations[i], geometry.bones);
            if (clip)
              outputAnimations.push(clip);
          }
          if (geometry.morphTargets) {
            var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
            outputAnimations = outputAnimations.concat(morphAnimationClips);
          }
          if (outputAnimations.length > 0)
            geometry.animations = outputAnimations;
        }
        ;
        if (json.materials === undefined || json.materials.length === 0) {
          return {geometry: geometry};
        } else {
          var materials = THREE.Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
          return {
            geometry: geometry,
            materials: materials
          };
        }
      }
    };
    THREE.LoadingManager = function(onLoad, onProgress, onError) {
      var scope = this;
      var isLoading = false,
          itemsLoaded = 0,
          itemsTotal = 0;
      this.onStart = undefined;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== undefined) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== undefined) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== undefined) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== undefined) {
          scope.onError(url);
        }
      };
    };
    THREE.DefaultLoadingManager = new THREE.LoadingManager();
    THREE.BufferGeometryLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.BufferGeometryLoader.prototype = {
      constructor: THREE.BufferGeometryLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json) {
        var geometry = new THREE.BufferGeometry();
        var index = json.data.index;
        if (index !== undefined) {
          var typedArray = new self[index.type](index.array);
          geometry.setIndex(new THREE.BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var typedArray = new self[attribute.type](attribute.array);
          geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) {
          for (var i = 0,
              n = groups.length; i !== n; ++i) {
            var group = groups[i];
            geometry.addGroup(group.start, group.count);
          }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
          var center = new THREE.Vector3();
          if (boundingSphere.center !== undefined) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
        }
        return geometry;
      }
    };
    THREE.MaterialLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.textures = {};
    };
    THREE.MaterialLoader.prototype = {
      constructor: THREE.MaterialLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      setTextures: function(value) {
        this.textures = value;
      },
      getTexture: function(name) {
        var textures = this.textures;
        if (textures[name] === undefined) {
          console.warn('THREE.MaterialLoader: Undefined texture', name);
        }
        return textures[name];
      },
      parse: function(json) {
        var material = new THREE[json.type];
        material.uuid = json.uuid;
        if (json.name !== undefined)
          material.name = json.name;
        if (json.color !== undefined)
          material.color.setHex(json.color);
        if (json.emissive !== undefined)
          material.emissive.setHex(json.emissive);
        if (json.specular !== undefined)
          material.specular.setHex(json.specular);
        if (json.shininess !== undefined)
          material.shininess = json.shininess;
        if (json.uniforms !== undefined)
          material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined)
          material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined)
          material.vertexColors = json.vertexColors;
        if (json.shading !== undefined)
          material.shading = json.shading;
        if (json.blending !== undefined)
          material.blending = json.blending;
        if (json.side !== undefined)
          material.side = json.side;
        if (json.opacity !== undefined)
          material.opacity = json.opacity;
        if (json.transparent !== undefined)
          material.transparent = json.transparent;
        if (json.alphaTest !== undefined)
          material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined)
          material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined)
          material.depthWrite = json.depthWrite;
        if (json.wireframe !== undefined)
          material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined)
          material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.size !== undefined)
          material.size = json.size;
        if (json.sizeAttenuation !== undefined)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== undefined)
          material.map = this.getTexture(json.map);
        if (json.alphaMap !== undefined) {
          material.alphaMap = this.getTexture(json.alphaMap);
          material.transparent = true;
        }
        if (json.bumpMap !== undefined)
          material.bumpMap = this.getTexture(json.bumpMap);
        if (json.bumpScale !== undefined)
          material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined)
          material.normalMap = this.getTexture(json.normalMap);
        if (json.normalScale)
          material.normalScale = new THREE.Vector2(json.normalScale, json.normalScale);
        if (json.displacementMap !== undefined)
          material.displacementMap = this.getTexture(json.displacementMap);
        if (json.displacementScale !== undefined)
          material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined)
          material.displacementBias = json.displacementBias;
        if (json.specularMap !== undefined)
          material.specularMap = this.getTexture(json.specularMap);
        if (json.envMap !== undefined) {
          material.envMap = this.getTexture(json.envMap);
          material.combine = THREE.MultiplyOperation;
        }
        if (json.reflectivity)
          material.reflectivity = json.reflectivity;
        if (json.lightMap !== undefined)
          material.lightMap = this.getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined)
          material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined)
          material.aoMap = this.getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined)
          material.aoMapIntensity = json.aoMapIntensity;
        if (json.materials !== undefined) {
          for (var i = 0,
              l = json.materials.length; i < l; i++) {
            material.materials.push(this.parse(json.materials[i]));
          }
        }
        return material;
      }
    };
    THREE.ObjectLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.texturePath = '';
    };
    THREE.ObjectLoader.prototype = {
      constructor: THREE.ObjectLoader,
      load: function(url, onLoad, onProgress, onError) {
        if (this.texturePath === '') {
          this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
        }
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
      },
      setTexturePath: function(value) {
        this.texturePath = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function() {
          if (onLoad !== undefined)
            onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.animations) {
          object.animations = this.parseAnimations(json.animations);
        }
        if (json.images === undefined || json.images.length === 0) {
          if (onLoad !== undefined)
            onLoad(object);
        }
        return object;
      },
      parseGeometries: function(json) {
        var geometries = {};
        if (json !== undefined) {
          var geometryLoader = new THREE.JSONLoader();
          var bufferGeometryLoader = new THREE.BufferGeometryLoader();
          for (var i = 0,
              l = json.length; i < l; i++) {
            var geometry;
            var data = json[i];
            switch (data.type) {
              case 'PlaneGeometry':
              case 'PlaneBufferGeometry':
                geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case 'BoxGeometry':
              case 'CubeGeometry':
                geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case 'CircleBufferGeometry':
                geometry = new THREE.CircleBufferGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case 'CircleGeometry':
                geometry = new THREE.CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
                break;
              case 'CylinderGeometry':
                geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                break;
              case 'SphereGeometry':
                geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case 'SphereBufferGeometry':
                geometry = new THREE.SphereBufferGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case 'DodecahedronGeometry':
                geometry = new THREE.DodecahedronGeometry(data.radius, data.detail);
                break;
              case 'IcosahedronGeometry':
                geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
                break;
              case 'OctahedronGeometry':
                geometry = new THREE.OctahedronGeometry(data.radius, data.detail);
                break;
              case 'TetrahedronGeometry':
                geometry = new THREE.TetrahedronGeometry(data.radius, data.detail);
                break;
              case 'RingGeometry':
                geometry = new THREE.RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                break;
              case 'TorusGeometry':
                geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case 'TorusKnotGeometry':
                geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
                break;
              case 'BufferGeometry':
                geometry = bufferGeometryLoader.parse(data);
                break;
              case 'Geometry':
                geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                continue;
            }
            geometry.uuid = data.uuid;
            if (data.name !== undefined)
              geometry.name = data.name;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      },
      parseMaterials: function(json, textures) {
        var materials = {};
        if (json !== undefined) {
          var loader = new THREE.MaterialLoader();
          loader.setTextures(textures);
          for (var i = 0,
              l = json.length; i < l; i++) {
            var material = loader.parse(json[i]);
            materials[material.uuid] = material;
          }
        }
        return materials;
      },
      parseAnimations: function(json) {
        var animations = [];
        for (var i = 0; i < json.length; i++) {
          var clip = THREE.AnimationClip.parse(json[i]);
          animations.push(clip);
        }
        return animations;
      },
      parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        function loadImage(url) {
          scope.manager.itemStart(url);
          return loader.load(url, function() {
            scope.manager.itemEnd(url);
          });
        }
        if (json !== undefined && json.length > 0) {
          var manager = new THREE.LoadingManager(onLoad);
          var loader = new THREE.ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          for (var i = 0,
              l = json.length; i < l; i++) {
            var image = json[i];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
            images[image.uuid] = loadImage(path);
          }
        }
        return images;
      },
      parseTextures: function(json, images) {
        function parseConstant(value) {
          if (typeof(value) === 'number')
            return value;
          console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
          return THREE[value];
        }
        var textures = {};
        if (json !== undefined) {
          for (var i = 0,
              l = json.length; i < l; i++) {
            var data = json[i];
            if (data.image === undefined) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined image', data.image);
            }
            var texture = new THREE.Texture(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined)
              texture.name = data.name;
            if (data.mapping !== undefined)
              texture.mapping = parseConstant(data.mapping);
            if (data.offset !== undefined)
              texture.offset = new THREE.Vector2(data.offset[0], data.offset[1]);
            if (data.repeat !== undefined)
              texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
            if (data.minFilter !== undefined)
              texture.minFilter = parseConstant(data.minFilter);
            if (data.magFilter !== undefined)
              texture.magFilter = parseConstant(data.magFilter);
            if (data.anisotropy !== undefined)
              texture.anisotropy = data.anisotropy;
            if (Array.isArray(data.wrap)) {
              texture.wrapS = parseConstant(data.wrap[0]);
              texture.wrapT = parseConstant(data.wrap[1]);
            }
            textures[data.uuid] = texture;
          }
        }
        return textures;
      },
      parseObject: function() {
        var matrix = new THREE.Matrix4();
        return function(data, geometries, materials) {
          var object;
          function getGeometry(name) {
            if (geometries[name] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined geometry', name);
            }
            return geometries[name];
          }
          function getMaterial(name) {
            if (name === undefined)
              return undefined;
            if (materials[name] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined material', name);
            }
            return materials[name];
          }
          switch (data.type) {
            case 'Scene':
              object = new THREE.Scene();
              break;
            case 'PerspectiveCamera':
              object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
              break;
            case 'OrthographicCamera':
              object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              break;
            case 'AmbientLight':
              object = new THREE.AmbientLight(data.color);
              break;
            case 'DirectionalLight':
              object = new THREE.DirectionalLight(data.color, data.intensity);
              break;
            case 'PointLight':
              object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case 'SpotLight':
              object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
              break;
            case 'HemisphereLight':
              object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case 'Mesh':
              object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'LOD':
              object = new THREE.LOD();
              break;
            case 'Line':
              object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
              break;
            case 'PointCloud':
            case 'Points':
              object = new THREE.Points(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'Sprite':
              object = new THREE.Sprite(getMaterial(data.material));
              break;
            case 'Group':
              object = new THREE.Group();
              break;
            default:
              object = new THREE.Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== undefined)
            object.name = data.name;
          if (data.matrix !== undefined) {
            matrix.fromArray(data.matrix);
            matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== undefined)
              object.position.fromArray(data.position);
            if (data.rotation !== undefined)
              object.rotation.fromArray(data.rotation);
            if (data.scale !== undefined)
              object.scale.fromArray(data.scale);
          }
          if (data.castShadow !== undefined)
            object.castShadow = data.castShadow;
          if (data.receiveShadow !== undefined)
            object.receiveShadow = data.receiveShadow;
          if (data.visible !== undefined)
            object.visible = data.visible;
          if (data.userData !== undefined)
            object.userData = data.userData;
          if (data.children !== undefined) {
            for (var child in data.children) {
              object.add(this.parseObject(data.children[child], geometries, materials));
            }
          }
          if (data.type === 'LOD') {
            var levels = data.levels;
            for (var l = 0; l < levels.length; l++) {
              var level = levels[l];
              var child = object.getObjectByProperty('uuid', level.object);
              if (child !== undefined) {
                object.addLevel(child, level.distance);
              }
            }
          }
          return object;
        };
      }()
    };
    THREE.TextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.TextureLoader.prototype = {
      constructor: THREE.TextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var texture = new THREE.Texture();
        var loader = new THREE.ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.CubeTextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.CubeTextureLoader.prototype = {
      constructor: THREE.CubeTextureLoader,
      load: function(urls, onLoad, onProgress, onError) {
        var texture = new THREE.CubeTexture([]);
        var loader = new THREE.ImageLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var loaded = 0;
        function loadTexture(i) {
          loader.load(urls[i], function(image) {
            texture.images[i] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, undefined, onError);
        }
        for (var i = 0; i < urls.length; ++i) {
          loadTexture(i);
        }
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this._parser = null;
    };
    THREE.BinaryTextureLoader.prototype = {
      constructor: THREE.BinaryTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new THREE.DataTexture();
        var loader = new THREE.XHRLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setResponseType('arraybuffer');
        loader.load(url, function(buffer) {
          var texData = scope._parser(buffer);
          if (!texData)
            return;
          if (undefined !== texData.image) {
            texture.image = texData.image;
          } else if (undefined !== texData.data) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
          texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
          texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
          texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
          texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
          if (undefined !== texData.format) {
            texture.format = texData.format;
          }
          if (undefined !== texData.type) {
            texture.type = texData.type;
          }
          if (undefined !== texData.mipmaps) {
            texture.mipmaps = texData.mipmaps;
          }
          if (1 === texData.mipmapCount) {
            texture.minFilter = THREE.LinearFilter;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.CompressedTextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this._parser = null;
    };
    THREE.CompressedTextureLoader.prototype = {
      constructor: THREE.CompressedTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new THREE.CompressedTexture();
        texture.image = images;
        var loader = new THREE.XHRLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setResponseType('arraybuffer');
        if (Array.isArray(url)) {
          var loaded = 0;
          var loadTexture = function(i) {
            loader.load(url[i], function(buffer) {
              var texDatas = scope._parser(buffer, true);
              images[i] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount === 1)
                  texture.minFilter = THREE.LinearFilter;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            }, onProgress, onError);
          };
          for (var i = 0,
              il = url.length; i < il; ++i) {
            loadTexture(i);
          }
        } else {
          loader.load(url, function(buffer) {
            var texDatas = scope._parser(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {mipmaps: []};
                for (var i = 0; i < texDatas.mipmapCount; i++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = THREE.LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.Material = function() {
      Object.defineProperty(this, 'id', {value: THREE.MaterialIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Material';
      this.side = THREE.FrontSide;
      this.opacity = 1;
      this.transparent = false;
      this.blending = THREE.NormalBlending;
      this.blendSrc = THREE.SrcAlphaFactor;
      this.blendDst = THREE.OneMinusSrcAlphaFactor;
      this.blendEquation = THREE.AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = THREE.LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.alphaTest = 0;
      this.overdraw = 0;
      this.visible = true;
      this._needsUpdate = true;
    };
    THREE.Material.prototype = {
      constructor: THREE.Material,
      get needsUpdate() {
        return this._needsUpdate;
      },
      set needsUpdate(value) {
        if (value === true)
          this.update();
        this._needsUpdate = value;
      },
      setValues: function(values) {
        if (values === undefined)
          return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === undefined) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          var currentValue = this[key];
          if (currentValue === undefined) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue instanceof THREE.Color) {
            currentValue.set(newValue);
          } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
            currentValue.copy(newValue);
          } else if (key === 'overdraw') {
            this[key] = Number(newValue);
          } else {
            this[key] = newValue;
          }
        }
      },
      toJSON: function(meta) {
        var data = {metadata: {
            version: 4.4,
            type: 'Material',
            generator: 'Material.toJSON'
          }};
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '')
          data.name = this.name;
        if (this.color instanceof THREE.Color)
          data.color = this.color.getHex();
        if (this.emissive instanceof THREE.Color)
          data.emissive = this.emissive.getHex();
        if (this.specular instanceof THREE.Color)
          data.specular = this.specular.getHex();
        if (this.shininess !== undefined)
          data.shininess = this.shininess;
        if (this.map instanceof THREE.Texture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.alphaMap instanceof THREE.Texture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap instanceof THREE.Texture)
          data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.bumpMap instanceof THREE.Texture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap instanceof THREE.Texture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalScale = this.normalScale;
        }
        if (this.displacementMap instanceof THREE.Texture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.specularMap instanceof THREE.Texture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap instanceof THREE.Texture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          data.reflectivity = this.reflectivity;
        }
        if (this.size !== undefined)
          data.size = this.size;
        if (this.sizeAttenuation !== undefined)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors)
          data.vertexColors = this.vertexColors;
        if (this.shading !== undefined && this.shading !== THREE.SmoothShading)
          data.shading = this.shading;
        if (this.blending !== undefined && this.blending !== THREE.NormalBlending)
          data.blending = this.blending;
        if (this.side !== undefined && this.side !== THREE.FrontSide)
          data.side = this.side;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        return data;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.name = source.name;
        this.side = source.side;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blending = source.blending;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.alphaTest = source.alphaTest;
        this.overdraw = source.overdraw;
        this.visible = source.visible;
        return this;
      },
      update: function() {
        this.dispatchEvent({type: 'update'});
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      },
      get wrapAround() {
        console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
      },
      set wrapAround(boolean) {
        console.warn('THREE.' + this.type + ': .wrapAround has been removed.');
      },
      get wrapRGB() {
        console.warn('THREE.' + this.type + ': .wrapRGB has been removed.');
        return new THREE.Color();
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
    THREE.MaterialIdCount = 0;
    THREE.LineBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.linecap = 'round';
      this.linejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
    THREE.LineBasicMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      this.vertexColors = source.vertexColors;
      this.fog = source.fog;
      return this;
    };
    THREE.LineDashedMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineDashedMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.vertexColors = false;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
    THREE.LineDashedMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      this.vertexColors = source.vertexColors;
      this.fog = source.fog;
      return this;
    };
    THREE.MeshBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.aoMap = null;
      this.aoMapIntensity = 1.0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
    THREE.MeshBasicMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.fog = source.fog;
      this.shading = source.shading;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      return this;
    };
    THREE.MeshLambertMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshLambertMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.map = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
    THREE.MeshLambertMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.emissive.copy(source.emissive);
      this.map = source.map;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.fog = source.fog;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    THREE.MeshPhongMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshPhongMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.specular = new THREE.Color(0x111111);
      this.shininess = 30;
      this.metal = false;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1.0;
      this.aoMap = null;
      this.aoMapIntensity = 1.0;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalScale = new THREE.Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
    THREE.MeshPhongMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.emissive.copy(source.emissive);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.metal = source.metal;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissiveMap = source.emissiveMap;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.fog = source.fog;
      this.shading = source.shading;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      return this;
    };
    THREE.MeshDepthMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshDepthMaterial';
      this.morphTargets = false;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    };
    THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
    THREE.MeshDepthMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    };
    THREE.MeshNormalMaterial = function(parameters) {
      THREE.Material.call(this, parameters);
      this.type = 'MeshNormalMaterial';
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
    THREE.MeshNormalMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    };
    THREE.MultiMaterial = function(materials) {
      this.uuid = THREE.Math.generateUUID();
      this.type = 'MultiMaterial';
      this.materials = materials instanceof Array ? materials : [];
      this.visible = true;
    };
    THREE.MultiMaterial.prototype = {
      constructor: THREE.MultiMaterial,
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.2,
            type: 'material',
            generator: 'MaterialExporter'
          },
          uuid: this.uuid,
          type: this.type,
          materials: []
        };
        for (var i = 0,
            l = this.materials.length; i < l; i++) {
          output.materials.push(this.materials[i].toJSON());
        }
        output.visible = this.visible;
        return output;
      },
      clone: function() {
        var material = new this.constructor();
        for (var i = 0; i < this.materials.length; i++) {
          material.materials.push(this.materials[i].clone());
        }
        material.visible = this.visible;
        return material;
      }
    };
    THREE.MeshFaceMaterial = THREE.MultiMaterial;
    THREE.PointsMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'PointsMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
    THREE.PointsMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      this.vertexColors = source.vertexColors;
      this.fog = source.fog;
      return this;
    };
    THREE.PointCloudMaterial = function(parameters) {
      console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    };
    THREE.ParticleBasicMaterial = function(parameters) {
      console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    };
    THREE.ParticleSystemMaterial = function(parameters) {
      console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
      return new THREE.PointsMaterial(parameters);
    };
    THREE.ShaderMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'ShaderMaterial';
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
      this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
      this.shading = THREE.SmoothShading;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.derivatives = false;
      this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
      };
      this.index0AttributeName = undefined;
      if (parameters !== undefined) {
        if (parameters.attributes !== undefined) {
          console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        }
        this.setValues(parameters);
      }
    };
    THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
    THREE.ShaderMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = THREE.UniformsUtils.clone(source.uniforms);
      this.attributes = source.attributes;
      this.defines = source.defines;
      this.shading = source.shading;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.fog = source.fog;
      this.lights = source.lights;
      this.vertexColors = source.vertexColors;
      this.skinning = source.skinning;
      this.morphTargets = source.morphTargets;
      this.morphNormals = source.morphNormals;
      this.derivatives = source.derivatives;
      return this;
    };
    THREE.ShaderMaterial.prototype.toJSON = function(meta) {
      var data = THREE.Material.prototype.toJSON.call(this, meta);
      data.uniforms = this.uniforms;
      data.attributes = this.attributes;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      return data;
    };
    THREE.RawShaderMaterial = function(parameters) {
      THREE.ShaderMaterial.call(this, parameters);
      this.type = 'RawShaderMaterial';
    };
    THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
    THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
    THREE.SpriteMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'SpriteMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.rotation = 0;
      this.fog = false;
      this.setValues(parameters);
    };
    THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
    THREE.SpriteMaterial.prototype.copy = function(source) {
      THREE.Material.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.map = source.map;
      this.rotation = source.rotation;
      this.fog = source.fog;
      return this;
    };
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      Object.defineProperty(this, 'id', {value: THREE.TextureIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.sourceFile = '';
      this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
      this.mipmaps = [];
      this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
      this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
      this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
      this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
      this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
      this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
      this.format = format !== undefined ? format : THREE.RGBAFormat;
      this.type = type !== undefined ? type : THREE.UnsignedByteType;
      this.offset = new THREE.Vector2(0, 0);
      this.repeat = new THREE.Vector2(1, 1);
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.version = 0;
      this.onUpdate = null;
    };
    THREE.Texture.DEFAULT_IMAGE = undefined;
    THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
    THREE.Texture.prototype = {
      constructor: THREE.Texture,
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        return this;
      },
      toJSON: function(meta) {
        if (meta.textures[this.uuid] !== undefined) {
          return meta.textures[this.uuid];
        }
        function getDataURL(image) {
          var canvas;
          if (image.toDataURL !== undefined) {
            canvas = image;
          } else {
            canvas = document.createElement('canvas');
            canvas.width = image.width;
            canvas.height = image.height;
            canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
          }
          if (canvas.width > 2048 || canvas.height > 2048) {
            return canvas.toDataURL('image/jpeg', 0.6);
          } else {
            return canvas.toDataURL('image/png');
          }
        }
        var output = {
          metadata: {
            version: 4.4,
            type: 'Texture',
            generator: 'Texture.toJSON'
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          wrap: [this.wrapS, this.wrapT],
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy
        };
        if (this.image !== undefined) {
          var image = this.image;
          if (image.uuid === undefined) {
            image.uuid = THREE.Math.generateUUID();
          }
          if (meta.images[image.uuid] === undefined) {
            meta.images[image.uuid] = {
              uuid: image.uuid,
              url: getDataURL(image)
            };
          }
          output.image = image.uuid;
        }
        meta.textures[this.uuid] = output;
        return output;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      },
      transformUv: function(uv) {
        if (this.mapping !== THREE.UVMapping)
          return;
        uv.multiply(this.repeat);
        uv.add(this.offset);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case THREE.RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case THREE.ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case THREE.MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case THREE.RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case THREE.ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case THREE.MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
    THREE.TextureIdCount = 0;
    THREE.CanvasTexture = function(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      THREE.Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.needsUpdate = true;
    };
    THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
    THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
      THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.images = images;
      this.flipY = false;
    };
    THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
    THREE.CubeTexture.prototype.copy = function(source) {
      THREE.Texture.prototype.copy.call(this, source);
      this.images = source.images;
      return this;
    };
    THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        width: width,
        height: height
      };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    };
    THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
    THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        data: data,
        width: width,
        height: height
      };
      this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
      this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    };
    THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.DataTexture.prototype.constructor = THREE.DataTexture;
    THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.generateMipmaps = false;
      var scope = this;
      function update() {
        requestAnimationFrame(update);
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          scope.needsUpdate = true;
        }
      }
      update();
    };
    THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
    THREE.Group = function() {
      THREE.Object3D.call(this);
      this.type = 'Group';
    };
    THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Group.prototype.constructor = THREE.Group;
    THREE.Points = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'Points';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.PointsMaterial({color: Math.random() * 0xffffff});
    };
    THREE.Points.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Points.prototype.constructor = THREE.Points;
    THREE.Points.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      return function raycast(raycaster, intersects) {
        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.Points.threshold;
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false) {
            return;
          }
        }
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var position = new THREE.Vector3();
        function testPoint(point, index) {
          var rayPointDistanceSq = ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            var intersectPoint = ray.closestPointToPoint(point);
            intersectPoint.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far)
              return;
            intersects.push({
              distance: distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object
            });
          }
        }
        if (geometry instanceof THREE.BufferGeometry) {
          var index = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (index !== null) {
            var indices = index.array;
            for (var i = 0,
                il = indices.length; i < il; i++) {
              var a = indices[i];
              position.fromArray(positions, a * 3);
              testPoint(position, a);
            }
          } else {
            for (var i = 0,
                l = positions.length / 3; i < l; i++) {
              position.fromArray(positions, i * 3);
              testPoint(position, i);
            }
          }
        } else {
          var vertices = geometry.vertices;
          for (var i = 0,
              l = vertices.length; i < l; i++) {
            testPoint(vertices[i], i);
          }
        }
      };
    }());
    THREE.Points.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    };
    THREE.PointCloud = function(geometry, material) {
      console.warn('THREE.PointCloud has been renamed to THREE.Points.');
      return new THREE.Points(geometry, material);
    };
    THREE.ParticleSystem = function(geometry, material) {
      console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
      return new THREE.Points(geometry, material);
    };
    THREE.Line = function(geometry, material, mode) {
      if (mode === 1) {
        console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
        return new THREE.LineSegments(geometry, material);
      }
      THREE.Object3D.call(this);
      this.type = 'Line';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.LineBasicMaterial({color: Math.random() * 0xffffff});
    };
    THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Line.prototype.constructor = THREE.Line;
    THREE.Line.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      return function raycast(raycaster, intersects) {
        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;
        var geometry = this.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
          return;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this instanceof THREE.LineSegments ? 2 : 1;
        if (geometry instanceof THREE.BufferGeometry) {
          var index = geometry.index;
          var attributes = geometry.attributes;
          if (index !== null) {
            var indices = index.array;
            var positions = attributes.position.array;
            for (var i = 0,
                l = indices.length - 1; i < l; i += step) {
              var a = indices[i];
              var b = indices[i + 1];
              vStart.fromArray(positions, a * 3);
              vEnd.fromArray(positions, b * 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > precisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            var positions = attributes.position.array;
            for (var i = 0,
                l = positions.length / 3 - 1; i < l; i += step) {
              vStart.fromArray(positions, 3 * i);
              vEnd.fromArray(positions, 3 * i + 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > precisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var vertices = geometry.vertices;
          var nbVertices = vertices.length;
          for (var i = 0; i < nbVertices - 1; i += step) {
            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
            if (distSq > precisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      };
    }());
    THREE.Line.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    };
    THREE.LineStrip = 0;
    THREE.LinePieces = 1;
    THREE.LineSegments = function(geometry, material) {
      THREE.Line.call(this, geometry, material);
      this.type = 'LineSegments';
    };
    THREE.LineSegments.prototype = Object.create(THREE.Line.prototype);
    THREE.LineSegments.prototype.constructor = THREE.LineSegments;
    THREE.Mesh = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'Mesh';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});
      this.updateMorphTargets();
    };
    THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Mesh.prototype.constructor = THREE.Mesh;
    THREE.Mesh.prototype.updateMorphTargets = function() {
      if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1;
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var m = 0,
            ml = this.geometry.morphTargets.length; m < ml; m++) {
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
        }
      }
    };
    THREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {
      if (this.morphTargetDictionary[name] !== undefined) {
        return this.morphTargetDictionary[name];
      }
      console.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
      return 0;
    };
    THREE.Mesh.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      var vA = new THREE.Vector3();
      var vB = new THREE.Vector3();
      var vC = new THREE.Vector3();
      var tempA = new THREE.Vector3();
      var tempB = new THREE.Vector3();
      var tempC = new THREE.Vector3();
      var uvA = new THREE.Vector2();
      var uvB = new THREE.Vector2();
      var uvC = new THREE.Vector2();
      var barycoord = new THREE.Vector3();
      var intersectionPoint = new THREE.Vector3();
      var intersectionPointWorld = new THREE.Vector3();
      function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
        THREE.Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
        uv1.multiplyScalar(barycoord.x);
        uv2.multiplyScalar(barycoord.y);
        uv3.multiplyScalar(barycoord.z);
        uv1.add(uv2).add(uv3);
        return uv1.clone();
      }
      function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
        var intersect;
        var material = object.material;
        if (material.side === THREE.BackSide) {
          intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray.intersectTriangle(pA, pB, pC, material.side !== THREE.DoubleSide, point);
        }
        if (intersect === null)
          return null;
        intersectionPointWorld.copy(point);
        intersectionPointWorld.applyMatrix4(object.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance: distance,
          point: intersectionPointWorld.clone(),
          object: object
        };
      }
      function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
        vA.fromArray(positions, a * 3);
        vB.fromArray(positions, b * 3);
        vC.fromArray(positions, c * 3);
        var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
        if (intersection) {
          if (uvs) {
            uvA.fromArray(uvs, a * 2);
            uvB.fromArray(uvs, b * 2);
            uvC.fromArray(uvs, c * 2);
            intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
          }
          intersection.face = new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC));
          intersection.faceIndex = a;
        }
        return intersection;
      }
      return function raycast(raycaster, intersects) {
        var geometry = this.geometry;
        var material = this.material;
        if (material === undefined)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        var matrixWorld = this.matrixWorld;
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false)
          return;
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false)
            return;
        }
        var uvs,
            intersection;
        if (geometry instanceof THREE.BufferGeometry) {
          var a,
              b,
              c;
          var index = geometry.index;
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (attributes.uv !== undefined) {
            uvs = attributes.uv.array;
          }
          if (index !== null) {
            var indices = index.array;
            for (var i = 0,
                l = indices.length; i < l; i += 3) {
              a = indices[i];
              b = indices[i + 1];
              c = indices[i + 2];
              intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects.push(intersection);
              }
            }
          } else {
            for (var i = 0,
                l = positions.length; i < l; i += 9) {
              a = i / 3;
              b = a + 1;
              c = a + 2;
              intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c);
              if (intersection) {
                intersection.index = a;
                intersects.push(intersection);
              }
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var fvA,
              fvB,
              fvC;
          var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
          var materials = isFaceMaterial === true ? material.materials : null;
          var vertices = geometry.vertices;
          var faces = geometry.faces;
          var faceVertexUvs = geometry.faceVertexUvs[0];
          if (faceVertexUvs.length > 0)
            uvs = faceVertexUvs;
          for (var f = 0,
              fl = faces.length; f < fl; f++) {
            var face = faces[f];
            var faceMaterial = isFaceMaterial === true ? materials[face.materialIndex] : material;
            if (faceMaterial === undefined)
              continue;
            fvA = vertices[face.a];
            fvB = vertices[face.b];
            fvC = vertices[face.c];
            if (faceMaterial.morphTargets === true) {
              var morphTargets = geometry.morphTargets;
              var morphInfluences = this.morphTargetInfluences;
              vA.set(0, 0, 0);
              vB.set(0, 0, 0);
              vC.set(0, 0, 0);
              for (var t = 0,
                  tl = morphTargets.length; t < tl; t++) {
                var influence = morphInfluences[t];
                if (influence === 0)
                  continue;
                var targets = morphTargets[t].vertices;
                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
              }
              vA.add(fvA);
              vB.add(fvB);
              vC.add(fvC);
              fvA = vA;
              fvB = vB;
              fvC = vC;
            }
            intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
            if (intersection) {
              if (uvs) {
                var uvs_f = uvs[f];
                uvA.copy(uvs_f[0]);
                uvB.copy(uvs_f[1]);
                uvC.copy(uvs_f[2]);
                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
              }
              intersection.face = face;
              intersection.faceIndex = f;
              intersects.push(intersection);
            }
          }
        }
      };
    }());
    THREE.Mesh.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    };
    THREE.Bone = function(skin) {
      THREE.Object3D.call(this);
      this.type = 'Bone';
      this.skin = skin;
    };
    THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Bone.prototype.constructor = THREE.Bone;
    THREE.Bone.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.skin = source.skin;
      return this;
    };
    THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
      this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
      this.identityMatrix = new THREE.Matrix4();
      bones = bones || [];
      this.bones = bones.slice(0);
      if (this.useVertexTexture) {
        var size = Math.sqrt(this.bones.length * 4);
        size = THREE.Math.nextPowerOfTwo(Math.ceil(size));
        size = Math.max(size, 4);
        this.boneTextureWidth = size;
        this.boneTextureHeight = size;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
      } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
      }
      if (boneInverses === undefined) {
        this.calculateInverses();
      } else {
        if (this.bones.length === boneInverses.length) {
          this.boneInverses = boneInverses.slice(0);
        } else {
          console.warn('THREE.Skeleton bonInverses is the wrong length.');
          this.boneInverses = [];
          for (var b = 0,
              bl = this.bones.length; b < bl; b++) {
            this.boneInverses.push(new THREE.Matrix4());
          }
        }
      }
    };
    THREE.Skeleton.prototype.calculateInverses = function() {
      this.boneInverses = [];
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        if (this.bones[b]) {
          inverse.getInverse(this.bones[b].matrixWorld);
        }
        this.boneInverses.push(inverse);
      }
    };
    THREE.Skeleton.prototype.pose = function() {
      var bone;
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          bone.matrixWorld.getInverse(this.boneInverses[b]);
        }
      }
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          if (bone.parent) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    };
    THREE.Skeleton.prototype.update = (function() {
      var offsetMatrix = new THREE.Matrix4();
      return function update() {
        for (var b = 0,
            bl = this.bones.length; b < bl; b++) {
          var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
          offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
          offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
        }
        if (this.useVertexTexture) {
          this.boneTexture.needsUpdate = true;
        }
      };
    })();
    THREE.Skeleton.prototype.clone = function() {
      return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
    };
    THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
      THREE.Mesh.call(this, geometry, material);
      this.type = 'SkinnedMesh';
      this.bindMode = "attached";
      this.bindMatrix = new THREE.Matrix4();
      this.bindMatrixInverse = new THREE.Matrix4();
      var bones = [];
      if (this.geometry && this.geometry.bones !== undefined) {
        var bone,
            gbone;
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          bone = new THREE.Bone(this);
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.fromArray(gbone.pos);
          bone.quaternion.fromArray(gbone.rotq);
          if (gbone.scl !== undefined)
            bone.scale.fromArray(gbone.scl);
        }
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          if (gbone.parent !== -1 && gbone.parent !== null) {
            bones[gbone.parent].add(bones[b]);
          } else {
            this.add(bones[b]);
          }
        }
      }
      this.normalizeSkinWeights();
      this.updateMatrixWorld(true);
      this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture), this.matrixWorld);
    };
    THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
    THREE.SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.getInverse(bindMatrix);
    };
    THREE.SkinnedMesh.prototype.pose = function() {
      this.skeleton.pose();
    };
    THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
      if (this.geometry instanceof THREE.Geometry) {
        for (var i = 0; i < this.geometry.skinIndices.length; i++) {
          var sw = this.geometry.skinWeights[i];
          var scale = 1.0 / sw.lengthManhattan();
          if (scale !== Infinity) {
            sw.multiplyScalar(scale);
          } else {
            sw.set(1);
          }
        }
      } else {}
    };
    THREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {
      THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
      } else {
        console.warn('THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode);
      }
    };
    THREE.SkinnedMesh.prototype.clone = function() {
      return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this);
    };
    THREE.LOD = function() {
      THREE.Object3D.call(this);
      this.type = 'LOD';
      Object.defineProperties(this, {
        levels: {
          enumerable: true,
          value: []
        },
        objects: {get: function() {
            console.warn('THREE.LOD: .objects has been renamed to .levels.');
            return this.levels;
          }}
      });
    };
    THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LOD.prototype.constructor = THREE.LOD;
    THREE.LOD.prototype.addLevel = function(object, distance) {
      if (distance === undefined)
        distance = 0;
      distance = Math.abs(distance);
      var levels = this.levels;
      for (var l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }
      levels.splice(l, 0, {
        distance: distance,
        object: object
      });
      this.add(object);
    };
    THREE.LOD.prototype.getObjectForDistance = function(distance) {
      var levels = this.levels;
      for (var i = 1,
          l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    };
    THREE.LOD.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function raycast(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      };
    }());
    THREE.LOD.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function update(camera) {
        var levels = this.levels;
        if (levels.length > 1) {
          v1.setFromMatrixPosition(camera.matrixWorld);
          v2.setFromMatrixPosition(this.matrixWorld);
          var distance = v1.distanceTo(v2);
          levels[0].object.visible = true;
          for (var i = 1,
              l = levels.length; i < l; i++) {
            if (distance >= levels[i].distance) {
              levels[i - 1].object.visible = false;
              levels[i].object.visible = true;
            } else {
              break;
            }
          }
          for (; i < l; i++) {
            levels[i].object.visible = false;
          }
        }
      };
    }();
    THREE.LOD.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source, false);
      var levels = source.levels;
      for (var i = 0,
          l = levels.length; i < l; i++) {
        var level = levels[i];
        this.addLevel(level.object.clone(), level.distance);
      }
      return this;
    };
    THREE.LOD.prototype.toJSON = function(meta) {
      var data = THREE.Object3D.prototype.toJSON.call(this, meta);
      data.object.levels = [];
      var levels = this.levels;
      for (var i = 0,
          l = levels.length; i < l; i++) {
        var level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }
      return data;
    };
    THREE.Sprite = (function() {
      var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
      var vertices = new Float32Array([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0]);
      var uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      return function Sprite(material) {
        THREE.Object3D.call(this);
        this.type = 'Sprite';
        this.geometry = geometry;
        this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();
      };
    })();
    THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Sprite.prototype.constructor = THREE.Sprite;
    THREE.Sprite.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function raycast(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition);
        var guessSizeSq = this.scale.x * this.scale.y;
        if (distanceSq > guessSizeSq) {
          return;
        }
        intersects.push({
          distance: Math.sqrt(distanceSq),
          point: this.position,
          face: null,
          object: this
        });
      };
    }());
    THREE.Sprite.prototype.clone = function() {
      return new this.constructor(this.material).copy(this);
    };
    THREE.Particle = THREE.Sprite;
    THREE.LensFlare = function(texture, size, distance, blending, color) {
      THREE.Object3D.call(this);
      this.lensFlares = [];
      this.positionScreen = new THREE.Vector3();
      this.customUpdateCallback = undefined;
      if (texture !== undefined) {
        this.add(texture, size, distance, blending, color);
      }
    };
    THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LensFlare.prototype.constructor = THREE.LensFlare;
    THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {
      if (size === undefined)
        size = -1;
      if (distance === undefined)
        distance = 0;
      if (opacity === undefined)
        opacity = 1;
      if (color === undefined)
        color = new THREE.Color(0xffffff);
      if (blending === undefined)
        blending = THREE.NormalBlending;
      distance = Math.min(distance, Math.max(0, distance));
      this.lensFlares.push({
        texture: texture,
        size: size,
        distance: distance,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 0,
        opacity: opacity,
        color: color,
        blending: blending
      });
    };
    THREE.LensFlare.prototype.updateLensFlares = function() {
      var f,
          fl = this.lensFlares.length;
      var flare;
      var vecX = -this.positionScreen.x * 2;
      var vecY = -this.positionScreen.y * 2;
      for (f = 0; f < fl; f++) {
        flare = this.lensFlares[f];
        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;
        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
      }
    };
    THREE.LensFlare.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      this.positionScreen.copy(source.positionScreen);
      this.customUpdateCallback = source.customUpdateCallback;
      for (var i = 0,
          l = source.lensFlares.length; i < l; i++) {
        this.lensFlares.push(source.lensFlares[i]);
      }
      return this;
    };
    THREE.Scene = function() {
      THREE.Object3D.call(this);
      this.type = 'Scene';
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
    };
    THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Scene.prototype.constructor = THREE.Scene;
    THREE.Scene.prototype.copy = function(source) {
      THREE.Object3D.prototype.copy.call(this, source);
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    };
    THREE.Fog = function(color, near, far) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.near = (near !== undefined) ? near : 1;
      this.far = (far !== undefined) ? far : 1000;
    };
    THREE.Fog.prototype.clone = function() {
      return new THREE.Fog(this.color.getHex(), this.near, this.far);
    };
    THREE.FogExp2 = function(color, density) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.density = (density !== undefined) ? density : 0.00025;
    };
    THREE.FogExp2.prototype.clone = function() {
      return new THREE.FogExp2(this.color.getHex(), this.density);
    };
    THREE.ShaderChunk = {};
    THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
    THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";
    THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
    THREE.ShaderChunk['aomap_fragment'] = "#ifdef USE_AOMAP\n\n	totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";
    THREE.ShaderChunk['aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif";
    THREE.ShaderChunk['begin_vertex'] = "\nvec3 transformed = vec3( position );\n";
    THREE.ShaderChunk['beginnormal_vertex'] = "\nvec3 objectNormal = vec3( normal );\n";
    THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";
    THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";
    THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";
    THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = color.xyz;\n\n#endif";
    THREE.ShaderChunk['common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n	if ( decayExponent > 0.0 ) {\n\n	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n\n	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n\n	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n	vec3 halfDir = normalize( lightDir + viewDir );\n\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( lightDir, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n	#ifdef GAMMA_INPUT\n\n		return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n	#ifdef GAMMA_OUTPUT\n\n		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n	#else\n\n		return a;\n\n	#endif\n\n}\n";
    THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
    THREE.ShaderChunk['displacementmap_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
    THREE.ShaderChunk['displacementmap_pars_vertex'] = "#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n";
    THREE.ShaderChunk['emissivemap_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n	totalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";
    THREE.ShaderChunk['emissivemap_pars_fragment'] = "#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n";
    THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";
    THREE.ShaderChunk['envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
    THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";
    THREE.ShaderChunk['hemilight_fragment'] = "#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalAmbientLight += lightColor;\n\n	}\n\n#endif\n\n";
    THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";
    THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif";
    THREE.ShaderChunk['lights_lambert_pars_vertex'] = "#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";
    THREE.ShaderChunk['lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lVector = pointLightPosition[ i ] - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition - mvPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float dotProduct = dot( normal, lightDir );\n\n			vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		vLightFront += lightColor * saturate( dotProduct );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += lightColor * saturate( - dotProduct );\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lightDir = hemisphereLightDirection[ i ];\n\n\n		float dotProduct = dot( normal, lightDir );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_fragment'] = "vec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = pointLightColor[ i ];\n\n		vec3 lightPosition = pointLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec3 lightColor = spotLightColor[ i ];\n\n		vec3 lightPosition = spotLightPosition[ i ];\n		vec3 lVector = lightPosition + vViewPosition.xyz;\n		vec3 lightDir = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], lightDir );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			attenuation *= spotEffect;\n\n\n			float cosineTerm = saturate( dot( normal, lightDir ) );\n\n			totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n\n			vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n			totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 lightColor = directionalLightColor[ i ];\n\n		vec3 lightDir = directionalLightDirection[ i ];\n\n\n		float cosineTerm = saturate( dot( normal, lightDir ) );\n\n		totalDiffuseLight += lightColor * cosineTerm;\n\n\n		vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n		totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n";
    THREE.ShaderChunk['linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
    THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
    THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";
    THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif\n";
    THREE.ShaderChunk['map_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";
    THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
    THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";
    THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
    THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['normal_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n";
    THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['project_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
    THREE.ShaderChunk['shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		float texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n		float shadow = 0.0;\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		bool isPointLight = shadowDarkness[ i ] < 0.0;\n\n		if ( isPointLight ) {\n\n			float realShadowDarkness = abs( shadowDarkness[ i ] );\n\n			vec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n	#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n			const float Dr = 1.25;\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			const float Dr = 2.25;\n	#endif\n\n			float os = Dr *  2.0 * texelSizeY;\n\n			const vec3 Gsd = vec3( - 1, 0, 1 );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n	#else \n			vec3 bd3D = normalize( lightToPosition );\n			float dp = length( lightToPosition );\n\n			adjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n			shadow *= realShadowDarkness;\n\n	#endif\n\n		} else {\n\n#endif \n			float texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n			vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\n			bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n			bool inFrustum = all( inFrustumVec );\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n			bool frustumTest = all( frustumTestVec );\n\n			if ( frustumTest ) {\n\n	#if defined( SHADOWMAP_TYPE_PCF )\n\n\n				/*\n					for ( float y = -1.25; y <= 1.25; y += 1.25 )\n						for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n							vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n							float fDepth = unpackDepth( rgbaDepth );\n							if ( fDepth < shadowCoord.z )\n								shadow += 1.0;\n					}\n					shadow /= 9.0;\n				*/\n\n				shadowCoord.z += shadowBias[ i ];\n\n				const float ShadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.25 * xPixelOffset;\n				float dy0 = - 1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				float fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n				shadow *= shadowDarkness[ i ];\n\n	#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\n				shadowCoord.z += shadowBias[ i ];\n\n				float xPixelOffset = texelSizeX;\n				float yPixelOffset = texelSizeY;\n\n				float dx0 = - 1.0 * xPixelOffset;\n				float dy0 = - 1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n				shadowKernel[ 0 ] *= vec3( 0.25 );\n\n				shadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n				shadowKernel[ 1 ] *= vec3( 0.25 );\n\n				shadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n				shadowKernel[ 2 ] *= vec3( 0.25 );\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n				shadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n				shadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n	#else \n				shadowCoord.z += shadowBias[ i ];\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n					shadow = shadowDarkness[ i ];\n\n	#endif\n\n			}\n\n#ifdef SHADOWMAP_DEBUG\n\n			if ( inFrustum ) {\n\n				if ( i == 0 ) {\n\n					outgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n				} else if ( i == 1 ) {\n\n					outgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n				} else {\n\n					outgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n				}\n\n			}\n\n#endif\n\n#if defined( POINT_LIGHT_SHADOWS )\n\n		}\n\n#endif\n\n		shadowMask = shadowMask * vec3( 1.0 - shadow );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n	#if defined(POINT_LIGHT_SHADOWS)\n\n\n		void adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n			const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n			if ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n				shadowValue += 1.0;\n\n		}\n\n\n		vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\n			vec3 absV = abs( v );\n\n\n			float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n			absV *= scaleToCube;\n\n\n			v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\n\n			vec2 planar = v.xy;\n\n			float almostATexel = 1.5 * texelSizeY;\n			float almostOne = 1.0 - almostATexel;\n\n			if ( absV.z >= almostOne ) {\n\n				if ( v.z > 0.0 )\n					planar.x = 4.0 - v.x;\n\n			} else if ( absV.x >= almostOne ) {\n\n				float signX = sign( v.x );\n				planar.x = v.z * signX + 2.0 * signX;\n\n			} else if ( absV.y >= almostOne ) {\n\n				float signY = sign( v.y );\n				planar.x = v.x + 2.0 * signY + 2.0;\n				planar.y = v.z * signY - 2.0;\n\n			}\n\n\n			return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n		}\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n#endif";
    THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";
    THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
    THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";
    THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
    THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";
    THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";
    THREE.ShaderChunk['uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk['uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk['uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = uv2;\n\n#endif";
    THREE.ShaderChunk['uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n\n#endif";
    THREE.ShaderChunk['uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";
    THREE.ShaderChunk['uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
    THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n	#endif\n\n#endif\n";
    THREE.UniformsUtils = {
      merge: function(uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
          var tmp = this.clone(uniforms[u]);
          for (var p in tmp) {
            merged[p] = tmp[p];
          }
        }
        return merged;
      },
      clone: function(uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
          uniforms_dst[u] = {};
          for (var p in uniforms_src[u]) {
            var parameter_src = uniforms_src[u][p];
            if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix3 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
              uniforms_dst[u][p] = parameter_src.clone();
            } else if (Array.isArray(parameter_src)) {
              uniforms_dst[u][p] = parameter_src.slice();
            } else {
              uniforms_dst[u][p] = parameter_src;
            }
          }
        }
        return uniforms_dst;
      }
    };
    THREE.UniformsLib = {
      common: {
        "diffuse": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "specularMap": {
          type: "t",
          value: null
        },
        "alphaMap": {
          type: "t",
          value: null
        },
        "envMap": {
          type: "t",
          value: null
        },
        "flipEnvMap": {
          type: "f",
          value: -1
        },
        "reflectivity": {
          type: "f",
          value: 1.0
        },
        "refractionRatio": {
          type: "f",
          value: 0.98
        }
      },
      aomap: {
        "aoMap": {
          type: "t",
          value: null
        },
        "aoMapIntensity": {
          type: "f",
          value: 1
        }
      },
      lightmap: {
        "lightMap": {
          type: "t",
          value: null
        },
        "lightMapIntensity": {
          type: "f",
          value: 1
        }
      },
      emissivemap: {"emissiveMap": {
          type: "t",
          value: null
        }},
      bumpmap: {
        "bumpMap": {
          type: "t",
          value: null
        },
        "bumpScale": {
          type: "f",
          value: 1
        }
      },
      normalmap: {
        "normalMap": {
          type: "t",
          value: null
        },
        "normalScale": {
          type: "v2",
          value: new THREE.Vector2(1, 1)
        }
      },
      displacementmap: {
        "displacementMap": {
          type: "t",
          value: null
        },
        "displacementScale": {
          type: "f",
          value: 1
        },
        "displacementBias": {
          type: "f",
          value: 0
        }
      },
      fog: {
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      lights: {
        "ambientLightColor": {
          type: "fv",
          value: []
        },
        "directionalLightDirection": {
          type: "fv",
          value: []
        },
        "directionalLightColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightDirection": {
          type: "fv",
          value: []
        },
        "hemisphereLightSkyColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightGroundColor": {
          type: "fv",
          value: []
        },
        "pointLightColor": {
          type: "fv",
          value: []
        },
        "pointLightPosition": {
          type: "fv",
          value: []
        },
        "pointLightDistance": {
          type: "fv1",
          value: []
        },
        "pointLightDecay": {
          type: "fv1",
          value: []
        },
        "spotLightColor": {
          type: "fv",
          value: []
        },
        "spotLightPosition": {
          type: "fv",
          value: []
        },
        "spotLightDirection": {
          type: "fv",
          value: []
        },
        "spotLightDistance": {
          type: "fv1",
          value: []
        },
        "spotLightAngleCos": {
          type: "fv1",
          value: []
        },
        "spotLightExponent": {
          type: "fv1",
          value: []
        },
        "spotLightDecay": {
          type: "fv1",
          value: []
        }
      },
      points: {
        "psColor": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "size": {
          type: "f",
          value: 1.0
        },
        "scale": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      shadowmap: {
        "shadowMap": {
          type: "tv",
          value: []
        },
        "shadowMapSize": {
          type: "v2v",
          value: []
        },
        "shadowBias": {
          type: "fv1",
          value: []
        },
        "shadowDarkness": {
          type: "fv1",
          value: []
        },
        "shadowMatrix": {
          type: "m4v",
          value: []
        }
      }
    };
    THREE.ShaderLib = {
      'basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["aomap"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "	#ifdef USE_ENVMAP", THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "	#endif", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["aomap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = vec3( 1.0 );", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["aomap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	outgoingLight = diffuseColor.rgb * totalAmbientLight * shadowMask;", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'lambert': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {"emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          }}]),
        vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_lambert_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_lambert_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "uniform vec3 ambientLightColor;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = ambientLightColor;", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;", "		else", "			outgoingLight += diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + emissive;", "	#else", "		outgoingLight += diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + emissive;", "	#endif", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'phong': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["aomap"], THREE.UniformsLib["lightmap"], THREE.UniformsLib["emissivemap"], THREE.UniformsLib["bumpmap"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["displacementmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
          "emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          },
          "specular": {
            type: "c",
            value: new THREE.Color(0x111111)
          },
          "shininess": {
            type: "f",
            value: 30
          }
        }]),
        vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["uv_pars_vertex"], THREE.ShaderChunk["uv2_pars_vertex"], THREE.ShaderChunk["displacementmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["uv_vertex"], THREE.ShaderChunk["uv2_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["beginnormal_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["displacementmap_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "	vViewPosition = - mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["uv_pars_fragment"], THREE.ShaderChunk["uv2_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["aomap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["emissivemap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", "	vec3 totalAmbientLight = ambientLightColor;", "	vec3 totalEmissiveLight = emissive;", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["normal_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["hemilight_fragment"], THREE.ShaderChunk["aomap_fragment"], THREE.ShaderChunk["emissivemap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "totalDiffuseLight *= shadowMask;", "totalSpecularLight *= shadowMask;", "#ifdef METAL", "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + totalEmissiveLight;", "#else", "	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + totalEmissiveLight;", "#endif", THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'points': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["points"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( psColor, opacity );", "	vec3 shadowMask = vec3( 1.0 );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_particle_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["shadowmap_fragment"], "	outgoingLight = diffuseColor.rgb * shadowMask;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'dashed': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], {
          "scale": {
            type: "f",
            value: 1
          },
          "dashSize": {
            type: "f",
            value: 1
          },
          "totalSize": {
            type: "f",
            value: 2
          }
        }]),
        vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["color_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'depth': {
        uniforms: {
          "mNear": {
            type: "f",
            value: 1.0
          },
          "mFar": {
            type: "f",
            value: 2000.0
          },
          "opacity": {
            type: "f",
            value: 1.0
          }
        },
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
      },
      'normal': {
        uniforms: {"opacity": {
            type: "f",
            value: 1.0
          }},
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'cube': {
        uniforms: {
          "tCube": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'equirect': {
        uniforms: {
          "tEquirect": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'depthRGBA': {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
      },
      'distanceRGBA': {
        uniforms: {"lightPos": {
            type: "v3",
            value: new THREE.Vector3(0, 0, 0)
          }},
        vertexShader: ["varying vec4 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["begin_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["project_vertex"], THREE.ShaderChunk["worldpos_vertex"], "vWorldPosition = worldPosition;", "}"].join("\n"),
        fragmentShader: ["uniform vec3 lightPos;", "varying vec4 vWorldPosition;", THREE.ShaderChunk["common"], "vec4 pack1K ( float depth ) {", "   depth /= 1000.0;", "   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = fract( depth * bitSh );", "	res -= res.xxyz * bitMsk;", "	return res; ", "}", "float unpack1K ( vec4 color ) {", "	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "	return dot( color, bitSh ) * 1000.0;", "}", "void main () {", "	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );", "}"].join("\n")
      }
    };
    THREE.WebGLRenderer = function(parameters) {
      console.log('THREE.WebGLRenderer', THREE.REVISION);
      parameters = parameters || {};
      var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),
          _context = parameters.context !== undefined ? parameters.context : null,
          _width = _canvas.width,
          _height = _canvas.height,
          pixelRatio = 1,
          _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
          _depth = parameters.depth !== undefined ? parameters.depth : true,
          _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
          _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
          _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
          _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
          _clearColor = new THREE.Color(0x000000),
          _clearAlpha = 0;
      var lights = [];
      var opaqueObjects = [];
      var opaqueObjectsLastIndex = -1;
      var transparentObjects = [];
      var transparentObjectsLastIndex = -1;
      var morphInfluences = new Float32Array(8);
      var sprites = [];
      var lensFlares = [];
      this.domElement = _canvas;
      this.context = null;
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.gammaFactor = 2.0;
      this.gammaInput = false;
      this.gammaOutput = false;
      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;
      this.autoScaleCubemaps = true;
      var _this = this,
          _currentProgram = null,
          _currentFramebuffer = null,
          _currentMaterialId = -1,
          _currentGeometryProgram = '',
          _currentCamera = null,
          _usedTextureUnits = 0,
          _viewportX = 0,
          _viewportY = 0,
          _viewportWidth = _canvas.width,
          _viewportHeight = _canvas.height,
          _currentWidth = 0,
          _currentHeight = 0,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _vector3 = new THREE.Vector3(),
          _direction = new THREE.Vector3(),
          _lightsNeedUpdate = true,
          _lights = {
            ambient: [0, 0, 0],
            directional: {
              length: 0,
              colors: [],
              positions: []
            },
            point: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              decays: []
            },
            spot: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              directions: [],
              anglesCos: [],
              exponents: [],
              decays: []
            },
            hemi: {
              length: 0,
              skyColors: [],
              groundColors: [],
              positions: []
            }
          },
          _infoMemory = {
            geometries: 0,
            textures: 0
          },
          _infoRender = {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
          };
      this.info = {
        render: _infoRender,
        memory: _infoMemory,
        programs: null
      };
      var _gl;
      try {
        var attributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer
        };
        _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
        if (_gl === null) {
          if (_canvas.getContext('webgl') !== null) {
            throw 'Error creating WebGL context with your selected attributes.';
          } else {
            throw 'Error creating WebGL context.';
          }
        }
        _canvas.addEventListener('webglcontextlost', onContextLost, false);
      } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error);
      }
      var extensions = new THREE.WebGLExtensions(_gl);
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_float_linear');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('ANGLE_instanced_arrays');
      if (extensions.get('OES_element_index_uint')) {
        THREE.BufferGeometry.MaxIndex = 4294967296;
      }
      var capabilities = new THREE.WebGLCapabilities(_gl, extensions, parameters);
      var state = new THREE.WebGLState(_gl, extensions, paramThreeToGL);
      var properties = new THREE.WebGLProperties();
      var objects = new THREE.WebGLObjects(_gl, properties, this.info);
      var programCache = new THREE.WebGLPrograms(this, capabilities);
      this.info.programs = programCache.programs;
      var bufferRenderer = new THREE.WebGLBufferRenderer(_gl, extensions, _infoRender);
      var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
      function glClearColor(r, g, b, a) {
        if (_premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        _gl.clearColor(r, g, b, a);
      }
      function setDefaultGLState() {
        state.init();
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      }
      function resetGLState() {
        _currentProgram = null;
        _currentCamera = null;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _lightsNeedUpdate = true;
        state.reset();
      }
      setDefaultGLState();
      this.context = _gl;
      this.capabilities = capabilities;
      this.extensions = extensions;
      this.state = state;
      var shadowMap = new THREE.WebGLShadowMap(this, lights, objects);
      this.shadowMap = shadowMap;
      var spritePlugin = new THREE.SpritePlugin(this, sprites);
      var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
      this.getContext = function() {
        return _gl;
      };
      this.getContextAttributes = function() {
        return _gl.getContextAttributes();
      };
      this.forceContextLoss = function() {
        extensions.get('WEBGL_lose_context').loseContext();
      };
      this.getMaxAnisotropy = (function() {
        var value;
        return function getMaxAnisotropy() {
          if (value !== undefined)
            return value;
          var extension = extensions.get('EXT_texture_filter_anisotropic');
          if (extension !== null) {
            value = _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else {
            value = 0;
          }
          return value;
        };
      })();
      this.getPrecision = function() {
        return capabilities.precision;
      };
      this.getPixelRatio = function() {
        return pixelRatio;
      };
      this.setPixelRatio = function(value) {
        if (value !== undefined)
          pixelRatio = value;
      };
      this.getSize = function() {
        return {
          width: _width,
          height: _height
        };
      };
      this.setSize = function(width, height, updateStyle) {
        _width = width;
        _height = height;
        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;
        if (updateStyle !== false) {
          _canvas.style.width = width + 'px';
          _canvas.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
      };
      this.setViewport = function(x, y, width, height) {
        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;
        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
      };
      this.getViewport = function(dimensions) {
        dimensions.x = _viewportX / pixelRatio;
        dimensions.y = _viewportY / pixelRatio;
        dimensions.z = _viewportWidth / pixelRatio;
        dimensions.w = _viewportHeight / pixelRatio;
      };
      this.setScissor = function(x, y, width, height) {
        _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);
      };
      this.enableScissorTest = function(boolean) {
        state.setScissorTest(boolean);
      };
      this.getClearColor = function() {
        return _clearColor;
      };
      this.setClearColor = function(color, alpha) {
        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.getClearAlpha = function() {
        return _clearAlpha;
      };
      this.setClearAlpha = function(alpha) {
        _clearAlpha = alpha;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color)
          bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth)
          bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil)
          bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        _gl.clear(_gl.COLOR_BUFFER_BIT);
      };
      this.clearDepth = function() {
        _gl.clear(_gl.DEPTH_BUFFER_BIT);
      };
      this.clearStencil = function() {
        _gl.clear(_gl.STENCIL_BUFFER_BIT);
      };
      this.clearTarget = function(renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      this.resetGLState = resetGLState;
      this.dispose = function() {
        _canvas.removeEventListener('webglcontextlost', onContextLost, false);
      };
      function onContextLost(event) {
        event.preventDefault();
        resetGLState();
        setDefaultGLState();
        properties.clear();
      }
      ;
      function onTextureDispose(event) {
        var texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        _infoMemory.textures--;
      }
      function onRenderTargetDispose(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        _infoMemory.textures--;
      }
      function onMaterialDispose(event) {
        var material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
      }
      function deallocateTexture(texture) {
        var textureProperties = properties.get(texture);
        if (texture.image && textureProperties.__image__webglTextureCube) {
          _gl.deleteTexture(textureProperties.__image__webglTextureCube);
        } else {
          if (textureProperties.__webglInit === undefined)
            return;
          _gl.deleteTexture(textureProperties.__webglTexture);
        }
        properties.delete(texture);
      }
      function deallocateRenderTarget(renderTarget) {
        var renderTargetProperties = properties.get(renderTarget);
        var textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget || textureProperties.__webglTexture === undefined)
          return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
          for (var i = 0; i < 6; i++) {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
            _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer[i]);
          }
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
          _gl.deleteRenderbuffer(renderTargetProperties.__webglRenderbuffer);
        }
        properties.delete(renderTarget.texture);
        properties.delete(renderTarget);
      }
      function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.delete(material);
      }
      function releaseMaterialProgramReference(material) {
        var programInfo = properties.get(material).program;
        material.program = undefined;
        if (programInfo !== undefined) {
          programCache.releaseProgram(programInfo);
        }
      }
      this.renderBufferImmediate = function(object, program, material) {
        state.initAttributes();
        var buffers = properties.get(object);
        if (object.hasPositions && !buffers.position)
          buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal)
          buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv)
          buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color)
          buffers.color = _gl.createBuffer();
        var attributes = program.getAttributes();
        if (object.hasPositions) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.position);
          _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
          if (material.type !== 'MeshPhongMaterial' && material.shading === THREE.FlatShading) {
            for (var i = 0,
                l = object.count * 3; i < l; i += 9) {
              var array = object.normalArray;
              var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
              var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
              var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
              array[i + 0] = nx;
              array[i + 1] = ny;
              array[i + 2] = nz;
              array[i + 3] = nx;
              array[i + 4] = ny;
              array[i + 5] = nz;
              array[i + 6] = nx;
              array[i + 7] = ny;
              array[i + 8] = nz;
            }
          }
          _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.normal);
          _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.uv);
          _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== THREE.NoColors) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(attributes.color);
          _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
      };
      this.renderBufferDirect = function(camera, lights, fog, geometry, material, object, group) {
        setMaterial(material);
        var program = setProgram(camera, lights, fog, material, object);
        var updateBuffers = false;
        var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
        if (geometryProgram !== _currentGeometryProgram) {
          _currentGeometryProgram = geometryProgram;
          updateBuffers = true;
        }
        var morphTargetInfluences = object.morphTargetInfluences;
        if (morphTargetInfluences !== undefined) {
          var activeInfluences = [];
          for (var i = 0,
              l = morphTargetInfluences.length; i < l; i++) {
            var influence = morphTargetInfluences[i];
            activeInfluences.push([influence, i]);
          }
          activeInfluences.sort(numericalSort);
          if (activeInfluences.length > 8) {
            activeInfluences.length = 8;
          }
          var morphAttributes = geometry.morphAttributes;
          for (var i = 0,
              l = activeInfluences.length; i < l; i++) {
            var influence = activeInfluences[i];
            morphInfluences[i] = influence[0];
            if (influence[0] !== 0) {
              var index = influence[1];
              if (material.morphTargets === true && morphAttributes.position)
                geometry.addAttribute('morphTarget' + i, morphAttributes.position[index]);
              if (material.morphNormals === true && morphAttributes.normal)
                geometry.addAttribute('morphNormal' + i, morphAttributes.normal[index]);
            } else {
              if (material.morphTargets === true)
                geometry.removeAttribute('morphTarget' + i);
              if (material.morphNormals === true)
                geometry.removeAttribute('morphNormal' + i);
            }
          }
          var uniforms = program.getUniforms();
          if (uniforms.morphTargetInfluences !== null) {
            _gl.uniform1fv(uniforms.morphTargetInfluences, morphInfluences);
          }
          updateBuffers = true;
        }
        var index = geometry.index;
        var position = geometry.attributes.position;
        if (material.wireframe === true) {
          index = objects.getWireframeAttribute(geometry);
        }
        var renderer;
        if (index !== null) {
          renderer = indexedBufferRenderer;
          renderer.setIndex(index);
        } else {
          renderer = bufferRenderer;
        }
        if (updateBuffers) {
          setupVertexAttributes(material, program, geometry);
          if (index !== null) {
            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index));
          }
        }
        var dataStart = 0;
        var dataCount = Infinity;
        if (index !== null) {
          dataCount = index.count;
        } else if (position !== undefined) {
          dataCount = position.count;
        }
        var rangeStart = geometry.drawRange.start;
        var rangeCount = geometry.drawRange.count;
        var groupStart = group !== null ? group.start : 0;
        var groupCount = group !== null ? group.count : Infinity;
        var drawStart = Math.max(dataStart, rangeStart, groupStart);
        var drawEnd = Math.min(dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
        var drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (object instanceof THREE.Mesh) {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * pixelRatio);
            renderer.setMode(_gl.LINES);
          } else {
            renderer.setMode(_gl.TRIANGLES);
          }
          if (geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0) {
            renderer.renderInstances(geometry);
          } else {
            renderer.render(drawStart, drawCount);
          }
        } else if (object instanceof THREE.Line) {
          var lineWidth = material.linewidth;
          if (lineWidth === undefined)
            lineWidth = 1;
          state.setLineWidth(lineWidth * pixelRatio);
          if (object instanceof THREE.LineSegments) {
            renderer.setMode(_gl.LINES);
          } else {
            renderer.setMode(_gl.LINE_STRIP);
          }
          renderer.render(drawStart, drawCount);
        } else if (object instanceof THREE.Points) {
          renderer.setMode(_gl.POINTS);
          renderer.render(drawStart, drawCount);
        }
      };
      function setupVertexAttributes(material, program, geometry, startIndex) {
        var extension;
        if (geometry instanceof THREE.InstancedBufferGeometry) {
          extension = extensions.get('ANGLE_instanced_arrays');
          if (extension === null) {
            console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
            return;
          }
        }
        if (startIndex === undefined)
          startIndex = 0;
        state.initAttributes();
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.getAttributes();
        var materialDefaultAttributeValues = material.defaultAttributeValues;
        for (var name in programAttributes) {
          var programAttribute = programAttributes[name];
          if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[name];
            if (geometryAttribute !== undefined) {
              var size = geometryAttribute.itemSize;
              var buffer = objects.getAttributeBuffer(geometryAttribute);
              if (geometryAttribute instanceof THREE.InterleavedBufferAttribute) {
                var data = geometryAttribute.data;
                var stride = data.stride;
                var offset = geometryAttribute.offset;
                if (data instanceof THREE.InstancedInterleavedBuffer) {
                  state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension);
                  if (geometry.maxInstancedCount === undefined) {
                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                  }
                } else {
                  state.enableAttribute(programAttribute);
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
              } else {
                if (geometryAttribute instanceof THREE.InstancedBufferAttribute) {
                  state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension);
                  if (geometry.maxInstancedCount === undefined) {
                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                  }
                } else {
                  state.enableAttribute(programAttribute);
                }
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);
              }
            } else if (materialDefaultAttributeValues !== undefined) {
              var value = materialDefaultAttributeValues[name];
              if (value !== undefined) {
                switch (value.length) {
                  case 2:
                    _gl.vertexAttrib2fv(programAttribute, value);
                    break;
                  case 3:
                    _gl.vertexAttrib3fv(programAttribute, value);
                    break;
                  case 4:
                    _gl.vertexAttrib4fv(programAttribute, value);
                    break;
                  default:
                    _gl.vertexAttrib1fv(programAttribute, value);
                }
              }
            }
          }
        }
        state.disableUnusedAttributes();
      }
      function numericalSort(a, b) {
        return b[0] - a[0];
      }
      function painterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      this.render = function(scene, camera, renderTarget, forceClear) {
        if (camera instanceof THREE.Camera === false) {
          console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
          return;
        }
        var fog = scene.fog;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === null)
          camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        lights.length = 0;
        opaqueObjectsLastIndex = -1;
        transparentObjectsLastIndex = -1;
        sprites.length = 0;
        lensFlares.length = 0;
        projectObject(scene, camera);
        opaqueObjects.length = opaqueObjectsLastIndex + 1;
        transparentObjects.length = transparentObjectsLastIndex + 1;
        if (_this.sortObjects === true) {
          opaqueObjects.sort(painterSortStable);
          transparentObjects.sort(reversePainterSortStable);
        }
        shadowMap.render(scene);
        _infoRender.calls = 0;
        _infoRender.vertices = 0;
        _infoRender.faces = 0;
        _infoRender.points = 0;
        this.setRenderTarget(renderTarget);
        if (this.autoClear || forceClear) {
          this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        if (scene.overrideMaterial) {
          var overrideMaterial = scene.overrideMaterial;
          renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);
          renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);
        } else {
          state.setBlending(THREE.NoBlending);
          renderObjects(opaqueObjects, camera, lights, fog);
          renderObjects(transparentObjects, camera, lights, fog);
        }
        spritePlugin.render(scene, camera);
        lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight);
        if (renderTarget) {
          var texture = renderTarget.texture;
          var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
          if (texture.generateMipmaps && isTargetPowerOfTwo && texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
            updateRenderTargetMipmap(renderTarget);
          }
        }
        state.setDepthTest(true);
        state.setDepthWrite(true);
        state.setColorWrite(true);
      };
      function pushRenderItem(object, geometry, material, z, group) {
        var array,
            index;
        if (material.transparent) {
          array = transparentObjects;
          index = ++transparentObjectsLastIndex;
        } else {
          array = opaqueObjects;
          index = ++opaqueObjectsLastIndex;
        }
        var renderItem = array[index];
        if (renderItem !== undefined) {
          renderItem.id = object.id;
          renderItem.object = object;
          renderItem.geometry = geometry;
          renderItem.material = material;
          renderItem.z = _vector3.z;
          renderItem.group = group;
        } else {
          renderItem = {
            id: object.id,
            object: object,
            geometry: geometry,
            material: material,
            z: _vector3.z,
            group: group
          };
          array.push(renderItem);
        }
      }
      function projectObject(object, camera) {
        if (object.visible === false)
          return;
        if ((object.channels.mask & camera.channels.mask) !== 0) {
          if (object instanceof THREE.Light) {
            lights.push(object);
          } else if (object instanceof THREE.Sprite) {
            sprites.push(object);
          } else if (object instanceof THREE.LensFlare) {
            lensFlares.push(object);
          } else if (object instanceof THREE.ImmediateRenderObject) {
            if (_this.sortObjects === true) {
              _vector3.setFromMatrixPosition(object.matrixWorld);
              _vector3.applyProjection(_projScreenMatrix);
            }
            pushRenderItem(object, null, object.material, _vector3.z, null);
          } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
            if (object instanceof THREE.SkinnedMesh) {
              object.skeleton.update();
            }
            if (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {
              var material = object.material;
              if (material.visible === true) {
                if (_this.sortObjects === true) {
                  _vector3.setFromMatrixPosition(object.matrixWorld);
                  _vector3.applyProjection(_projScreenMatrix);
                }
                var geometry = objects.update(object);
                if (material instanceof THREE.MeshFaceMaterial) {
                  var groups = geometry.groups;
                  var materials = material.materials;
                  for (var i = 0,
                      l = groups.length; i < l; i++) {
                    var group = groups[i];
                    var groupMaterial = materials[group.materialIndex];
                    if (groupMaterial.visible === true) {
                      pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                    }
                  }
                } else {
                  pushRenderItem(object, geometry, material, _vector3.z, null);
                }
              }
            }
          }
        }
        var children = object.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          projectObject(children[i], camera);
        }
      }
      function renderObjects(renderList, camera, lights, fog, overrideMaterial) {
        for (var i = 0,
            l = renderList.length; i < l; i++) {
          var renderItem = renderList[i];
          var object = renderItem.object;
          var geometry = renderItem.geometry;
          var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
          var group = renderItem.group;
          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
          object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
          if (object instanceof THREE.ImmediateRenderObject) {
            setMaterial(material);
            var program = setProgram(camera, lights, fog, material, object);
            _currentGeometryProgram = '';
            object.render(function(object) {
              _this.renderBufferImmediate(object, program, material);
            });
          } else {
            _this.renderBufferDirect(camera, lights, fog, geometry, material, object, group);
          }
        }
      }
      function initMaterial(material, lights, fog, object) {
        var materialProperties = properties.get(material);
        var parameters = programCache.getParameters(material, lights, fog, object);
        var code = programCache.getProgramCode(material, parameters);
        var program = materialProperties.program;
        var programChange = true;
        if (program === undefined) {
          material.addEventListener('dispose', onMaterialDispose);
        } else if (program.code !== code) {
          releaseMaterialProgramReference(material);
        } else if (parameters.shaderID !== undefined) {
          return;
        } else {
          programChange = false;
        }
        if (programChange) {
          if (parameters.shaderID) {
            var shader = THREE.ShaderLib[parameters.shaderID];
            materialProperties.__webglShader = {
              name: material.type,
              uniforms: THREE.UniformsUtils.clone(shader.uniforms),
              vertexShader: shader.vertexShader,
              fragmentShader: shader.fragmentShader
            };
          } else {
            materialProperties.__webglShader = {
              name: material.type,
              uniforms: material.uniforms,
              vertexShader: material.vertexShader,
              fragmentShader: material.fragmentShader
            };
          }
          material.__webglShader = materialProperties.__webglShader;
          program = programCache.acquireProgram(material, parameters, code);
          materialProperties.program = program;
          material.program = program;
        }
        var attributes = program.getAttributes();
        if (material.morphTargets) {
          material.numSupportedMorphTargets = 0;
          for (var i = 0; i < _this.maxMorphTargets; i++) {
            if (attributes['morphTarget' + i] >= 0) {
              material.numSupportedMorphTargets++;
            }
          }
        }
        if (material.morphNormals) {
          material.numSupportedMorphNormals = 0;
          for (i = 0; i < _this.maxMorphNormals; i++) {
            if (attributes['morphNormal' + i] >= 0) {
              material.numSupportedMorphNormals++;
            }
          }
        }
        materialProperties.uniformsList = [];
        var uniformLocations = materialProperties.program.getUniforms();
        for (var u in materialProperties.__webglShader.uniforms) {
          var location = uniformLocations[u];
          if (location) {
            materialProperties.uniformsList.push([materialProperties.__webglShader.uniforms[u], location]);
          }
        }
      }
      function setMaterial(material) {
        setMaterialFaces(material);
        if (material.transparent === true) {
          state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);
        } else {
          state.setBlending(THREE.NoBlending);
        }
        state.setDepthFunc(material.depthFunc);
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        state.setColorWrite(material.colorWrite);
        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      }
      function setMaterialFaces(material) {
        material.side !== THREE.DoubleSide ? state.enable(_gl.CULL_FACE) : state.disable(_gl.CULL_FACE);
        state.setFlipSided(material.side === THREE.BackSide);
      }
      function setProgram(camera, lights, fog, material, object) {
        _usedTextureUnits = 0;
        var materialProperties = properties.get(material);
        if (material.needsUpdate || !materialProperties.program) {
          initMaterial(material, lights, fog, object);
          material.needsUpdate = false;
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = materialProperties.program,
            p_uniforms = program.getUniforms(),
            m_uniforms = materialProperties.__webglShader.uniforms;
        if (program.id !== _currentProgram) {
          _gl.useProgram(program.program);
          _currentProgram = program.id;
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          if (_currentMaterialId === -1)
            refreshLights = true;
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || camera !== _currentCamera) {
          _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
          if (capabilities.logarithmicDepthBuffer) {
            _gl.uniform1f(p_uniforms.logDepthBufFC, 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
          }
          if (camera !== _currentCamera)
            _currentCamera = camera;
          if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
            if (p_uniforms.cameraPosition !== undefined) {
              _vector3.setFromMatrixPosition(camera.matrixWorld);
              _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
            }
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
            if (p_uniforms.viewMatrix !== undefined) {
              _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
            }
          }
        }
        if (material.skinning) {
          if (object.bindMatrix && p_uniforms.bindMatrix !== undefined) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
          }
          if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
          }
          if (capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture) {
            if (p_uniforms.boneTexture !== undefined) {
              var textureUnit = getTextureUnit();
              _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
              _this.setTexture(object.skeleton.boneTexture, textureUnit);
            }
            if (p_uniforms.boneTextureWidth !== undefined) {
              _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
            }
            if (p_uniforms.boneTextureHeight !== undefined) {
              _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
            }
          } else if (object.skeleton && object.skeleton.boneMatrices) {
            if (p_uniforms.boneGlobalMatrices !== undefined) {
              _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
            }
          }
        }
        if (refreshMaterial) {
          if (fog && material.fog) {
            refreshUniformsFog(m_uniforms, fog);
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
            if (_lightsNeedUpdate) {
              refreshLights = true;
              setupLights(lights, camera);
              _lightsNeedUpdate = false;
            }
            if (refreshLights) {
              refreshUniformsLights(m_uniforms, _lights);
              markUniformsLightsNeedsUpdate(m_uniforms, true);
            } else {
              markUniformsLightsNeedsUpdate(m_uniforms, false);
            }
          }
          if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsCommon(m_uniforms, material);
          }
          if (material instanceof THREE.LineBasicMaterial) {
            refreshUniformsLine(m_uniforms, material);
          } else if (material instanceof THREE.LineDashedMaterial) {
            refreshUniformsLine(m_uniforms, material);
            refreshUniformsDash(m_uniforms, material);
          } else if (material instanceof THREE.PointsMaterial) {
            refreshUniformsParticle(m_uniforms, material);
          } else if (material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsPhong(m_uniforms, material);
          } else if (material instanceof THREE.MeshDepthMaterial) {
            m_uniforms.mNear.value = camera.near;
            m_uniforms.mFar.value = camera.far;
            m_uniforms.opacity.value = material.opacity;
          } else if (material instanceof THREE.MeshNormalMaterial) {
            m_uniforms.opacity.value = material.opacity;
          }
          if (object.receiveShadow && !material._shadowPass) {
            refreshUniformsShadow(m_uniforms, lights, camera);
          }
          loadUniformsGeneric(materialProperties.uniformsList);
        }
        loadUniformsMatrices(p_uniforms, object);
        if (p_uniforms.modelMatrix !== undefined) {
          _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
        }
        return program;
      }
      function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        if (material.emissive) {
          uniforms.emissive.value = material.emissive;
        }
        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.aoMap) {
          uniforms.aoMap.value = material.aoMap;
          uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
          uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
          uvScaleMap = material.emissiveMap;
        }
        if (uvScaleMap !== undefined) {
          if (uvScaleMap instanceof THREE.WebGLRenderTarget)
            uvScaleMap = uvScaleMap.texture;
          var offset = uvScaleMap.offset;
          var repeat = uvScaleMap.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = (material.envMap instanceof THREE.WebGLRenderTargetCube) ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
      }
      function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
      }
      function refreshUniformsParticle(uniforms, material) {
        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0;
        uniforms.map.value = material.map;
        if (material.map !== null) {
          var offset = material.map.offset;
          var repeat = material.map.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
      }
      function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog instanceof THREE.Fog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog instanceof THREE.FogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value = material.specular;
        uniforms.shininess.value = Math.max(material.shininess, 1e-4);
        if (material.lightMap) {
          uniforms.lightMap.value = material.lightMap;
          uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.emissiveMap) {
          uniforms.emissiveMap.value = material.emissiveMap;
        }
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
        }
        if (material.displacementMap) {
          uniforms.displacementMap.value = material.displacementMap;
          uniforms.displacementScale.value = material.displacementScale;
          uniforms.displacementBias.value = material.displacementBias;
        }
      }
      function refreshUniformsLights(uniforms, lights) {
        uniforms.ambientLightColor.value = lights.ambient;
        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;
        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;
        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;
        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;
        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;
        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;
        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;
      }
      function refreshUniformsShadow(uniforms, lights, camera) {
        if (uniforms.shadowMatrix) {
          var j = 0;
          for (var i = 0,
              il = lights.length; i < il; i++) {
            var light = lights[i];
            if (light.castShadow === true) {
              if (light instanceof THREE.PointLight || light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight) {
                var shadow = light.shadow;
                if (light instanceof THREE.PointLight) {
                  _vector3.setFromMatrixPosition(light.matrixWorld).negate();
                  shadow.matrix.identity().setPosition(_vector3);
                  uniforms.shadowDarkness.value[j] = -shadow.darkness;
                } else {
                  uniforms.shadowDarkness.value[j] = shadow.darkness;
                }
                uniforms.shadowMatrix.value[j] = shadow.matrix;
                uniforms.shadowMap.value[j] = shadow.map;
                uniforms.shadowMapSize.value[j] = shadow.mapSize;
                uniforms.shadowBias.value[j] = shadow.bias;
                j++;
              }
            }
          }
        }
      }
      function loadUniformsMatrices(uniforms, object) {
        _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object.modelViewMatrix.elements);
        if (uniforms.normalMatrix) {
          _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object.normalMatrix.elements);
        }
      }
      function getTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= capabilities.maxTextures) {
          console.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
        }
        _usedTextureUnits += 1;
        return textureUnit;
      }
      function loadUniformsGeneric(uniforms) {
        var texture,
            textureUnit;
        for (var j = 0,
            jl = uniforms.length; j < jl; j++) {
          var uniform = uniforms[j][0];
          if (uniform.needsUpdate === false)
            continue;
          var type = uniform.type;
          var value = uniform.value;
          var location = uniforms[j][1];
          switch (type) {
            case '1i':
              _gl.uniform1i(location, value);
              break;
            case '1f':
              _gl.uniform1f(location, value);
              break;
            case '2f':
              _gl.uniform2f(location, value[0], value[1]);
              break;
            case '3f':
              _gl.uniform3f(location, value[0], value[1], value[2]);
              break;
            case '4f':
              _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
              break;
            case '1iv':
              _gl.uniform1iv(location, value);
              break;
            case '3iv':
              _gl.uniform3iv(location, value);
              break;
            case '1fv':
              _gl.uniform1fv(location, value);
              break;
            case '2fv':
              _gl.uniform2fv(location, value);
              break;
            case '3fv':
              _gl.uniform3fv(location, value);
              break;
            case '4fv':
              _gl.uniform4fv(location, value);
              break;
            case 'Matrix3fv':
              _gl.uniformMatrix3fv(location, false, value);
              break;
            case 'Matrix4fv':
              _gl.uniformMatrix4fv(location, false, value);
              break;
            case 'i':
              _gl.uniform1i(location, value);
              break;
            case 'f':
              _gl.uniform1f(location, value);
              break;
            case 'v2':
              _gl.uniform2f(location, value.x, value.y);
              break;
            case 'v3':
              _gl.uniform3f(location, value.x, value.y, value.z);
              break;
            case 'v4':
              _gl.uniform4f(location, value.x, value.y, value.z, value.w);
              break;
            case 'c':
              _gl.uniform3f(location, value.r, value.g, value.b);
              break;
            case 'iv1':
              _gl.uniform1iv(location, value);
              break;
            case 'iv':
              _gl.uniform3iv(location, value);
              break;
            case 'fv1':
              _gl.uniform1fv(location, value);
              break;
            case 'fv':
              _gl.uniform3fv(location, value);
              break;
            case 'v2v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(2 * value.length);
              }
              for (var i = 0,
                  i2 = 0,
                  il = value.length; i < il; i++, i2 += 2) {
                uniform._array[i2 + 0] = value[i].x;
                uniform._array[i2 + 1] = value[i].y;
              }
              _gl.uniform2fv(location, uniform._array);
              break;
            case 'v3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(3 * value.length);
              }
              for (var i = 0,
                  i3 = 0,
                  il = value.length; i < il; i++, i3 += 3) {
                uniform._array[i3 + 0] = value[i].x;
                uniform._array[i3 + 1] = value[i].y;
                uniform._array[i3 + 2] = value[i].z;
              }
              _gl.uniform3fv(location, uniform._array);
              break;
            case 'v4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(4 * value.length);
              }
              for (var i = 0,
                  i4 = 0,
                  il = value.length; i < il; i++, i4 += 4) {
                uniform._array[i4 + 0] = value[i].x;
                uniform._array[i4 + 1] = value[i].y;
                uniform._array[i4 + 2] = value[i].z;
                uniform._array[i4 + 3] = value[i].w;
              }
              _gl.uniform4fv(location, uniform._array);
              break;
            case 'm3':
              _gl.uniformMatrix3fv(location, false, value.elements);
              break;
            case 'm3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(9 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 9);
              }
              _gl.uniformMatrix3fv(location, false, uniform._array);
              break;
            case 'm4':
              _gl.uniformMatrix4fv(location, false, value.elements);
              break;
            case 'm4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(16 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 16);
              }
              _gl.uniformMatrix4fv(location, false, uniform._array);
              break;
            case 't':
              texture = value;
              textureUnit = getTextureUnit();
              _gl.uniform1i(location, textureUnit);
              if (!texture)
                continue;
              if (texture instanceof THREE.CubeTexture || (Array.isArray(texture.image) && texture.image.length === 6)) {
                setCubeTexture(texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                setCubeTextureDynamic(texture.texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTarget) {
                _this.setTexture(texture.texture, textureUnit);
              } else {
                _this.setTexture(texture, textureUnit);
              }
              break;
            case 'tv':
              if (uniform._array === undefined) {
                uniform._array = [];
              }
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                uniform._array[i] = getTextureUnit();
              }
              _gl.uniform1iv(location, uniform._array);
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                texture = uniform.value[i];
                textureUnit = uniform._array[i];
                if (!texture)
                  continue;
                if (texture instanceof THREE.CubeTexture || (texture.image instanceof Array && texture.image.length === 6)) {
                  setCubeTexture(texture, textureUnit);
                } else if (texture instanceof THREE.WebGLRenderTarget) {
                  _this.setTexture(texture.texture, textureUnit);
                } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                  setCubeTextureDynamic(texture.texture, textureUnit);
                } else {
                  _this.setTexture(texture, textureUnit);
                }
              }
              break;
            default:
              console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
          }
        }
      }
      function setColorLinear(array, offset, color, intensity) {
        array[offset + 0] = color.r * intensity;
        array[offset + 1] = color.g * intensity;
        array[offset + 2] = color.b * intensity;
      }
      function setupLights(lights, camera) {
        var l,
            ll,
            light,
            r = 0,
            g = 0,
            b = 0,
            color,
            skyColor,
            groundColor,
            intensity,
            distance,
            zlights = _lights,
            viewMatrix = camera.matrixWorldInverse,
            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,
            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,
            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,
            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,
            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,
            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,
            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;
        for (l = 0, ll = lights.length; l < ll; l++) {
          light = lights[l];
          color = light.color;
          intensity = light.intensity;
          distance = light.distance;
          if (light instanceof THREE.AmbientLight) {
            if (!light.visible)
              continue;
            r += color.r;
            g += color.g;
            b += color.b;
          } else if (light instanceof THREE.DirectionalLight) {
            dirCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.transformDirection(viewMatrix);
            dirOffset = dirLength * 3;
            dirPositions[dirOffset + 0] = _direction.x;
            dirPositions[dirOffset + 1] = _direction.y;
            dirPositions[dirOffset + 2] = _direction.z;
            setColorLinear(dirColors, dirOffset, color, intensity);
            dirLength += 1;
          } else if (light instanceof THREE.PointLight) {
            pointCount += 1;
            if (!light.visible)
              continue;
            pointOffset = pointLength * 3;
            setColorLinear(pointColors, pointOffset, color, intensity);
            _vector3.setFromMatrixPosition(light.matrixWorld);
            _vector3.applyMatrix4(viewMatrix);
            pointPositions[pointOffset + 0] = _vector3.x;
            pointPositions[pointOffset + 1] = _vector3.y;
            pointPositions[pointOffset + 2] = _vector3.z;
            pointDistances[pointLength] = distance;
            pointDecays[pointLength] = (light.distance === 0) ? 0.0 : light.decay;
            pointLength += 1;
          } else if (light instanceof THREE.SpotLight) {
            spotCount += 1;
            if (!light.visible)
              continue;
            spotOffset = spotLength * 3;
            setColorLinear(spotColors, spotOffset, color, intensity);
            _direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.copy(_direction).applyMatrix4(viewMatrix);
            spotPositions[spotOffset + 0] = _vector3.x;
            spotPositions[spotOffset + 1] = _vector3.y;
            spotPositions[spotOffset + 2] = _vector3.z;
            spotDistances[spotLength] = distance;
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.transformDirection(viewMatrix);
            spotDirections[spotOffset + 0] = _direction.x;
            spotDirections[spotOffset + 1] = _direction.y;
            spotDirections[spotOffset + 2] = _direction.z;
            spotAnglesCos[spotLength] = Math.cos(light.angle);
            spotExponents[spotLength] = light.exponent;
            spotDecays[spotLength] = (light.distance === 0) ? 0.0 : light.decay;
            spotLength += 1;
          } else if (light instanceof THREE.HemisphereLight) {
            hemiCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _direction.transformDirection(viewMatrix);
            hemiOffset = hemiLength * 3;
            hemiPositions[hemiOffset + 0] = _direction.x;
            hemiPositions[hemiOffset + 1] = _direction.y;
            hemiPositions[hemiOffset + 2] = _direction.z;
            skyColor = light.color;
            groundColor = light.groundColor;
            setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
            setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
            hemiLength += 1;
          }
        }
        for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
          dirColors[l] = 0.0;
        for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
          pointColors[l] = 0.0;
        for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
          spotColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
          hemiSkyColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
          hemiGroundColors[l] = 0.0;
        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;
        zlights.ambient[0] = r;
        zlights.ambient[1] = g;
        zlights.ambient[2] = b;
      }
      this.setFaceCulling = function(cullFace, frontFaceDirection) {
        if (cullFace === THREE.CullFaceNone) {
          state.disable(_gl.CULL_FACE);
        } else {
          if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
            _gl.frontFace(_gl.CW);
          } else {
            _gl.frontFace(_gl.CCW);
          }
          if (cullFace === THREE.CullFaceBack) {
            _gl.cullFace(_gl.BACK);
          } else if (cullFace === THREE.CullFaceFront) {
            _gl.cullFace(_gl.FRONT);
          } else {
            _gl.cullFace(_gl.FRONT_AND_BACK);
          }
          state.enable(_gl.CULL_FACE);
        }
      };
      function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
        var extension;
        if (isImagePowerOfTwo) {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
        } else {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
          if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
            console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
          }
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
          if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
            console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
          }
        }
        extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
          if (texture.type === THREE.FloatType && extensions.get('OES_texture_float_linear') === null)
            return;
          if (texture.type === THREE.HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
            return;
          if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
            properties.get(texture).__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      function uploadTexture(textureProperties, texture, slot) {
        if (textureProperties.__webglInit === undefined) {
          textureProperties.__webglInit = true;
          texture.addEventListener('dispose', onTextureDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          _infoMemory.textures++;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        texture.image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
        if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false) {
          texture.image = makePowerOfTwo(texture.image);
        }
        var image = texture.image,
            isImagePowerOfTwo = isPowerOfTwo(image),
            glFormat = paramThreeToGL(texture.format),
            glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
        var mipmap,
            mipmaps = texture.mipmaps;
        if (texture instanceof THREE.DataTexture) {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        } else if (texture instanceof THREE.CompressedTexture) {
          for (var i = 0,
              il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
              if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        } else {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_2D);
        textureProperties.__version = texture.version;
        if (texture.onUpdate)
          texture.onUpdate(texture);
      }
      this.setTexture = function(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          var image = texture.image;
          if (image === undefined) {
            console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
            return;
          }
          if (image.complete === false) {
            console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
            return;
          }
          uploadTexture(textureProperties, texture, slot);
          return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      };
      function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
          var scale = maxSize / Math.max(image.width, image.height);
          var canvas = document.createElement('canvas');
          canvas.width = Math.floor(image.width * scale);
          canvas.height = Math.floor(image.height * scale);
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
          console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
          return canvas;
        }
        return image;
      }
      function isPowerOfTwo(image) {
        return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);
      }
      function textureNeedsPowerOfTwo(texture) {
        if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping)
          return true;
        if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter)
          return true;
        return false;
      }
      function makePowerOfTwo(image) {
        if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
          var canvas = document.createElement('canvas');
          canvas.width = THREE.Math.nearestPowerOfTwo(image.width);
          canvas.height = THREE.Math.nearestPowerOfTwo(image.height);
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, canvas.width, canvas.height);
          console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
          return canvas;
        }
        return image;
      }
      function setCubeTexture(texture, slot) {
        var textureProperties = properties.get(texture);
        if (texture.image.length === 6) {
          if (texture.version > 0 && textureProperties.__version !== texture.version) {
            if (!textureProperties.__image__webglTextureCube) {
              texture.addEventListener('dispose', onTextureDispose);
              textureProperties.__image__webglTextureCube = _gl.createTexture();
              _infoMemory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            var isCompressed = texture instanceof THREE.CompressedTexture;
            var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
            var cubeImage = [];
            for (var i = 0; i < 6; i++) {
              if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
                cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
              } else {
                cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
              }
            }
            var image = cubeImage[0],
                isImagePowerOfTwo = isPowerOfTwo(image),
                glFormat = paramThreeToGL(texture.format),
                glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
            for (var i = 0; i < 6; i++) {
              if (!isCompressed) {
                if (isDataTexture) {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                } else {
                  state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                }
              } else {
                var mipmap,
                    mipmaps = cubeImage[i].mipmaps;
                for (var j = 0,
                    jl = mipmaps.length; j < jl; j++) {
                  mipmap = mipmaps[j];
                  if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                      state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                      console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                    }
                  } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              }
            }
            if (texture.generateMipmaps && isImagePowerOfTwo) {
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
              texture.onUpdate(texture);
          } else {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
          }
        }
      }
      function setCubeTextureDynamic(texture, slot) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
      }
      function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
      }
      function setupRenderBuffer(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
      }
      this.setRenderTarget = function(renderTarget) {
        var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
          var renderTargetProperties = properties.get(renderTarget);
          var textureProperties = properties.get(renderTarget.texture);
          if (renderTarget.depthBuffer === undefined)
            renderTarget.depthBuffer = true;
          if (renderTarget.stencilBuffer === undefined)
            renderTarget.stencilBuffer = true;
          renderTarget.addEventListener('dispose', onRenderTargetDispose);
          textureProperties.__webglTexture = _gl.createTexture();
          _infoMemory.textures++;
          var isTargetPowerOfTwo = isPowerOfTwo(renderTarget),
              glFormat = paramThreeToGL(renderTarget.texture.format),
              glType = paramThreeToGL(renderTarget.texture.type);
          if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            renderTargetProperties.__webglRenderbuffer = [];
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
            for (var i = 0; i < 6; i++) {
              renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
              renderTargetProperties.__webglRenderbuffer[i] = _gl.createRenderbuffer();
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
              setupFrameBuffer(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
              setupRenderBuffer(renderTargetProperties.__webglRenderbuffer[i], renderTarget);
            }
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (renderTarget.shareDepthFrom) {
              renderTargetProperties.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
            } else {
              renderTargetProperties.__webglRenderbuffer = _gl.createRenderbuffer();
            }
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
            state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            setupFrameBuffer(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
            if (renderTarget.shareDepthFrom) {
              if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);
              } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTargetProperties.__webglRenderbuffer);
              }
            } else {
              setupRenderBuffer(renderTargetProperties.__webglRenderbuffer, renderTarget);
            }
            if (renderTarget.texture.generateMipmaps && isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_2D);
          }
          if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
          } else {
            state.bindTexture(_gl.TEXTURE_2D, null);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        var framebuffer,
            width,
            height,
            vx,
            vy;
        if (renderTarget) {
          var renderTargetProperties = properties.get(renderTarget);
          if (isCube) {
            framebuffer = renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];
          } else {
            framebuffer = renderTargetProperties.__webglFramebuffer;
          }
          width = renderTarget.width;
          height = renderTarget.height;
          vx = 0;
          vy = 0;
        } else {
          framebuffer = null;
          width = _viewportWidth;
          height = _viewportHeight;
          vx = _viewportX;
          vy = _viewportY;
        }
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          _gl.viewport(vx, vy, width, height);
          _currentFramebuffer = framebuffer;
        }
        if (isCube) {
          var textureProperties = properties.get(renderTarget.texture);
          _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0);
        }
        _currentWidth = width;
        _currentHeight = height;
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
        if (renderTarget instanceof THREE.WebGLRenderTarget === false) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
          return;
        }
        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (framebuffer) {
          var restore = false;
          if (framebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            restore = true;
          }
          try {
            var texture = renderTarget.texture;
            if (texture.format !== THREE.RGBAFormat && paramThreeToGL(texture.format) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
              console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
              return;
            }
            if (texture.type !== THREE.UnsignedByteType && paramThreeToGL(texture.type) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(texture.type === THREE.FloatType && extensions.get('WEBGL_color_buffer_float')) && !(texture.type === THREE.HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
              console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
              return;
            }
            if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
              _gl.readPixels(x, y, width, height, paramThreeToGL(texture.format), paramThreeToGL(texture.type), buffer);
            } else {
              console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            }
          } finally {
            if (restore) {
              _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
            }
          }
        }
      };
      function updateRenderTargetMipmap(renderTarget) {
        var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        var texture = properties.get(renderTarget.texture).__webglTexture;
        state.bindTexture(target, texture);
        _gl.generateMipmap(target);
        state.bindTexture(target, null);
      }
      function filterFallback(f) {
        if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
          return _gl.NEAREST;
        }
        return _gl.LINEAR;
      }
      function paramThreeToGL(p) {
        var extension;
        if (p === THREE.RepeatWrapping)
          return _gl.REPEAT;
        if (p === THREE.ClampToEdgeWrapping)
          return _gl.CLAMP_TO_EDGE;
        if (p === THREE.MirroredRepeatWrapping)
          return _gl.MIRRORED_REPEAT;
        if (p === THREE.NearestFilter)
          return _gl.NEAREST;
        if (p === THREE.NearestMipMapNearestFilter)
          return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === THREE.NearestMipMapLinearFilter)
          return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === THREE.LinearFilter)
          return _gl.LINEAR;
        if (p === THREE.LinearMipMapNearestFilter)
          return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === THREE.LinearMipMapLinearFilter)
          return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === THREE.UnsignedByteType)
          return _gl.UNSIGNED_BYTE;
        if (p === THREE.UnsignedShort4444Type)
          return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === THREE.UnsignedShort5551Type)
          return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === THREE.UnsignedShort565Type)
          return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === THREE.ByteType)
          return _gl.BYTE;
        if (p === THREE.ShortType)
          return _gl.SHORT;
        if (p === THREE.UnsignedShortType)
          return _gl.UNSIGNED_SHORT;
        if (p === THREE.IntType)
          return _gl.INT;
        if (p === THREE.UnsignedIntType)
          return _gl.UNSIGNED_INT;
        if (p === THREE.FloatType)
          return _gl.FLOAT;
        extension = extensions.get('OES_texture_half_float');
        if (extension !== null) {
          if (p === THREE.HalfFloatType)
            return extension.HALF_FLOAT_OES;
        }
        if (p === THREE.AlphaFormat)
          return _gl.ALPHA;
        if (p === THREE.RGBFormat)
          return _gl.RGB;
        if (p === THREE.RGBAFormat)
          return _gl.RGBA;
        if (p === THREE.LuminanceFormat)
          return _gl.LUMINANCE;
        if (p === THREE.LuminanceAlphaFormat)
          return _gl.LUMINANCE_ALPHA;
        if (p === THREE.AddEquation)
          return _gl.FUNC_ADD;
        if (p === THREE.SubtractEquation)
          return _gl.FUNC_SUBTRACT;
        if (p === THREE.ReverseSubtractEquation)
          return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === THREE.ZeroFactor)
          return _gl.ZERO;
        if (p === THREE.OneFactor)
          return _gl.ONE;
        if (p === THREE.SrcColorFactor)
          return _gl.SRC_COLOR;
        if (p === THREE.OneMinusSrcColorFactor)
          return _gl.ONE_MINUS_SRC_COLOR;
        if (p === THREE.SrcAlphaFactor)
          return _gl.SRC_ALPHA;
        if (p === THREE.OneMinusSrcAlphaFactor)
          return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === THREE.DstAlphaFactor)
          return _gl.DST_ALPHA;
        if (p === THREE.OneMinusDstAlphaFactor)
          return _gl.ONE_MINUS_DST_ALPHA;
        if (p === THREE.DstColorFactor)
          return _gl.DST_COLOR;
        if (p === THREE.OneMinusDstColorFactor)
          return _gl.ONE_MINUS_DST_COLOR;
        if (p === THREE.SrcAlphaSaturateFactor)
          return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
          if (p === THREE.RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === THREE.RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');
        if (extension !== null) {
          if (p === THREE.RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
          if (p === THREE.MinEquation)
            return extension.MIN_EXT;
          if (p === THREE.MaxEquation)
            return extension.MAX_EXT;
        }
        return 0;
      }
      this.supportsFloatTextures = function() {
        console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
        return extensions.get('OES_texture_float');
      };
      this.supportsHalfFloatTextures = function() {
        console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
        return extensions.get('OES_texture_half_float');
      };
      this.supportsStandardDerivatives = function() {
        console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
        return extensions.get('OES_standard_derivatives');
      };
      this.supportsCompressedTextureS3TC = function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
        return extensions.get('WEBGL_compressed_texture_s3tc');
      };
      this.supportsCompressedTexturePVRTC = function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
        return extensions.get('WEBGL_compressed_texture_pvrtc');
      };
      this.supportsBlendMinMax = function() {
        console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
        return extensions.get('EXT_blend_minmax');
      };
      this.supportsVertexTextures = function() {
        return capabilities.vertexTextures;
      };
      this.supportsInstancedArrays = function() {
        console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
        return extensions.get('ANGLE_instanced_arrays');
      };
      this.initMaterial = function() {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      };
      this.addPrePlugin = function() {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      };
      this.addPostPlugin = function() {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      };
      this.updateShadowMap = function() {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
      };
      Object.defineProperties(this, {
        shadowMapEnabled: {
          get: function() {
            return shadowMap.enabled;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            shadowMap.enabled = value;
          }
        },
        shadowMapType: {
          get: function() {
            return shadowMap.type;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            shadowMap.type = value;
          }
        },
        shadowMapCullFace: {
          get: function() {
            return shadowMap.cullFace;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
            shadowMap.cullFace = value;
          }
        },
        shadowMapDebug: {
          get: function() {
            return shadowMap.debug;
          },
          set: function(value) {
            console.warn('THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.');
            shadowMap.debug = value;
          }
        }
      });
    };
    THREE.WebGLRenderTarget = function(width, height, options) {
      this.uuid = THREE.Math.generateUUID();
      this.width = width;
      this.height = height;
      options = options || {};
      if (options.minFilter === undefined)
        options.minFilter = THREE.LinearFilter;
      this.texture = new THREE.Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy);
      this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
      this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
    };
    THREE.WebGLRenderTarget.prototype = {
      constructor: THREE.WebGLRenderTarget,
      get wrapS() {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
        return this.texture.wrapS;
      },
      set wrapS(value) {
        console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
        this.texture.wrapS = value;
      },
      get wrapT() {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
        return this.texture.wrapT;
      },
      set wrapT(value) {
        console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
        this.texture.wrapT = value;
      },
      get magFilter() {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
        return this.texture.magFilter;
      },
      set magFilter(value) {
        console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
        this.texture.magFilter = value;
      },
      get minFilter() {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
        return this.texture.minFilter;
      },
      set minFilter(value) {
        console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
        this.texture.minFilter = value;
      },
      get anisotropy() {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
        return this.texture.anisotropy;
      },
      set anisotropy(value) {
        console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
        this.texture.anisotropy = value;
      },
      get offset() {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
        return this.texture.offset;
      },
      set offset(value) {
        console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
        this.texture.offset = value;
      },
      get repeat() {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
        return this.texture.repeat;
      },
      set repeat(value) {
        console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
        this.texture.repeat = value;
      },
      get format() {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
        return this.texture.format;
      },
      set format(value) {
        console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
        this.texture.format = value;
      },
      get type() {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
        return this.texture.type;
      },
      set type(value) {
        console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
        this.texture.type = value;
      },
      get generateMipmaps() {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
        return this.texture.generateMipmaps;
      },
      set generateMipmaps(value) {
        console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
        this.texture.generateMipmaps = value;
      },
      setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
          this.width = width;
          this.height = height;
          this.dispose();
        }
      },
      clone: function() {
        return new this.constructor().copy(this);
      },
      copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.shareDepthFrom = source.shareDepthFrom;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube = function(width, height, options) {
      THREE.WebGLRenderTarget.call(this, width, height, options);
      this.activeCubeFace = 0;
    };
    THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
    THREE.WebGLBufferRenderer = function(_gl, extensions, _infoRender) {
      var mode;
      function setMode(value) {
        mode = value;
      }
      function render(start, count) {
        _gl.drawArrays(mode, start, count);
        _infoRender.calls++;
        _infoRender.vertices += count;
        if (mode === _gl.TRIANGLES)
          _infoRender.faces += count / 3;
      }
      function renderInstances(geometry) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
          console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
        var position = geometry.attributes.position;
        if (position instanceof THREE.InterleavedBufferAttribute) {
          extension.drawArraysInstancedANGLE(mode, 0, position.data.count, geometry.maxInstancedCount);
        } else {
          extension.drawArraysInstancedANGLE(mode, 0, position.count, geometry.maxInstancedCount);
        }
      }
      this.setMode = setMode;
      this.render = render;
      this.renderInstances = renderInstances;
    };
    THREE.WebGLIndexedBufferRenderer = function(_gl, extensions, _infoRender) {
      var mode;
      function setMode(value) {
        mode = value;
      }
      var type,
          size;
      function setIndex(index) {
        if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
          type = _gl.UNSIGNED_INT;
          size = 4;
        } else {
          type = _gl.UNSIGNED_SHORT;
          size = 2;
        }
      }
      function render(start, count) {
        _gl.drawElements(mode, count, type, start * size);
        _infoRender.calls++;
        _infoRender.vertices += count;
        if (mode === _gl.TRIANGLES)
          _infoRender.faces += count / 3;
      }
      function renderInstances(geometry) {
        var extension = extensions.get('ANGLE_instanced_arrays');
        if (extension === null) {
          console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
          return;
        }
        var index = geometry.index;
        extension.drawElementsInstancedANGLE(mode, index.array.length, type, 0, geometry.maxInstancedCount);
      }
      this.setMode = setMode;
      this.setIndex = setIndex;
      this.render = render;
      this.renderInstances = renderInstances;
    };
    THREE.WebGLExtensions = function(gl) {
      var extensions = {};
      this.get = function(name) {
        if (extensions[name] !== undefined) {
          return extensions[name];
        }
        var extension;
        switch (name) {
          case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
          console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }
        extensions[name] = extension;
        return extension;
      };
    };
    THREE.WebGLCapabilities = function(gl, extensions, parameters) {
      function getMaxPrecision(precision) {
        if (precision === 'highp') {
          if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return 'highp';
          }
          precision = 'mediump';
        }
        if (precision === 'mediump') {
          if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return 'mediump';
          }
        }
        return 'lowp';
      }
      this.getMaxPrecision = getMaxPrecision;
      this.precision = parameters.precision !== undefined ? parameters.precision : 'highp', this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;
      this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
      this.maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      this.maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
      this.maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
      this.maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
      this.vertexTextures = this.maxVertexTextures > 0;
      this.floatFragmentTextures = !!extensions.get('OES_texture_float');
      this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
      var _maxPrecision = getMaxPrecision(this.precision);
      if (_maxPrecision !== this.precision) {
        console.warn('THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.');
        this.precision = _maxPrecision;
      }
      if (this.logarithmicDepthBuffer) {
        this.logarithmicDepthBuffer = !!extensions.get('EXT_frag_depth');
      }
    };
    THREE.WebGLGeometries = function(gl, properties, info) {
      var geometries = {};
      function get(object) {
        var geometry = object.geometry;
        if (geometries[geometry.id] !== undefined) {
          return geometries[geometry.id];
        }
        geometry.addEventListener('dispose', onGeometryDispose);
        var buffergeometry;
        if (geometry instanceof THREE.BufferGeometry) {
          buffergeometry = geometry;
        } else if (geometry instanceof THREE.Geometry) {
          if (geometry._bufferGeometry === undefined) {
            geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject(object);
          }
          buffergeometry = geometry._bufferGeometry;
        }
        geometries[geometry.id] = buffergeometry;
        info.memory.geometries++;
        return buffergeometry;
      }
      function onGeometryDispose(event) {
        var geometry = event.target;
        var buffergeometry = geometries[geometry.id];
        deleteAttributes(buffergeometry.attributes);
        geometry.removeEventListener('dispose', onGeometryDispose);
        delete geometries[geometry.id];
        var property = properties.get(geometry);
        if (property.wireframe)
          deleteAttribute(property.wireframe);
        info.memory.geometries--;
      }
      function getAttributeBuffer(attribute) {
        if (attribute instanceof THREE.InterleavedBufferAttribute) {
          return properties.get(attribute.data).__webglBuffer;
        }
        return properties.get(attribute).__webglBuffer;
      }
      function deleteAttribute(attribute) {
        var buffer = getAttributeBuffer(attribute);
        if (buffer !== undefined) {
          gl.deleteBuffer(buffer);
          removeAttributeBuffer(attribute);
        }
      }
      function deleteAttributes(attributes) {
        for (var name in attributes) {
          deleteAttribute(attributes[name]);
        }
      }
      function removeAttributeBuffer(attribute) {
        if (attribute instanceof THREE.InterleavedBufferAttribute) {
          properties.delete(attribute.data);
        } else {
          properties.delete(attribute);
        }
      }
      this.get = get;
    };
    THREE.WebGLObjects = function(gl, properties, info) {
      var geometries = new THREE.WebGLGeometries(gl, properties, info);
      function update(object) {
        var geometry = geometries.get(object);
        if (object.geometry instanceof THREE.Geometry) {
          geometry.updateFromObject(object);
        }
        var index = geometry.index;
        var attributes = geometry.attributes;
        if (index !== null) {
          updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
        }
        for (var name in attributes) {
          updateAttribute(attributes[name], gl.ARRAY_BUFFER);
        }
        var morphAttributes = geometry.morphAttributes;
        for (var name in morphAttributes) {
          var array = morphAttributes[name];
          for (var i = 0,
              l = array.length; i < l; i++) {
            updateAttribute(array[i], gl.ARRAY_BUFFER);
          }
        }
        return geometry;
      }
      function updateAttribute(attribute, bufferType) {
        var data = (attribute instanceof THREE.InterleavedBufferAttribute) ? attribute.data : attribute;
        var attributeProperties = properties.get(data);
        if (attributeProperties.__webglBuffer === undefined) {
          createBuffer(attributeProperties, data, bufferType);
        } else if (attributeProperties.version !== data.version) {
          updateBuffer(attributeProperties, data, bufferType);
        }
      }
      function createBuffer(attributeProperties, data, bufferType) {
        attributeProperties.__webglBuffer = gl.createBuffer();
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
        gl.bufferData(bufferType, data.array, usage);
        attributeProperties.version = data.version;
      }
      function updateBuffer(attributeProperties, data, bufferType) {
        gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
        if (data.dynamic === false || data.updateRange.count === -1) {
          gl.bufferSubData(bufferType, 0, data.array);
        } else if (data.updateRange.count === 0) {
          console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
        } else {
          gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count));
          data.updateRange.count = 0;
        }
        attributeProperties.version = data.version;
      }
      function getAttributeBuffer(attribute) {
        if (attribute instanceof THREE.InterleavedBufferAttribute) {
          return properties.get(attribute.data).__webglBuffer;
        }
        return properties.get(attribute).__webglBuffer;
      }
      function getWireframeAttribute(geometry) {
        var property = properties.get(geometry);
        if (property.wireframe !== undefined) {
          return property.wireframe;
        }
        var indices = [];
        var index = geometry.index;
        var attributes = geometry.attributes;
        var position = attributes.position;
        if (index !== null) {
          var edges = {};
          var array = index.array;
          for (var i = 0,
              l = array.length; i < l; i += 3) {
            var a = array[i + 0];
            var b = array[i + 1];
            var c = array[i + 2];
            if (checkEdge(edges, a, b))
              indices.push(a, b);
            if (checkEdge(edges, b, c))
              indices.push(b, c);
            if (checkEdge(edges, c, a))
              indices.push(c, a);
          }
        } else {
          var array = attributes.position.array;
          for (var i = 0,
              l = (array.length / 3) - 1; i < l; i += 3) {
            var a = i + 0;
            var b = i + 1;
            var c = i + 2;
            indices.push(a, b, b, c, c, a);
          }
        }
        var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
        var attribute = new THREE.BufferAttribute(new TypeArray(indices), 1);
        updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
        property.wireframe = attribute;
        return attribute;
      }
      function checkEdge(edges, a, b) {
        if (a > b) {
          var tmp = a;
          a = b;
          b = tmp;
        }
        var list = edges[a];
        if (list === undefined) {
          edges[a] = [b];
          return true;
        } else if (list.indexOf(b) === -1) {
          list.push(b);
          return true;
        }
        return false;
      }
      this.getAttributeBuffer = getAttributeBuffer;
      this.getWireframeAttribute = getWireframeAttribute;
      this.update = update;
    };
    THREE.WebGLProgram = (function() {
      var programIdCount = 0;
      function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
          var value = defines[name];
          if (value === false)
            continue;
          chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
      }
      function fetchUniformLocations(gl, program, identifiers) {
        var uniforms = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; i++) {
          var info = gl.getActiveUniform(program, i);
          var name = info.name;
          var location = gl.getUniformLocation(program, name);
          var suffixPos = name.lastIndexOf('[0]');
          if (suffixPos !== -1 && suffixPos === name.length - 3) {
            uniforms[name.substr(0, suffixPos)] = location;
          }
          uniforms[name] = location;
        }
        return uniforms;
      }
      function fetchAttributeLocations(gl, program, identifiers) {
        var attributes = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < n; i++) {
          var info = gl.getActiveAttrib(program, i);
          var name = info.name;
          attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
      }
      function filterEmptyLine(string) {
        return string !== '';
      }
      return function WebGLProgram(renderer, code, material, parameters) {
        var gl = renderer.context;
        var defines = material.defines;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === THREE.PCFShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
          switch (material.envMap.mapping) {
            case THREE.CubeReflectionMapping:
            case THREE.CubeRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
              break;
            case THREE.EquirectangularReflectionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
              break;
            case THREE.SphericalReflectionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
              break;
          }
          switch (material.envMap.mapping) {
            case THREE.CubeRefractionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
              break;
          }
          switch (material.combine) {
            case THREE.MultiplyOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
              break;
            case THREE.MixOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
              break;
            case THREE.AddOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
              break;
          }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex,
            prefixFragment;
        if (material instanceof THREE.RawShaderMaterial) {
          prefixVertex = '';
          prefixFragment = '';
        } else {
          prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, '#define MAX_BONES ' + parameters.maxBones, parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
          prefixFragment = [parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ? '#extension GL_OES_standard_derivatives : enable' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + material.__webglShader.name, customDefines, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', renderer.gammaInput ? '#define GAMMA_INPUT' : '', renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.metal ? '#define METAL' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', '\n'].filter(filterEmptyLine).join('\n');
        }
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        var glVertexShader = THREE.WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = THREE.WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (material.index0AttributeName !== undefined) {
          gl.bindAttribLocation(program, 0, material.index0AttributeName);
        } else if (parameters.morphTargets === true) {
          gl.bindAttribLocation(program, 0, 'position');
        }
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program);
        var vertexLog = gl.getShaderInfoLog(glVertexShader);
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
          runnable = false;
          console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
        } else if (programLog !== '') {
          console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        } else if (vertexLog === '' || fragmentLog === '') {
          haveDiagnostics = false;
        }
        if (haveDiagnostics) {
          this.diagnostics = {
            runnable: runnable,
            material: material,
            programLog: programLog,
            vertexShader: {
              log: vertexLog,
              prefix: prefixVertex
            },
            fragmentShader: {
              log: fragmentLog,
              prefix: prefixFragment
            }
          };
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
          if (cachedUniforms === undefined) {
            cachedUniforms = fetchUniformLocations(gl, program);
          }
          return cachedUniforms;
        };
        var cachedAttributes;
        this.getAttributes = function() {
          if (cachedAttributes === undefined) {
            cachedAttributes = fetchAttributeLocations(gl, program);
          }
          return cachedAttributes;
        };
        this.destroy = function() {
          gl.deleteProgram(program);
          this.program = undefined;
        };
        Object.defineProperties(this, {
          uniforms: {get: function() {
              console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
              return this.getUniforms();
            }},
          attributes: {get: function() {
              console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
              return this.getAttributes();
            }}
        });
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      };
    })();
    THREE.WebGLPrograms = function(renderer, capabilities) {
      var programs = [];
      var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points'
      };
      var parameterNames = ["precision", "supportsVertexTextures", "map", "envMap", "envMapMode", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "maxDirLights", "maxPointLights", "maxSpotLights", "maxHemiLights", "maxShadows", "shadowMapEnabled", "pointLightShadows", "shadowMapType", "shadowMapDebug", "alphaTest", "metal", "doubleSided", "flipSided"];
      function allocateBones(object) {
        if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
          return 1024;
        } else {
          var nVertexUniforms = capabilities.maxVertexUniforms;
          var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          var maxBones = nVertexMatrices;
          if (object !== undefined && object instanceof THREE.SkinnedMesh) {
            maxBones = Math.min(object.skeleton.bones.length, maxBones);
            if (maxBones < object.skeleton.bones.length) {
              console.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
            }
          }
          return maxBones;
        }
      }
      function allocateLights(lights) {
        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (light.visible === false)
            continue;
          if (light instanceof THREE.DirectionalLight)
            dirLights++;
          if (light instanceof THREE.PointLight)
            pointLights++;
          if (light instanceof THREE.SpotLight)
            spotLights++;
          if (light instanceof THREE.HemisphereLight)
            hemiLights++;
        }
        return {
          'directional': dirLights,
          'point': pointLights,
          'spot': spotLights,
          'hemi': hemiLights
        };
      }
      function allocateShadows(lights) {
        var maxShadows = 0;
        var pointLightShadows = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (!light.castShadow)
            continue;
          if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight)
            maxShadows++;
          if (light instanceof THREE.PointLight) {
            maxShadows++;
            pointLightShadows++;
          }
        }
        return {
          'maxShadows': maxShadows,
          'pointLightShadows': pointLightShadows
        };
      }
      this.getParameters = function(material, lights, fog, object) {
        var shaderID = shaderIDs[material.type];
        var maxLightCount = allocateLights(lights);
        var allocatedShadows = allocateShadows(lights);
        var maxBones = allocateBones(object);
        var precision = renderer.getPrecision();
        if (material.precision !== null) {
          precision = capabilities.getMaxPrecision(material.precision);
          if (precision !== material.precision) {
            console.warn('THREE.WebGLRenderer.initMaterial:', material.precision, 'not supported, using', precision, 'instead.');
          }
        }
        var parameters = {
          shaderID: shaderID,
          precision: precision,
          supportsVertexTextures: capabilities.vertexTextures,
          map: !!material.map,
          envMap: !!material.envMap,
          envMapMode: material.envMap && material.envMap.mapping,
          lightMap: !!material.lightMap,
          aoMap: !!material.aoMap,
          emissiveMap: !!material.emissiveMap,
          bumpMap: !!material.bumpMap,
          normalMap: !!material.normalMap,
          displacementMap: !!material.displacementMap,
          specularMap: !!material.specularMap,
          alphaMap: !!material.alphaMap,
          combine: material.combine,
          vertexColors: material.vertexColors,
          fog: fog,
          useFog: material.fog,
          fogExp: fog instanceof THREE.FogExp2,
          flatShading: material.shading === THREE.FlatShading,
          sizeAttenuation: material.sizeAttenuation,
          logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
          skinning: material.skinning,
          maxBones: maxBones,
          useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
          morphTargets: material.morphTargets,
          morphNormals: material.morphNormals,
          maxMorphTargets: renderer.maxMorphTargets,
          maxMorphNormals: renderer.maxMorphNormals,
          maxDirLights: maxLightCount.directional,
          maxPointLights: maxLightCount.point,
          maxSpotLights: maxLightCount.spot,
          maxHemiLights: maxLightCount.hemi,
          maxShadows: allocatedShadows.maxShadows,
          pointLightShadows: allocatedShadows.pointLightShadows,
          shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && allocatedShadows.maxShadows > 0,
          shadowMapType: renderer.shadowMap.type,
          shadowMapDebug: renderer.shadowMap.debug,
          alphaTest: material.alphaTest,
          metal: material.metal,
          doubleSided: material.side === THREE.DoubleSide,
          flipSided: material.side === THREE.BackSide
        };
        return parameters;
      };
      this.getProgramCode = function(material, parameters) {
        var chunks = [];
        if (parameters.shaderID) {
          chunks.push(parameters.shaderID);
        } else {
          chunks.push(material.fragmentShader);
          chunks.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
          for (var name in material.defines) {
            chunks.push(name);
            chunks.push(material.defines[name]);
          }
        }
        for (var i = 0; i < parameterNames.length; i++) {
          var parameterName = parameterNames[i];
          chunks.push(parameterName);
          chunks.push(parameters[parameterName]);
        }
        return chunks.join();
      };
      this.acquireProgram = function(material, parameters, code) {
        var program;
        for (var p = 0,
            pl = programs.length; p < pl; p++) {
          var programInfo = programs[p];
          if (programInfo.code === code) {
            program = programInfo;
            ++program.usedTimes;
            break;
          }
        }
        if (program === undefined) {
          program = new THREE.WebGLProgram(renderer, code, material, parameters);
          programs.push(program);
        }
        return program;
      };
      this.releaseProgram = function(program) {
        if (--program.usedTimes === 0) {
          var i = programs.indexOf(program);
          programs[i] = programs[programs.length - 1];
          programs.pop();
          program.destroy();
        }
      };
      this.programs = programs;
    };
    THREE.WebGLProperties = function() {
      var properties = {};
      this.get = function(object) {
        var uuid = object.uuid;
        var map = properties[uuid];
        if (map === undefined) {
          map = {};
          properties[uuid] = map;
        }
        return map;
      };
      this.delete = function(object) {
        delete properties[object.uuid];
      };
      this.clear = function() {
        properties = {};
      };
    };
    THREE.WebGLShader = (function() {
      function addLineNumbers(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
          lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
      }
      return function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
          console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
          console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
      };
    })();
    THREE.WebGLShadowMap = function(_renderer, _lights, _objects) {
      var _gl = _renderer.context,
          _state = _renderer.state,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _min = new THREE.Vector3(),
          _max = new THREE.Vector3(),
          _lookTarget = new THREE.Vector3(),
          _lightPositionWorld = new THREE.Vector3(),
          _renderList = [],
          _MorphingFlag = 1,
          _SkinningFlag = 2,
          _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
          _depthMaterials = new Array(_NumberOfMaterialVariants),
          _distanceMaterials = new Array(_NumberOfMaterialVariants);
      var cubeDirections = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)];
      var cubeUps = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)];
      var cube2DViewPorts = [new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()];
      var _vector4 = new THREE.Vector4();
      var depthShader = THREE.ShaderLib["depthRGBA"];
      var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
      var distanceShader = THREE.ShaderLib["distanceRGBA"];
      var distanceUniforms = THREE.UniformsUtils.clone(distanceShader.uniforms);
      for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
        var useMorphing = (i & _MorphingFlag) !== 0;
        var useSkinning = (i & _SkinningFlag) !== 0;
        var depthMaterial = new THREE.ShaderMaterial({
          uniforms: depthUniforms,
          vertexShader: depthShader.vertexShader,
          fragmentShader: depthShader.fragmentShader,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        depthMaterial._shadowPass = true;
        _depthMaterials[i] = depthMaterial;
        var distanceMaterial = new THREE.ShaderMaterial({
          uniforms: distanceUniforms,
          vertexShader: distanceShader.vertexShader,
          fragmentShader: distanceShader.fragmentShader,
          morphTargets: useMorphing,
          skinning: useSkinning
        });
        distanceMaterial._shadowPass = true;
        _distanceMaterials[i] = distanceMaterial;
      }
      var scope = this;
      this.enabled = false;
      this.autoUpdate = true;
      this.needsUpdate = false;
      this.type = THREE.PCFShadowMap;
      this.cullFace = THREE.CullFaceFront;
      this.render = function(scene) {
        var faceCount,
            isPointLight;
        if (scope.enabled === false)
          return;
        if (scope.autoUpdate === false && scope.needsUpdate === false)
          return;
        _gl.clearColor(1, 1, 1, 1);
        _state.disable(_gl.BLEND);
        _state.enable(_gl.CULL_FACE);
        _gl.frontFace(_gl.CCW);
        _gl.cullFace(scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK);
        _state.setDepthTest(true);
        _renderer.getViewport(_vector4);
        for (var i = 0,
            il = _lights.length; i < il; i++) {
          var light = _lights[i];
          if (light.castShadow === true) {
            var shadow = light.shadow;
            var shadowCamera = shadow.camera;
            var shadowMapSize = shadow.mapSize;
            if (light instanceof THREE.PointLight) {
              faceCount = 6;
              isPointLight = true;
              var vpWidth = shadowMapSize.x / 4.0;
              var vpHeight = shadowMapSize.y / 2.0;
              cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
              cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
              cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
            } else {
              faceCount = 1;
              isPointLight = false;
            }
            if (shadow.map === null) {
              var shadowFilter = THREE.LinearFilter;
              if (scope.type === THREE.PCFSoftShadowMap) {
                shadowFilter = THREE.NearestFilter;
              }
              var pars = {
                minFilter: shadowFilter,
                magFilter: shadowFilter,
                format: THREE.RGBAFormat
              };
              shadow.map = new THREE.WebGLRenderTarget(shadowMapSize.x, shadowMapSize.y, pars);
              shadow.matrix = new THREE.Matrix4();
              if (light instanceof THREE.SpotLight) {
                shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;
              }
              shadowCamera.updateProjectionMatrix();
            }
            var shadowMap = shadow.map;
            var shadowMatrix = shadow.matrix;
            _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(_lightPositionWorld);
            _renderer.setRenderTarget(shadowMap);
            _renderer.clear();
            for (var face = 0; face < faceCount; face++) {
              if (isPointLight) {
                _lookTarget.copy(shadowCamera.position);
                _lookTarget.add(cubeDirections[face]);
                shadowCamera.up.copy(cubeUps[face]);
                shadowCamera.lookAt(_lookTarget);
                var vpDimensions = cube2DViewPorts[face];
                _renderer.setViewport(vpDimensions.x, vpDimensions.y, vpDimensions.z, vpDimensions.w);
              } else {
                _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                shadowCamera.lookAt(_lookTarget);
              }
              shadowCamera.updateMatrixWorld();
              shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
              shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
              shadowMatrix.multiply(shadowCamera.projectionMatrix);
              shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
              _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
              _frustum.setFromMatrix(_projScreenMatrix);
              _renderList.length = 0;
              projectObject(scene, shadowCamera);
              for (var j = 0,
                  jl = _renderList.length; j < jl; j++) {
                var object = _renderList[j];
                var geometry = _objects.update(object);
                var material = object.material;
                if (material instanceof THREE.MeshFaceMaterial) {
                  var groups = geometry.groups;
                  var materials = material.materials;
                  for (var k = 0,
                      kl = groups.length; k < kl; k++) {
                    var group = groups[k];
                    var groupMaterial = materials[group.materialIndex];
                    if (groupMaterial.visible === true) {
                      var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                      _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, depthMaterial, object, group);
                    }
                  }
                } else {
                  var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                  _renderer.renderBufferDirect(shadowCamera, _lights, null, geometry, depthMaterial, object, null);
                }
              }
            }
            _renderer.resetGLState();
          }
        }
        _renderer.setViewport(_vector4.x, _vector4.y, _vector4.z, _vector4.w);
        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();
        _renderer.setClearColor(clearColor, clearAlpha);
        _state.enable(_gl.BLEND);
        if (scope.cullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.BACK);
        }
        _renderer.resetGLState();
        scope.needsUpdate = false;
      };
      function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
        var geometry = object.geometry;
        var newMaterial = null;
        var materialVariants = _depthMaterials;
        var customMaterial = object.customDepthMaterial;
        if (isPointLight) {
          materialVariants = _distanceMaterials;
          customMaterial = object.customDistanceMaterial;
        }
        if (!customMaterial) {
          var useMorphing = geometry.morphTargets !== undefined && geometry.morphTargets.length > 0 && material.morphTargets;
          var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;
          var variantIndex = 0;
          if (useMorphing)
            variantIndex |= _MorphingFlag;
          if (useSkinning)
            variantIndex |= _SkinningFlag;
          newMaterial = materialVariants[variantIndex];
        } else {
          newMaterial = customMaterial;
        }
        newMaterial.visible = material.visible;
        newMaterial.wireframe = material.wireframe;
        newMaterial.wireframeLinewidth = material.wireframeLinewidth;
        if (isPointLight && newMaterial.uniforms.lightPos !== undefined) {
          newMaterial.uniforms.lightPos.value.copy(lightPositionWorld);
        }
        return newMaterial;
      }
      function projectObject(object, camera) {
        if (object.visible === false)
          return;
        if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points) {
          if (object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
            var material = object.material;
            if (material.visible === true) {
              object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
              _renderList.push(object);
            }
          }
        }
        var children = object.children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          projectObject(children[i], camera);
        }
      }
    };
    THREE.WebGLState = function(gl, extensions, paramThreeToGL) {
      var _this = this;
      var newAttributes = new Uint8Array(16);
      var enabledAttributes = new Uint8Array(16);
      var attributeDivisors = new Uint8Array(16);
      var capabilities = {};
      var compressedTextureFormats = null;
      var currentBlending = null;
      var currentBlendEquation = null;
      var currentBlendSrc = null;
      var currentBlendDst = null;
      var currentBlendEquationAlpha = null;
      var currentBlendSrcAlpha = null;
      var currentBlendDstAlpha = null;
      var currentDepthFunc = null;
      var currentDepthWrite = null;
      var currentColorWrite = null;
      var currentFlipSided = null;
      var currentLineWidth = null;
      var currentPolygonOffsetFactor = null;
      var currentPolygonOffsetUnits = null;
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      var currentTextureSlot = undefined;
      var currentBoundTextures = {};
      this.init = function() {
        gl.clearColor(0, 0, 0, 1);
        gl.clearDepth(1);
        gl.clearStencil(0);
        this.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        this.enable(gl.CULL_FACE);
        this.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      };
      this.initAttributes = function() {
        for (var i = 0,
            l = newAttributes.length; i < l; i++) {
          newAttributes[i] = 0;
        }
      };
      this.enableAttribute = function(attribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== 0) {
          var extension = extensions.get('ANGLE_instanced_arrays');
          extension.vertexAttribDivisorANGLE(attribute, 0);
          attributeDivisors[attribute] = 0;
        }
      };
      this.enableAttributeAndDivisor = function(attribute, meshPerAttribute, extension) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
          extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
          attributeDivisors[attribute] = meshPerAttribute;
        }
      };
      this.disableUnusedAttributes = function() {
        for (var i = 0,
            l = enabledAttributes.length; i < l; i++) {
          if (enabledAttributes[i] !== newAttributes[i]) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
          }
        }
      };
      this.enable = function(id) {
        if (capabilities[id] !== true) {
          gl.enable(id);
          capabilities[id] = true;
        }
      };
      this.disable = function(id) {
        if (capabilities[id] !== false) {
          gl.disable(id);
          capabilities[id] = false;
        }
      };
      this.getCompressedTextureFormats = function() {
        if (compressedTextureFormats === null) {
          compressedTextureFormats = [];
          if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc')) {
            var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
            for (var i = 0; i < formats.length; i++) {
              compressedTextureFormats.push(formats[i]);
            }
          }
        }
        return compressedTextureFormats;
      };
      this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {
        if (blending !== currentBlending) {
          if (blending === THREE.NoBlending) {
            this.disable(gl.BLEND);
          } else if (blending === THREE.AdditiveBlending) {
            this.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          } else if (blending === THREE.SubtractiveBlending) {
            this.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
          } else if (blending === THREE.MultiplyBlending) {
            this.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
          } else if (blending === THREE.CustomBlending) {
            this.enable(gl.BLEND);
          } else {
            this.enable(gl.BLEND);
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          }
          currentBlending = blending;
        }
        if (blending === THREE.CustomBlending) {
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
        } else {
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
        }
      };
      this.setDepthFunc = function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case THREE.NeverDepth:
                gl.depthFunc(gl.NEVER);
                break;
              case THREE.AlwaysDepth:
                gl.depthFunc(gl.ALWAYS);
                break;
              case THREE.LessDepth:
                gl.depthFunc(gl.LESS);
                break;
              case THREE.LessEqualDepth:
                gl.depthFunc(gl.LEQUAL);
                break;
              case THREE.EqualDepth:
                gl.depthFunc(gl.EQUAL);
                break;
              case THREE.GreaterEqualDepth:
                gl.depthFunc(gl.GEQUAL);
                break;
              case THREE.GreaterDepth:
                gl.depthFunc(gl.GREATER);
                break;
              case THREE.NotEqualDepth:
                gl.depthFunc(gl.NOTEQUAL);
                break;
              default:
                gl.depthFunc(gl.LEQUAL);
            }
          } else {
            gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      };
      this.setDepthTest = function(depthTest) {
        if (depthTest) {
          this.enable(gl.DEPTH_TEST);
        } else {
          this.disable(gl.DEPTH_TEST);
        }
      };
      this.setDepthWrite = function(depthWrite) {
        if (currentDepthWrite !== depthWrite) {
          gl.depthMask(depthWrite);
          currentDepthWrite = depthWrite;
        }
      };
      this.setColorWrite = function(colorWrite) {
        if (currentColorWrite !== colorWrite) {
          gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
          currentColorWrite = colorWrite;
        }
      };
      this.setFlipSided = function(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(gl.CW);
          } else {
            gl.frontFace(gl.CCW);
          }
          currentFlipSided = flipSided;
        }
      };
      this.setLineWidth = function(width) {
        if (width !== currentLineWidth) {
          gl.lineWidth(width);
          currentLineWidth = width;
        }
      };
      this.setPolygonOffset = function(polygonOffset, factor, units) {
        if (polygonOffset) {
          this.enable(gl.POLYGON_OFFSET_FILL);
        } else {
          this.disable(gl.POLYGON_OFFSET_FILL);
        }
        if (polygonOffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      };
      this.setScissorTest = function(scissorTest) {
        if (scissorTest) {
          this.enable(gl.SCISSOR_TEST);
        } else {
          this.disable(gl.SCISSOR_TEST);
        }
      };
      this.activeTexture = function(webglSlot) {
        if (webglSlot === undefined)
          webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          currentTextureSlot = webglSlot;
        }
      };
      this.bindTexture = function(webglType, webglTexture) {
        if (currentTextureSlot === undefined) {
          _this.activeTexture();
        }
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
          boundTexture = {
            type: undefined,
            texture: undefined
          };
          currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
          gl.bindTexture(webglType, webglTexture);
          boundTexture.type = webglType;
          boundTexture.texture = webglTexture;
        }
      };
      this.compressedTexImage2D = function() {
        try {
          gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
          console.error(error);
        }
      };
      this.texImage2D = function() {
        try {
          gl.texImage2D.apply(gl, arguments);
        } catch (error) {
          console.error(error);
        }
      };
      this.reset = function() {
        for (var i = 0; i < enabledAttributes.length; i++) {
          if (enabledAttributes[i] === 1) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
          }
        }
        capabilities = {};
        compressedTextureFormats = null;
        currentBlending = null;
        currentDepthWrite = null;
        currentColorWrite = null;
        currentFlipSided = null;
      };
    };
    THREE.LensFlarePlugin = function(renderer, flares) {
      var gl = renderer.context;
      var state = renderer.state;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var hasVertexTexture;
      var tempTexture,
          occlusionTexture;
      function init() {
        var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();
        state.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        var shader;
        if (hasVertexTexture) {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        } else {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        }
        program = createProgram(shader);
        attributes = {
          vertex: gl.getAttribLocation(program, "position"),
          uv: gl.getAttribLocation(program, "uv")
        };
        uniforms = {
          renderType: gl.getUniformLocation(program, "renderType"),
          map: gl.getUniformLocation(program, "map"),
          occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
          opacity: gl.getUniformLocation(program, "opacity"),
          color: gl.getUniformLocation(program, "color"),
          scale: gl.getUniformLocation(program, "scale"),
          rotation: gl.getUniformLocation(program, "rotation"),
          screenPosition: gl.getUniformLocation(program, "screenPosition")
        };
      }
      this.render = function(scene, camera, viewportWidth, viewportHeight) {
        if (flares.length === 0)
          return;
        var tempPosition = new THREE.Vector3();
        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;
        var size = 16 / viewportHeight,
            scale = new THREE.Vector2(size * invAspect, size);
        var screenPosition = new THREE.Vector3(1, 1, 0),
            screenPositionPixels = new THREE.Vector2(1, 1);
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.vertex);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        state.disable(gl.CULL_FACE);
        gl.depthMask(false);
        for (var i = 0,
            l = flares.length; i < l; i++) {
          size = 16 / viewportHeight;
          scale.set(size * invAspect, size);
          var flare = flares[i];
          tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
          tempPosition.applyMatrix4(camera.matrixWorldInverse);
          tempPosition.applyProjection(camera.projectionMatrix);
          screenPosition.copy(tempPosition);
          screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
          screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
          if (hasVertexTexture || (screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight)) {
            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_2D, null);
            state.activeTexture(gl.TEXTURE1);
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 0);
            gl.uniform2f(uniforms.scale, scale.x, scale.y);
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            state.disable(gl.BLEND);
            state.enable(gl.DEPTH_TEST);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 1);
            state.disable(gl.DEPTH_TEST);
            state.activeTexture(gl.TEXTURE1);
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            flare.positionScreen.copy(screenPosition);
            if (flare.customUpdateCallback) {
              flare.customUpdateCallback(flare);
            } else {
              flare.updateLensFlares();
            }
            gl.uniform1i(uniforms.renderType, 2);
            state.enable(gl.BLEND);
            for (var j = 0,
                jl = flare.lensFlares.length; j < jl; j++) {
              var sprite = flare.lensFlares[j];
              if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                screenPosition.x = sprite.x;
                screenPosition.y = sprite.y;
                screenPosition.z = sprite.z;
                size = sprite.size * sprite.scale / viewportHeight;
                scale.x = size * invAspect;
                scale.y = size;
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform1f(uniforms.rotation, sprite.rotation);
                gl.uniform1f(uniforms.opacity, sprite.opacity);
                gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                renderer.setTexture(sprite.texture, 1);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
              }
            }
          }
        }
        state.enable(gl.CULL_FACE);
        state.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        renderer.resetGLState();
      };
      function createProgram(shader) {
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = "precision " + renderer.getPrecision() + " float;\n";
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
      }
    };
    THREE.SpritePlugin = function(renderer, sprites) {
      var gl = renderer.context;
      var state = renderer.state;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var texture;
      var spritePosition = new THREE.Vector3();
      var spriteRotation = new THREE.Quaternion();
      var spriteScale = new THREE.Vector3();
      function init() {
        var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        program = createProgram();
        attributes = {
          position: gl.getAttribLocation(program, 'position'),
          uv: gl.getAttribLocation(program, 'uv')
        };
        uniforms = {
          uvOffset: gl.getUniformLocation(program, 'uvOffset'),
          uvScale: gl.getUniformLocation(program, 'uvScale'),
          rotation: gl.getUniformLocation(program, 'rotation'),
          scale: gl.getUniformLocation(program, 'scale'),
          color: gl.getUniformLocation(program, 'color'),
          map: gl.getUniformLocation(program, 'map'),
          opacity: gl.getUniformLocation(program, 'opacity'),
          modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
          projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
          fogType: gl.getUniformLocation(program, 'fogType'),
          fogDensity: gl.getUniformLocation(program, 'fogDensity'),
          fogNear: gl.getUniformLocation(program, 'fogNear'),
          fogFar: gl.getUniformLocation(program, 'fogFar'),
          fogColor: gl.getUniformLocation(program, 'fogColor'),
          alphaTest: gl.getUniformLocation(program, 'alphaTest')
        };
        var canvas = document.createElement('canvas');
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 8, 8);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
      }
      this.render = function(scene, camera) {
        if (sprites.length === 0)
          return;
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        state.initAttributes();
        state.enableAttribute(attributes.position);
        state.enableAttribute(attributes.uv);
        state.disableUnusedAttributes();
        state.disable(gl.CULL_FACE);
        state.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        state.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
          gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
          if (fog instanceof THREE.Fog) {
            gl.uniform1f(uniforms.fogNear, fog.near);
            gl.uniform1f(uniforms.fogFar, fog.far);
            gl.uniform1i(uniforms.fogType, 1);
            oldFogType = 1;
            sceneFogType = 1;
          } else if (fog instanceof THREE.FogExp2) {
            gl.uniform1f(uniforms.fogDensity, fog.density);
            gl.uniform1i(uniforms.fogType, 2);
            oldFogType = 2;
            sceneFogType = 2;
          }
        } else {
          gl.uniform1i(uniforms.fogType, 0);
          oldFogType = 0;
          sceneFogType = 0;
        }
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
          sprite.z = -sprite.modelViewMatrix.elements[14];
        }
        sprites.sort(painterSortStable);
        var scale = [];
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          var material = sprite.material;
          gl.uniform1f(uniforms.alphaTest, material.alphaTest);
          gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
          sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
          scale[0] = spriteScale.x;
          scale[1] = spriteScale.y;
          var fogType = 0;
          if (scene.fog && material.fog) {
            fogType = sceneFogType;
          }
          if (oldFogType !== fogType) {
            gl.uniform1i(uniforms.fogType, fogType);
            oldFogType = fogType;
          }
          if (material.map !== null) {
            gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
            gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
          } else {
            gl.uniform2f(uniforms.uvOffset, 0, 0);
            gl.uniform2f(uniforms.uvScale, 1, 1);
          }
          gl.uniform1f(uniforms.opacity, material.opacity);
          gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
          gl.uniform1f(uniforms.rotation, material.rotation);
          gl.uniform2fv(uniforms.scale, scale);
          state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          state.setDepthTest(material.depthTest);
          state.setDepthWrite(material.depthWrite);
          if (material.map && material.map.image && material.map.image.width) {
            renderer.setTexture(material.map, 0);
          } else {
            renderer.setTexture(texture, 0);
          }
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        state.enable(gl.CULL_FACE);
        renderer.resetGLState();
      };
      function createProgram() {
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));
        gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
      }
      function painterSortStable(a, b) {
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return b.id - a.id;
        }
      }
    };
    THREE.CurveUtils = {
      tangentQuadraticBezier: function(t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
      },
      tangentCubicBezier: function(t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
      },
      tangentSpline: function(t, p0, p1, p2, p3) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
      },
      interpolate: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    };
    THREE.GeometryUtils = {
      merge: function(geometry1, geometry2, materialIndexOffset) {
        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        var matrix;
        if (geometry2 instanceof THREE.Mesh) {
          geometry2.matrixAutoUpdate && geometry2.updateMatrix();
          matrix = geometry2.matrix;
          geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
      },
      center: function(geometry) {
        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry.center();
      }
    };
    THREE.ImageUtils = {
      crossOrigin: undefined,
      loadTexture: function(url, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTexture is being deprecated. Use THREE.TextureLoader() instead.');
        var loader = new THREE.TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(url, onLoad, undefined, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      },
      loadTextureCube: function(urls, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTextureCube is being deprecated. Use THREE.CubeTextureLoader() instead.');
        var loader = new THREE.CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(urls, onLoad, undefined, onError);
        if (mapping)
          texture.mapping = mapping;
        return texture;
      },
      loadCompressedTexture: function() {
        console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
      },
      loadCompressedTextureCube: function() {
        console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
      }
    };
    THREE.SceneUtils = {
      createMultiMaterialObject: function(geometry, materials) {
        var group = new THREE.Group();
        for (var i = 0,
            l = materials.length; i < l; i++) {
          group.add(new THREE.Mesh(geometry, materials[i]));
        }
        return group;
      },
      detach: function(child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
      },
      attach: function(child, scene, parent) {
        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
      }
    };
    THREE.ShapeUtils = {
      area: function(contour) {
        var n = contour.length;
        var a = 0.0;
        for (var p = n - 1,
            q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      },
      triangulate: (function() {
        function snip(contour, u, v, w, n, verts) {
          var p;
          var ax,
              ay,
              bx,
              by;
          var cx,
              cy,
              px,
              py;
          ax = contour[verts[u]].x;
          ay = contour[verts[u]].y;
          bx = contour[verts[v]].x;
          by = contour[verts[v]].y;
          cx = contour[verts[w]].x;
          cy = contour[verts[w]].y;
          if (Number.EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))))
            return false;
          var aX,
              aY,
              bX,
              bY,
              cX,
              cY;
          var apx,
              apy,
              bpx,
              bpy,
              cpx,
              cpy;
          var cCROSSap,
              bCROSScp,
              aCROSSbp;
          aX = cx - bx;
          aY = cy - by;
          bX = ax - cx;
          bY = ay - cy;
          cX = bx - ax;
          cY = by - ay;
          for (p = 0; p < n; p++) {
            px = contour[verts[p]].x;
            py = contour[verts[p]].y;
            if (((px === ax) && (py === ay)) || ((px === bx) && (py === by)) || ((px === cx) && (py === cy)))
              continue;
            apx = px - ax;
            apy = py - ay;
            bpx = px - bx;
            bpy = py - by;
            cpx = px - cx;
            cpy = py - cy;
            aCROSSbp = aX * bpy - aY * bpx;
            cCROSSap = cX * apy - cY * apx;
            bCROSScp = bX * cpy - bY * cpx;
            if ((aCROSSbp >= -Number.EPSILON) && (bCROSScp >= -Number.EPSILON) && (cCROSSap >= -Number.EPSILON))
              return false;
          }
          return true;
        }
        return function(contour, indices) {
          var n = contour.length;
          if (n < 3)
            return null;
          var result = [],
              verts = [],
              vertIndices = [];
          var u,
              v,
              w;
          if (THREE.ShapeUtils.area(contour) > 0.0) {
            for (v = 0; v < n; v++)
              verts[v] = v;
          } else {
            for (v = 0; v < n; v++)
              verts[v] = (n - 1) - v;
          }
          var nv = n;
          var count = 2 * nv;
          for (v = nv - 1; nv > 2; ) {
            if ((count--) <= 0) {
              console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');
              if (indices)
                return vertIndices;
              return result;
            }
            u = v;
            if (nv <= u)
              u = 0;
            v = u + 1;
            if (nv <= v)
              v = 0;
            w = v + 1;
            if (nv <= w)
              w = 0;
            if (snip(contour, u, v, w, nv, verts)) {
              var a,
                  b,
                  c,
                  s,
                  t;
              a = verts[u];
              b = verts[v];
              c = verts[w];
              result.push([contour[a], contour[b], contour[c]]);
              vertIndices.push([verts[u], verts[v], verts[w]]);
              for (s = v, t = v + 1; t < nv; s++, t++) {
                verts[s] = verts[t];
              }
              nv--;
              count = 2 * nv;
            }
          }
          if (indices)
            return vertIndices;
          return result;
        };
      })(),
      triangulateShape: function(contour, holes) {
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
          if (inSegPt1.x !== inSegPt2.x) {
            if (inSegPt1.x < inSegPt2.x) {
              return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
            } else {
              return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
            }
          } else {
            if (inSegPt1.y < inSegPt2.y) {
              return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
            } else {
              return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
            }
          }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
          var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
              seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
          var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
              seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
          var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
          var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
          var limit = seg1dy * seg2dx - seg1dx * seg2dy;
          var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
          if (Math.abs(limit) > Number.EPSILON) {
            var perpSeg2;
            if (limit > 0) {
              if ((perpSeg1 < 0) || (perpSeg1 > limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 < 0) || (perpSeg2 > limit))
                return [];
            } else {
              if ((perpSeg1 > 0) || (perpSeg1 < limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 > 0) || (perpSeg2 < limit))
                return [];
            }
            if (perpSeg2 === 0) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 === 0) || (perpSeg1 === limit)))
                return [];
              return [inSeg1Pt1];
            }
            if (perpSeg2 === limit) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 === 0) || (perpSeg1 === limit)))
                return [];
              return [inSeg1Pt2];
            }
            if (perpSeg1 === 0)
              return [inSeg2Pt1];
            if (perpSeg1 === limit)
              return [inSeg2Pt2];
            var factorSeg1 = perpSeg2 / limit;
            return [{
              x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy
            }];
          } else {
            if ((perpSeg1 !== 0) || (seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy))
              return [];
            var seg1Pt = ((seg1dx === 0) && (seg1dy === 0));
            var seg2Pt = ((seg2dx === 0) && (seg2dy === 0));
            if (seg1Pt && seg2Pt) {
              if ((inSeg1Pt1.x !== inSeg2Pt1.x) || (inSeg1Pt1.y !== inSeg2Pt1.y))
                return [];
              return [inSeg1Pt1];
            }
            if (seg1Pt) {
              if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                return [];
              return [inSeg1Pt1];
            }
            if (seg2Pt) {
              if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                return [];
              return [inSeg2Pt1];
            }
            var seg1min,
                seg1max,
                seg1minVal,
                seg1maxVal;
            var seg2min,
                seg2max,
                seg2minVal,
                seg2maxVal;
            if (seg1dx !== 0) {
              if (inSeg1Pt1.x < inSeg1Pt2.x) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.x;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.x;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.x;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.x;
              }
              if (inSeg2Pt1.x < inSeg2Pt2.x) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.x;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.x;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.x;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.x;
              }
            } else {
              if (inSeg1Pt1.y < inSeg1Pt2.y) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.y;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.y;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.y;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.y;
              }
              if (inSeg2Pt1.y < inSeg2Pt2.y) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.y;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.y;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.y;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.y;
              }
            }
            if (seg1minVal <= seg2minVal) {
              if (seg1maxVal < seg2minVal)
                return [];
              if (seg1maxVal === seg2minVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg2min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg2min, seg1max];
              return [seg2min, seg2max];
            } else {
              if (seg1minVal > seg2maxVal)
                return [];
              if (seg1minVal === seg2maxVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg1min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg1min, seg1max];
              return [seg1min, seg2max];
            }
          }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
          var legFromPtX = inLegFromPt.x - inVertex.x,
              legFromPtY = inLegFromPt.y - inVertex.y;
          var legToPtX = inLegToPt.x - inVertex.x,
              legToPtY = inLegToPt.y - inVertex.y;
          var otherPtX = inOtherPt.x - inVertex.x,
              otherPtY = inOtherPt.y - inVertex.y;
          var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
          var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
          if (Math.abs(from2toAngle) > Number.EPSILON) {
            var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
            if (from2toAngle > 0) {
              return ((from2otherAngle >= 0) && (other2toAngle >= 0));
            } else {
              return ((from2otherAngle >= 0) || (other2toAngle >= 0));
            }
          } else {
            return (from2otherAngle > 0);
          }
        }
        function removeHoles(contour, holes) {
          var shape = contour.concat();
          var hole;
          function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
            var lastShapeIdx = shape.length - 1;
            var prevShapeIdx = inShapeIdx - 1;
            if (prevShapeIdx < 0)
              prevShapeIdx = lastShapeIdx;
            var nextShapeIdx = inShapeIdx + 1;
            if (nextShapeIdx > lastShapeIdx)
              nextShapeIdx = 0;
            var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
            if (!insideAngle) {
              return false;
            }
            var lastHoleIdx = hole.length - 1;
            var prevHoleIdx = inHoleIdx - 1;
            if (prevHoleIdx < 0)
              prevHoleIdx = lastHoleIdx;
            var nextHoleIdx = inHoleIdx + 1;
            if (nextHoleIdx > lastHoleIdx)
              nextHoleIdx = 0;
            insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
            if (!insideAngle) {
              return false;
            }
            return true;
          }
          function intersectsShapeEdge(inShapePt, inHolePt) {
            var sIdx,
                nextIdx,
                intersection;
            for (sIdx = 0; sIdx < shape.length; sIdx++) {
              nextIdx = sIdx + 1;
              nextIdx %= shape.length;
              intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
              if (intersection.length > 0)
                return true;
            }
            return false;
          }
          var indepHoles = [];
          function intersectsHoleEdge(inShapePt, inHolePt) {
            var ihIdx,
                chkHole,
                hIdx,
                nextIdx,
                intersection;
            for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
              chkHole = holes[indepHoles[ihIdx]];
              for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                nextIdx = hIdx + 1;
                nextIdx %= chkHole.length;
                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                if (intersection.length > 0)
                  return true;
              }
            }
            return false;
          }
          var holeIndex,
              shapeIndex,
              shapePt,
              holePt,
              holeIdx,
              cutKey,
              failedCuts = [],
              tmpShape1,
              tmpShape2,
              tmpHole1,
              tmpHole2;
          for (var h = 0,
              hl = holes.length; h < hl; h++) {
            indepHoles.push(h);
          }
          var minShapeIndex = 0;
          var counter = indepHoles.length * 2;
          while (indepHoles.length > 0) {
            counter--;
            if (counter < 0) {
              console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
              break;
            }
            for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
              shapePt = shape[shapeIndex];
              holeIndex = -1;
              for (var h = 0; h < indepHoles.length; h++) {
                holeIdx = indepHoles[h];
                cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                if (failedCuts[cutKey] !== undefined)
                  continue;
                hole = holes[holeIdx];
                for (var h2 = 0; h2 < hole.length; h2++) {
                  holePt = hole[h2];
                  if (!isCutLineInsideAngles(shapeIndex, h2))
                    continue;
                  if (intersectsShapeEdge(shapePt, holePt))
                    continue;
                  if (intersectsHoleEdge(shapePt, holePt))
                    continue;
                  holeIndex = h2;
                  indepHoles.splice(h, 1);
                  tmpShape1 = shape.slice(0, shapeIndex + 1);
                  tmpShape2 = shape.slice(shapeIndex);
                  tmpHole1 = hole.slice(holeIndex);
                  tmpHole2 = hole.slice(0, holeIndex + 1);
                  shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                  minShapeIndex = shapeIndex;
                  break;
                }
                if (holeIndex >= 0)
                  break;
                failedCuts[cutKey] = true;
              }
              if (holeIndex >= 0)
                break;
            }
          }
          return shape;
        }
        var i,
            il,
            f,
            face,
            key,
            index,
            allPointsMap = {};
        var allpoints = contour.concat();
        for (var h = 0,
            hl = holes.length; h < hl; h++) {
          Array.prototype.push.apply(allpoints, holes[h]);
        }
        for (i = 0, il = allpoints.length; i < il; i++) {
          key = allpoints[i].x + ":" + allpoints[i].y;
          if (allPointsMap[key] !== undefined) {
            console.warn("THREE.Shape: Duplicate point", key);
          }
          allPointsMap[key] = i;
        }
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangles = THREE.ShapeUtils.triangulate(shapeWithoutHoles, false);
        for (i = 0, il = triangles.length; i < il; i++) {
          face = triangles[i];
          for (f = 0; f < 3; f++) {
            key = face[f].x + ":" + face[f].y;
            index = allPointsMap[key];
            if (index !== undefined) {
              face[f] = index;
            }
          }
        }
        return triangles.concat();
      },
      isClockWise: function(pts) {
        return THREE.ShapeUtils.area(pts) < 0;
      },
      b2: (function() {
        function b2p0(t, p) {
          var k = 1 - t;
          return k * k * p;
        }
        function b2p1(t, p) {
          return 2 * (1 - t) * t * p;
        }
        function b2p2(t, p) {
          return t * t * p;
        }
        return function(t, p0, p1, p2) {
          return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
        };
      })(),
      b3: (function() {
        function b3p0(t, p) {
          var k = 1 - t;
          return k * k * k * p;
        }
        function b3p1(t, p) {
          var k = 1 - t;
          return 3 * k * k * t * p;
        }
        function b3p2(t, p) {
          var k = 1 - t;
          return 3 * k * t * t * p;
        }
        function b3p3(t, p) {
          return t * t * t * p;
        }
        return function(t, p0, p1, p2, p3) {
          return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
        };
      })()
    };
    THREE.Audio = function(listener) {
      THREE.Object3D.call(this);
      this.type = 'Audio';
      this.context = listener.context;
      this.source = this.context.createBufferSource();
      this.source.onended = this.onEnded.bind(this);
      this.gain = this.context.createGain();
      this.gain.connect(this.context.destination);
      this.panner = this.context.createPanner();
      this.panner.connect(this.gain);
      this.autoplay = false;
      this.startTime = 0;
      this.playbackRate = 1;
      this.isPlaying = false;
    };
    THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Audio.prototype.constructor = THREE.Audio;
    THREE.Audio.prototype.load = function(file) {
      var scope = this;
      var request = new XMLHttpRequest();
      request.open('GET', file, true);
      request.responseType = 'arraybuffer';
      request.onload = function(e) {
        scope.context.decodeAudioData(this.response, function(buffer) {
          scope.source.buffer = buffer;
          if (scope.autoplay)
            scope.play();
        });
      };
      request.send();
      return this;
    };
    THREE.Audio.prototype.play = function() {
      if (this.isPlaying === true) {
        console.warn('THREE.Audio: Audio is already playing.');
        return;
      }
      var source = this.context.createBufferSource();
      source.buffer = this.source.buffer;
      source.loop = this.source.loop;
      source.onended = this.source.onended;
      source.start(0, this.startTime);
      source.playbackRate.value = this.playbackRate;
      this.isPlaying = true;
      this.source = source;
      this.connect();
    };
    THREE.Audio.prototype.pause = function() {
      this.source.stop();
      this.startTime = this.context.currentTime;
    };
    THREE.Audio.prototype.stop = function() {
      this.source.stop();
      this.startTime = 0;
    };
    THREE.Audio.prototype.connect = function() {
      if (this.filter !== undefined) {
        this.source.connect(this.filter);
        this.filter.connect(this.panner);
      } else {
        this.source.connect(this.panner);
      }
    };
    THREE.Audio.prototype.disconnect = function() {
      if (this.filter !== undefined) {
        this.source.disconnect(this.filter);
        this.filter.disconnect(this.panner);
      } else {
        this.source.disconnect(this.panner);
      }
    };
    THREE.Audio.prototype.setFilter = function(value) {
      if (this.isPlaying === true) {
        this.disconnect();
        this.filter = value;
        this.connect();
      } else {
        this.filter = value;
      }
    };
    THREE.Audio.prototype.getFilter = function() {
      return this.filter;
    };
    THREE.Audio.prototype.setPlaybackRate = function(value) {
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.value = this.playbackRate;
      }
    };
    THREE.Audio.prototype.getPlaybackRate = function() {
      return this.playbackRate;
    };
    THREE.Audio.prototype.onEnded = function() {
      this.isPlaying = false;
    };
    THREE.Audio.prototype.setLoop = function(value) {
      this.source.loop = value;
    };
    THREE.Audio.prototype.getLoop = function() {
      return this.source.loop;
    };
    THREE.Audio.prototype.setRefDistance = function(value) {
      this.panner.refDistance = value;
    };
    THREE.Audio.prototype.getRefDistance = function() {
      return this.panner.refDistance;
    };
    THREE.Audio.prototype.setRolloffFactor = function(value) {
      this.panner.rolloffFactor = value;
    };
    THREE.Audio.prototype.getRolloffFactor = function() {
      return this.panner.rolloffFactor;
    };
    THREE.Audio.prototype.setVolume = function(value) {
      this.gain.gain.value = value;
    };
    THREE.Audio.prototype.getVolume = function() {
      return this.gain.gain.value;
    };
    THREE.Audio.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      return function updateMatrixWorld(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        position.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(position.x, position.y, position.z);
      };
    })();
    THREE.AudioListener = function() {
      THREE.Object3D.call(this);
      this.type = 'AudioListener';
      this.context = new (window.AudioContext || window.webkitAudioContext)();
    };
    THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
    THREE.AudioListener.prototype.constructor = THREE.AudioListener;
    THREE.AudioListener.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      var orientation = new THREE.Vector3();
      return function updateMatrixWorld(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.matrixWorld.decompose(position, quaternion, scale);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
      };
    })();
    THREE.Curve = function() {};
    THREE.Curve.prototype = {
      constructor: THREE.Curve,
      getPoint: function(t) {
        console.warn("THREE.Curve: Warning, getPoint() not implemented!");
        return null;
      },
      getPointAt: function(u) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t);
      },
      getPoints: function(divisions) {
        if (!divisions)
          divisions = 5;
        var d,
            pts = [];
        for (d = 0; d <= divisions; d++) {
          pts.push(this.getPoint(d / divisions));
        }
        return pts;
      },
      getSpacedPoints: function(divisions) {
        if (!divisions)
          divisions = 5;
        var d,
            pts = [];
        for (d = 0; d <= divisions; d++) {
          pts.push(this.getPointAt(d / divisions));
        }
        return pts;
      },
      getLength: function() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
      },
      getLengths: function(divisions) {
        if (!divisions)
          divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
        if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current,
            last = this.getPoint(0);
        var p,
            sum = 0;
        cache.push(0);
        for (p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      },
      updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
      },
      getUtoTmapping: function(u, distance) {
        var arcLengths = this.getLengths();
        var i = 0,
            il = arcLengths.length;
        var targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        var low = 0,
            high = il - 1,
            comparison;
        while (low <= high) {
          i = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i] - targetArcLength;
          if (comparison < 0) {
            low = i + 1;
          } else if (comparison > 0) {
            high = i - 1;
          } else {
            high = i;
            break;
          }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) {
          var t = i / (il - 1);
          return t;
        }
        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;
        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        var t = (i + segmentFraction) / (il - 1);
        return t;
      },
      getTangent: function(t) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;
        if (t1 < 0)
          t1 = 0;
        if (t2 > 1)
          t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var vec = pt2.clone().sub(pt1);
        return vec.normalize();
      },
      getTangentAt: function(u) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t);
      }
    };
    THREE.Curve.Utils = THREE.CurveUtils;
    THREE.Curve.create = function(constructor, getPointFunc) {
      constructor.prototype = Object.create(THREE.Curve.prototype);
      constructor.prototype.constructor = constructor;
      constructor.prototype.getPoint = getPointFunc;
      return constructor;
    };
    THREE.CurvePath = function() {
      this.curves = [];
      this.autoClose = false;
    };
    THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
    THREE.CurvePath.prototype.constructor = THREE.CurvePath;
    THREE.CurvePath.prototype.add = function(curve) {
      this.curves.push(curve);
    };
    THREE.CurvePath.prototype.closePath = function() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new THREE.LineCurve(endPoint, startPoint));
      }
    };
    THREE.CurvePath.prototype.getPoint = function(t) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var u = 1 - diff / curve.getLength();
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    };
    THREE.CurvePath.prototype.getLength = function() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    };
    THREE.CurvePath.prototype.getCurveLengths = function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      var lengths = [],
          sums = 0;
      for (var i = 0,
          l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    };
    THREE.CurvePath.prototype.createPointsGeometry = function(divisions) {
      var pts = this.getPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {
      var pts = this.getSpacedPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createGeometry = function(points) {
      var geometry = new THREE.Geometry();
      for (var i = 0,
          l = points.length; i < l; i++) {
        var point = points[i];
        geometry.vertices.push(new THREE.Vector3(point.x, point.y, point.z || 0));
      }
      return geometry;
    };
    THREE.Path = function(points) {
      THREE.CurvePath.call(this);
      this.actions = [];
      if (points) {
        this.fromPoints(points);
      }
    };
    THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
    THREE.Path.prototype.constructor = THREE.Path;
    THREE.Path.prototype.fromPoints = function(vectors) {
      this.moveTo(vectors[0].x, vectors[0].y);
      for (var i = 1,
          l = vectors.length; i < l; i++) {
        this.lineTo(vectors[i].x, vectors[i].y);
      }
    };
    THREE.Path.prototype.moveTo = function(x, y) {
      this.actions.push({
        action: 'moveTo',
        args: [x, y]
      });
    };
    THREE.Path.prototype.lineTo = function(x, y) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
      this.curves.push(curve);
      this.actions.push({
        action: 'lineTo',
        args: [x, y]
      });
    };
    THREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: 'quadraticCurveTo',
        args: [aCPx, aCPy, aX, aY]
      });
    };
    THREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: 'bezierCurveTo',
        args: [aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]
      });
    };
    THREE.Path.prototype.splineThru = function(pts) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var npts = [new THREE.Vector2(x0, y0)];
      Array.prototype.push.apply(npts, pts);
      var curve = new THREE.SplineCurve(npts);
      this.curves.push(curve);
      this.actions.push({
        action: 'splineThru',
        args: args
      });
    };
    THREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    };
    THREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var args = [aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation || 0];
      var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      args.push(lastPoint.x);
      args.push(lastPoint.y);
      this.actions.push({
        action: 'ellipse',
        args: args
      });
    };
    THREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {
      if (!divisions)
        divisions = 40;
      var points = [];
      for (var i = 0; i < divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      return points;
    };
    THREE.Path.prototype.getPoints = function(divisions, closedPath) {
      divisions = divisions || 12;
      var b2 = THREE.ShapeUtils.b2;
      var b3 = THREE.ShapeUtils.b3;
      var points = [];
      var cpx,
          cpy,
          cpx2,
          cpy2,
          cpx1,
          cpy1,
          cpx0,
          cpy0,
          laste,
          tx,
          ty;
      for (var i = 0,
          l = this.actions.length; i < l; i++) {
        var item = this.actions[i];
        var action = item.action;
        var args = item.args;
        switch (action) {
          case 'moveTo':
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case 'lineTo':
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case 'quadraticCurveTo':
            cpx = args[2];
            cpy = args[3];
            cpx1 = args[0];
            cpy1 = args[1];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (var j = 1; j <= divisions; j++) {
              var t = j / divisions;
              tx = b2(t, cpx0, cpx1, cpx);
              ty = b2(t, cpy0, cpy1, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case 'bezierCurveTo':
            cpx = args[4];
            cpy = args[5];
            cpx1 = args[0];
            cpy1 = args[1];
            cpx2 = args[2];
            cpy2 = args[3];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (var j = 1; j <= divisions; j++) {
              var t = j / divisions;
              tx = b3(t, cpx0, cpx1, cpx2, cpx);
              ty = b3(t, cpy0, cpy1, cpy2, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case 'splineThru':
            laste = this.actions[i - 1].args;
            var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
            var spts = [last];
            var n = divisions * args[0].length;
            spts = spts.concat(args[0]);
            var spline = new THREE.SplineCurve(spts);
            for (var j = 1; j <= n; j++) {
              points.push(spline.getPointAt(j / n));
            }
            break;
          case 'arc':
            var aX = args[0],
                aY = args[1],
                aRadius = args[2],
                aStartAngle = args[3],
                aEndAngle = args[4],
                aClockwise = !!args[5];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (var j = 1; j <= tdivisions; j++) {
              var t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + aRadius * Math.cos(angle);
              ty = aY + aRadius * Math.sin(angle);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case 'ellipse':
            var aX = args[0],
                aY = args[1],
                xRadius = args[2],
                yRadius = args[3],
                aStartAngle = args[4],
                aEndAngle = args[5],
                aClockwise = !!args[6],
                aRotation = args[7];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            var cos,
                sin;
            if (aRotation !== 0) {
              cos = Math.cos(aRotation);
              sin = Math.sin(aRotation);
            }
            for (var j = 1; j <= tdivisions; j++) {
              var t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + xRadius * Math.cos(angle);
              ty = aY + yRadius * Math.sin(angle);
              if (aRotation !== 0) {
                var x = tx,
                    y = ty;
                tx = (x - aX) * cos - (y - aY) * sin + aX;
                ty = (x - aX) * sin + (y - aY) * cos + aY;
              }
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
        }
      }
      var lastPoint = points[points.length - 1];
      if (Math.abs(lastPoint.x - points[0].x) < Number.EPSILON && Math.abs(lastPoint.y - points[0].y) < Number.EPSILON)
        points.splice(points.length - 1, 1);
      if (closedPath) {
        points.push(points[0]);
      }
      return points;
    };
    THREE.Path.prototype.toShapes = function(isCCW, noHoles) {
      function extractSubpaths(inActions) {
        var subPaths = [],
            lastPath = new THREE.Path();
        for (var i = 0,
            l = inActions.length; i < l; i++) {
          var item = inActions[i];
          var args = item.args;
          var action = item.action;
          if (action === 'moveTo') {
            if (lastPath.actions.length !== 0) {
              subPaths.push(lastPath);
              lastPath = new THREE.Path();
            }
          }
          lastPath[action].apply(lastPath, args);
        }
        if (lastPath.actions.length !== 0) {
          subPaths.push(lastPath);
        }
        return subPaths;
      }
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];
        for (var i = 0,
            l = inSubpaths.length; i < l; i++) {
          var tmpPath = inSubpaths[i];
          var tmpShape = new THREE.Shape();
          tmpShape.actions = tmpPath.actions;
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
        }
        return shapes;
      }
      function isPointInsidePolygon(inPt, inPolygon) {
        var polyLen = inPolygon.length;
        var inside = false;
        for (var p = polyLen - 1,
            q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
              continue;
            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x)
                return true;
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y !== edgeLowPt.y)
              continue;
            if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
              return true;
          }
        }
        return inside;
      }
      var isClockWise = THREE.ShapeUtils.isClockWise;
      var subPaths = extractSubpaths(this.actions);
      if (subPaths.length === 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      var solid,
          tmpPath,
          tmpShape,
          shapes = [];
      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      var holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];
      for (var i = 0,
          l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if ((!holesFirst) && (newShapes[mainIdx]))
            mainIdx++;
          newShapes[mainIdx] = {
            s: new THREE.Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.actions = tmpPath.actions;
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          });
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        var ambiguous = false;
        var toChange = [];
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          var sho = newShapeHoles[sIdx];
          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx !== s2Idx)
                  toChange.push({
                    froms: sIdx,
                    tos: s2Idx,
                    hole: hIdx
                  });
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambiguous)
            newShapeHoles = betterShapeHoles;
        }
      }
      var tmpHoles;
      for (var i = 0,
          il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (var j = 0,
            jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    };
    THREE.Shape = function() {
      THREE.Path.apply(this, arguments);
      this.holes = [];
    };
    THREE.Shape.prototype = Object.create(THREE.Path.prototype);
    THREE.Shape.prototype.constructor = THREE.Shape;
    THREE.Shape.prototype.extrude = function(options) {
      return new THREE.ExtrudeGeometry(this, options);
    };
    THREE.Shape.prototype.makeGeometry = function(options) {
      return new THREE.ShapeGeometry(this, options);
    };
    THREE.Shape.prototype.getPointsHoles = function(divisions) {
      var holesPts = [];
      for (var i = 0,
          l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    };
    THREE.Shape.prototype.extractAllPoints = function(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    };
    THREE.Shape.prototype.extractPoints = function(divisions) {
      return this.extractAllPoints(divisions);
    };
    THREE.Shape.Utils = THREE.ShapeUtils;
    THREE.LineCurve = function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.LineCurve.prototype.constructor = THREE.LineCurve;
    THREE.LineCurve.prototype.getPoint = function(t) {
      var point = this.v2.clone().sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
      return point;
    };
    THREE.LineCurve.prototype.getPointAt = function(u) {
      return this.getPoint(u);
    };
    THREE.LineCurve.prototype.getTangent = function(t) {
      var tangent = this.v2.clone().sub(this.v1);
      return tangent.normalize();
    };
    THREE.QuadraticBezierCurve = function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
    THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
      var b2 = THREE.ShapeUtils.b2;
      return new THREE.Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
    };
    THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
      var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;
      return new THREE.Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
    };
    THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    };
    THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
    THREE.CubicBezierCurve.prototype.getPoint = function(t) {
      var b3 = THREE.ShapeUtils.b3;
      return new THREE.Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
    };
    THREE.CubicBezierCurve.prototype.getTangent = function(t) {
      var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;
      return new THREE.Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
    };
    THREE.SplineCurve = function(points) {
      this.points = (points == undefined) ? [] : points;
    };
    THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
    THREE.SplineCurve.prototype.getPoint = function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var interpolate = THREE.CurveUtils.interpolate;
      return new THREE.Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
    };
    THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
      this.aRotation = aRotation || 0;
    };
    THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
    THREE.EllipseCurve.prototype.getPoint = function(t) {
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      if (deltaAngle < 0)
        deltaAngle += Math.PI * 2;
      if (deltaAngle > Math.PI * 2)
        deltaAngle -= Math.PI * 2;
      var angle;
      if (this.aClockwise === true) {
        angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
      } else {
        angle = this.aStartAngle + t * deltaAngle;
      }
      var x = this.aX + this.xRadius * Math.cos(angle);
      var y = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        var cos = Math.cos(this.aRotation);
        var sin = Math.sin(this.aRotation);
        var tx = x,
            ty = y;
        x = (tx - this.aX) * cos - (ty - this.aY) * sin + this.aX;
        y = (tx - this.aX) * sin + (ty - this.aY) * cos + this.aY;
      }
      return new THREE.Vector2(x, y);
    };
    THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
    THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
    THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.subVectors(this.v2, this.v1);
      vector.multiplyScalar(t);
      vector.add(this.v1);
      return vector;
    });
    THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var b2 = THREE.ShapeUtils.b2;
      return new THREE.Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
    });
    THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }, function(t) {
      var b3 = THREE.ShapeUtils.b3;
      return new THREE.Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
    });
    THREE.SplineCurve3 = THREE.Curve.create(function(points) {
      console.warn('THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3');
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var interpolate = THREE.CurveUtils.interpolate;
      return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
    });
    THREE.CatmullRomCurve3 = (function() {
      var tmp = new THREE.Vector3(),
          px = new CubicPoly(),
          py = new CubicPoly(),
          pz = new CubicPoly();
      function CubicPoly() {}
      CubicPoly.prototype.init = function(x0, x1, t0, t1) {
        this.c0 = x0;
        this.c1 = t0;
        this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
        this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
      };
      CubicPoly.prototype.initNonuniformCatmullRom = function(x0, x1, x2, x3, dt0, dt1, dt2) {
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        this.init(x1, x2, t1, t2);
      };
      CubicPoly.prototype.initCatmullRom = function(x0, x1, x2, x3, tension) {
        this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      };
      CubicPoly.prototype.calc = function(t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
      };
      return THREE.Curve.create(function(p) {
        this.points = p || [];
      }, function(t) {
        var points = this.points,
            point,
            intPoint,
            weight,
            l;
        l = points.length;
        if (l < 2)
          console.log('duh, you need at least 2 points');
        point = (l - 1) * t;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        if (weight === 0 && intPoint === l - 1) {
          intPoint = l - 2;
          weight = 1;
        }
        var p0,
            p1,
            p2,
            p3;
        if (intPoint === 0) {
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;
        } else {
          p0 = points[intPoint - 1];
        }
        p1 = points[intPoint];
        p2 = points[intPoint + 1];
        if (intPoint + 2 < l) {
          p3 = points[intPoint + 2];
        } else {
          tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 2]);
          p3 = tmp;
        }
        if (this.type === undefined || this.type === 'centripetal' || this.type === 'chordal') {
          var pow = this.type === 'chordal' ? 0.5 : 0.25;
          var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
          if (dt1 < 1e-4)
            dt1 = 1.0;
          if (dt0 < 1e-4)
            dt0 = dt1;
          if (dt2 < 1e-4)
            dt2 = dt1;
          px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.type === 'catmullrom') {
          var tension = this.tension !== undefined ? this.tension : 0.5;
          px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension);
          py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension);
          pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }
        var v = new THREE.Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
        return v;
      });
    })();
    THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points) {
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 0) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
      var point0 = points[(intPoint - 1) % points.length];
      var point1 = points[(intPoint) % points.length];
      var point2 = points[(intPoint + 1) % points.length];
      var point3 = points[(intPoint + 2) % points.length];
      var interpolate = THREE.CurveUtils.interpolate;
      return new THREE.Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
    });
    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
      THREE.Geometry.call(this);
      this.type = 'BoxGeometry';
      this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };
      this.widthSegments = widthSegments || 1;
      this.heightSegments = heightSegments || 1;
      this.depthSegments = depthSegments || 1;
      var scope = this;
      var width_half = width / 2;
      var height_half = height / 2;
      var depth_half = depth / 2;
      buildPlane('z', 'y', -1, -1, depth, height, width_half, 0);
      buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1);
      buildPlane('x', 'z', 1, 1, width, depth, height_half, 2);
      buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3);
      buildPlane('x', 'y', 1, -1, width, height, depth_half, 4);
      buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5);
      function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
        var w,
            ix,
            iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;
        if ((u === 'x' && v === 'y') || (u === 'y' && v === 'x')) {
          w = 'z';
        } else if ((u === 'x' && v === 'z') || (u === 'z' && v === 'x')) {
          w = 'y';
          gridY = scope.depthSegments;
        } else if ((u === 'z' && v === 'y') || (u === 'y' && v === 'z')) {
          w = 'x';
          gridX = scope.depthSegments;
        }
        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();
        normal[w] = depth > 0 ? 1 : -1;
        for (iy = 0; iy < gridY1; iy++) {
          for (ix = 0; ix < gridX1; ix++) {
            var vector = new THREE.Vector3();
            vector[u] = (ix * segment_width - width_half) * udir;
            vector[v] = (iy * segment_height - height_half) * vdir;
            vector[w] = depth;
            scope.vertices.push(vector);
          }
        }
        for (iy = 0; iy < gridY; iy++) {
          for (ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * (iy + 1);
            var c = (ix + 1) + gridX1 * (iy + 1);
            var d = (ix + 1) + gridX1 * iy;
            var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
            var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
            var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
            var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
            var face = new THREE.Face3(a + offset, b + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uva, uvb, uvd]);
            face = new THREE.Face3(b + offset, c + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
          }
        }
      }
      this.mergeVertices();
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
    THREE.BoxGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.BoxGeometry(parameters.width, parameters.height, parameters.depth, parameters.widthSegments, parameters.heightSegments, parameters.depthSegments);
    };
    THREE.CubeGeometry = THREE.BoxGeometry;
    THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CircleGeometry';
      this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      this.fromBufferGeometry(new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    };
    THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
    THREE.CircleGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.CircleGeometry(parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.CircleBufferGeometry = function(radius, segments, thetaStart, thetaLength) {
      THREE.BufferGeometry.call(this);
      this.type = 'CircleBufferGeometry';
      this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      segments = segments !== undefined ? Math.max(3, segments) : 8;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      var vertices = segments + 2;
      var positions = new Float32Array(vertices * 3);
      var normals = new Float32Array(vertices * 3);
      var uvs = new Float32Array(vertices * 2);
      normals[2] = 1.0;
      uvs[0] = 0.5;
      uvs[1] = 0.5;
      for (var s = 0,
          i = 3,
          ii = 2; s <= segments; s++, i += 3, ii += 2) {
        var segment = thetaStart + s / segments * thetaLength;
        positions[i] = radius * Math.cos(segment);
        positions[i + 1] = radius * Math.sin(segment);
        normals[i + 2] = 1;
        uvs[ii] = (positions[i] / radius + 1) / 2;
        uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
      }
      var indices = [];
      for (var i = 1; i <= segments; i++) {
        indices.push(i, i + 1, 0);
      }
      this.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));
      this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
    THREE.CircleBufferGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.CircleBufferGeometry(parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CylinderGeometry';
      this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radiusTop = radiusTop !== undefined ? radiusTop : 20;
      radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
      height = height !== undefined ? height : 100;
      radialSegments = radialSegments || 8;
      heightSegments = heightSegments || 1;
      openEnded = openEnded !== undefined ? openEnded : false;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
      var heightHalf = height / 2;
      var x,
          y,
          vertices = [],
          uvs = [];
      for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var vertex = new THREE.Vector3();
          vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
          vertex.y = -v * height + heightHalf;
          vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      var tanTheta = (radiusBottom - radiusTop) / height;
      var na,
          nb;
      for (x = 0; x < radialSegments; x++) {
        if (radiusTop !== 0) {
          na = this.vertices[vertices[0][x]].clone();
          nb = this.vertices[vertices[0][x + 1]].clone();
        } else {
          na = this.vertices[vertices[1][x]].clone();
          nb = this.vertices[vertices[1][x + 1]].clone();
        }
        na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
        nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
        for (y = 0; y < heightSegments; y++) {
          var v1 = vertices[y][x];
          var v2 = vertices[y + 1][x];
          var v3 = vertices[y + 1][x + 1];
          var v4 = vertices[y][x + 1];
          var n1 = na.clone();
          var n2 = na.clone();
          var n3 = nb.clone();
          var n4 = nb.clone();
          var uv1 = uvs[y][x].clone();
          var uv2 = uvs[y + 1][x].clone();
          var uv3 = uvs[y + 1][x + 1].clone();
          var uv4 = uvs[y][x + 1].clone();
          this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
          this.faceVertexUvs[0].push([uv1, uv2, uv4]);
          this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
          this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
        }
      }
      if (openEnded === false && radiusTop > 0) {
        this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[0][x];
          var v2 = vertices[0][x + 1];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, 1, 0);
          var n2 = new THREE.Vector3(0, 1, 0);
          var n3 = new THREE.Vector3(0, 1, 0);
          var uv1 = uvs[0][x].clone();
          var uv2 = uvs[0][x + 1].clone();
          var uv3 = new THREE.Vector2(uv2.x, 0);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 1));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      if (openEnded === false && radiusBottom > 0) {
        this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[heightSegments][x + 1];
          var v2 = vertices[heightSegments][x];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, -1, 0);
          var n2 = new THREE.Vector3(0, -1, 0);
          var n3 = new THREE.Vector3(0, -1, 0);
          var uv1 = uvs[heightSegments][x + 1].clone();
          var uv2 = uvs[heightSegments][x].clone();
          var uv3 = new THREE.Vector2(uv2.x, 1);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3], undefined, 2));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
    THREE.CylinderGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.CylinderGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.EdgesGeometry = function(geometry, thresholdAngle) {
      THREE.BufferGeometry.call(this);
      thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
      var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));
      var edge = [0, 0],
          hash = {};
      function sortFunction(a, b) {
        return a - b;
      }
      var keys = ['a', 'b', 'c'];
      var geometry2;
      if (geometry instanceof THREE.BufferGeometry) {
        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry(geometry);
      } else {
        geometry2 = geometry.clone();
      }
      geometry2.mergeVertices();
      geometry2.computeFaceNormals();
      var vertices = geometry2.vertices;
      var faces = geometry2.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
          edge[0] = face[keys[j]];
          edge[1] = face[keys[(j + 1) % 3]];
          edge.sort(sortFunction);
          var key = edge.toString();
          if (hash[key] === undefined) {
            hash[key] = {
              vert1: edge[0],
              vert2: edge[1],
              face1: i,
              face2: undefined
            };
          } else {
            hash[key].face2 = i;
          }
        }
      }
      var coords = [];
      for (var key in hash) {
        var h = hash[key];
        if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
          var vertex = vertices[h.vert1];
          coords.push(vertex.x);
          coords.push(vertex.y);
          coords.push(vertex.z);
          vertex = vertices[h.vert2];
          coords.push(vertex.x);
          coords.push(vertex.y);
          coords.push(vertex.z);
        }
      }
      this.addAttribute('position', new THREE.BufferAttribute(new Float32Array(coords), 3));
    };
    THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
    THREE.ExtrudeGeometry = function(shapes, options) {
      if (typeof(shapes) === "undefined") {
        shapes = [];
        return;
      }
      THREE.Geometry.call(this);
      this.type = 'ExtrudeGeometry';
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
    THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
      var sl = shapes.length;
      for (var s = 0; s < sl; s++) {
        var shape = shapes[s];
        this.addShape(shape, options);
      }
    };
    THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
      var amount = options.amount !== undefined ? options.amount : 100;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var extrudePath = options.extrudePath;
      var extrudePts,
          extrudeByPath = false;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
      var splineTube,
          binormal,
          normal,
          position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
      }
      var ahole,
          h,
          hl;
      var scope = this;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          if (THREE.ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      var b,
          bs,
          t,
          z,
          vert,
          vlen = vertices.length,
          face,
          flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        var v_trans_x,
            v_trans_y,
            shrink_by = 1;
        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
        var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
        if (Math.abs(collinear0) > Number.EPSILON) {
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
          var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
          var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
          var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
          v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
          var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
          if (v_trans_lensq <= 2) {
            return new THREE.Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          var direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      var contourMovements = [];
      for (var i = 0,
          il = contour.length,
          j = il - 1,
          k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      var holesMovements = [],
          oneHoleMovements,
          verticesMovements = contourMovements.concat();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * (Math.sin(t * Math.PI / 2));
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }
      bs = bevelSize;
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      var s;
      for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
          vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, amount / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, amount + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            if (!extrudeByPath) {
              v(vert.x, vert.y, amount + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        if (bevelEnabled) {
          var layer = 0;
          var offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
      }
      function buildSideFaces() {
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
      }
      function sidewalls(contour, layeroffset) {
        var j,
            k;
        i = contour.length;
        while (--i >= 0) {
          j = i;
          k = i - 1;
          if (k < 0)
            k = contour.length - 1;
          var s = 0,
              sl = steps + bevelSegments * 2;
          for (s = 0; s < sl; s++) {
            var slen1 = vlen * s;
            var slen2 = vlen * (s + 1);
            var a = layeroffset + j + slen1,
                b = layeroffset + k + slen1,
                c = layeroffset + k + slen2,
                d = layeroffset + j + slen2;
            f4(a, b, c, d, contour, s, sl, j, k);
          }
        }
      }
      function v(x, y, z) {
        scope.vertices.push(new THREE.Vector3(x, y, z));
      }
      function f3(a, b, c) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, c, null, null, 0));
        var uvs = uvgen.generateTopUV(scope, a, b, c);
        scope.faceVertexUvs[0].push(uvs);
      }
      function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, d, null, null, 1));
        scope.faces.push(new THREE.Face3(b, c, d, null, null, 1));
        var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
        scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
        scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
      }
    };
    THREE.ExtrudeGeometry.WorldUVGenerator = {
      generateTopUV: function(geometry, indexA, indexB, indexC) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y)];
      },
      generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        var d = vertices[indexD];
        if (Math.abs(a.y - b.y) < 0.01) {
          return [new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z)];
        } else {
          return [new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z)];
        }
      }
    };
    THREE.ShapeGeometry = function(shapes, options) {
      THREE.Geometry.call(this);
      this.type = 'ShapeGeometry';
      if (Array.isArray(shapes) === false)
        shapes = [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
    THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
      for (var i = 0,
          l = shapes.length; i < l; i++) {
        this.addShape(shapes[i], options);
      }
      return this;
    };
    THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
      if (options === undefined)
        options = {};
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var material = options.material;
      var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
      var i,
          l,
          hole;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (i = 0, l = holes.length; i < l; i++) {
          hole = holes[i];
          if (THREE.ShapeUtils.isClockWise(hole)) {
            holes[i] = hole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.ShapeUtils.triangulateShape(vertices, holes);
      for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        vertices = vertices.concat(hole);
      }
      var vert,
          vlen = vertices.length;
      var face,
          flen = faces.length;
      for (i = 0; i < vlen; i++) {
        vert = vertices[i];
        this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        var a = face[0] + shapesOffset;
        var b = face[1] + shapesOffset;
        var c = face[2] + shapesOffset;
        this.faces.push(new THREE.Face3(a, b, c, null, null, material));
        this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
      }
    };
    THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
      THREE.Geometry.call(this);
      this.type = 'LatheGeometry';
      this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
      };
      segments = segments || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || 2 * Math.PI;
      var inversePointLength = 1.0 / (points.length - 1);
      var inverseSegments = 1.0 / segments;
      for (var i = 0,
          il = segments; i <= il; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var c = Math.cos(phi),
            s = Math.sin(phi);
        for (var j = 0,
            jl = points.length; j < jl; j++) {
          var pt = points[j];
          var vertex = new THREE.Vector3();
          vertex.x = c * pt.x - s * pt.y;
          vertex.y = s * pt.x + c * pt.y;
          vertex.z = pt.z;
          this.vertices.push(vertex);
        }
      }
      var np = points.length;
      for (var i = 0,
          il = segments; i < il; i++) {
        for (var j = 0,
            jl = points.length - 1; j < jl; j++) {
          var base = j + np * i;
          var a = base;
          var b = base + np;
          var c = base + 1 + np;
          var d = base + 1;
          var u0 = i * inverseSegments;
          var v0 = j * inversePointLength;
          var u1 = u0 + inverseSegments;
          var v1 = v0 + inversePointLength;
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1)]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1)]);
        }
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
      THREE.Geometry.call(this);
      this.type = 'PlaneGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
    THREE.PlaneGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.PlaneGeometry(parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments);
    };
    THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
      THREE.BufferGeometry.call(this);
      this.type = 'PlaneBufferGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = Math.floor(widthSegments) || 1;
      var gridY = Math.floor(heightSegments) || 1;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segment_width = width / gridX;
      var segment_height = height / gridY;
      var vertices = new Float32Array(gridX1 * gridY1 * 3);
      var normals = new Float32Array(gridX1 * gridY1 * 3);
      var uvs = new Float32Array(gridX1 * gridY1 * 2);
      var offset = 0;
      var offset2 = 0;
      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          vertices[offset] = x;
          vertices[offset + 1] = -y;
          normals[offset + 2] = 1;
          uvs[offset2] = ix / gridX;
          uvs[offset2 + 1] = 1 - (iy / gridY);
          offset += 3;
          offset2 += 2;
        }
      }
      offset = 0;
      var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
      for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = (ix + 1) + gridX1 * (iy + 1);
          var d = (ix + 1) + gridX1 * iy;
          indices[offset] = a;
          indices[offset + 1] = b;
          indices[offset + 2] = d;
          indices[offset + 3] = b;
          indices[offset + 4] = c;
          indices[offset + 5] = d;
          offset += 6;
        }
      }
      this.setIndex(new THREE.BufferAttribute(indices, 1));
      this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    };
    THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
    THREE.PlaneBufferGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.PlaneBufferGeometry(parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments);
    };
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'RingGeometry';
      this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      innerRadius = innerRadius || 0;
      outerRadius = outerRadius || 50;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
      phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;
      var i,
          o,
          uvs = [],
          radius = innerRadius,
          radiusStep = ((outerRadius - innerRadius) / phiSegments);
      for (i = 0; i < phiSegments + 1; i++) {
        for (o = 0; o < thetaSegments + 1; o++) {
          var vertex = new THREE.Vector3();
          var segment = thetaStart + o / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
        }
        radius += radiusStep;
      }
      var n = new THREE.Vector3(0, 0, 1);
      for (i = 0; i < phiSegments; i++) {
        var thetaSegment = i * (thetaSegments + 1);
        for (o = 0; o < thetaSegments; o++) {
          var segment = o + thetaSegment;
          var v1 = segment;
          var v2 = segment + thetaSegments + 1;
          var v3 = segment + thetaSegments + 2;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
          v1 = segment;
          v2 = segment + thetaSegments + 2;
          v3 = segment + 1;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
        }
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
    THREE.RingGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.RingGeometry(parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments, parameters.phiSegments, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'SphereGeometry';
      this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      this.fromBufferGeometry(new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
    THREE.SphereGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.SphereGeometry(parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.SphereBufferGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      THREE.BufferGeometry.call(this);
      this.type = 'SphereBufferGeometry';
      this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
      heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
      phiStart = phiStart !== undefined ? phiStart : 0;
      phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
      var thetaEnd = thetaStart + thetaLength;
      var vertexCount = ((widthSegments + 1) * (heightSegments + 1));
      var positions = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
      var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
      var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2);
      var index = 0,
          vertices = [],
          normal = new THREE.Vector3();
      for (var y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var v = y / heightSegments;
        for (var x = 0; x <= widthSegments; x++) {
          var u = x / widthSegments;
          var px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          var py = radius * Math.cos(thetaStart + v * thetaLength);
          var pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          normal.set(px, py, pz).normalize();
          positions.setXYZ(index, px, py, pz);
          normals.setXYZ(index, normal.x, normal.y, normal.z);
          uvs.setXY(index, u, 1 - v);
          verticesRow.push(index);
          index++;
        }
        vertices.push(verticesRow);
      }
      var indices = [];
      for (var y = 0; y < heightSegments; y++) {
        for (var x = 0; x < widthSegments; x++) {
          var v1 = vertices[y][x + 1];
          var v2 = vertices[y][x];
          var v3 = vertices[y + 1][x];
          var v4 = vertices[y + 1][x + 1];
          if (y !== 0 || thetaStart > 0)
            indices.push(v1, v2, v4);
          if (y !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(v2, v3, v4);
        }
      }
      this.setIndex(new (positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute)(indices, 1));
      this.addAttribute('position', positions);
      this.addAttribute('normal', normals);
      this.addAttribute('uv', uvs);
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
    THREE.SphereBufferGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.SphereBufferGeometry(parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength);
    };
    THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
      THREE.Geometry.call(this);
      this.type = 'TorusGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 8;
      tubularSegments = tubularSegments || 6;
      arc = arc || Math.PI * 2;
      var center = new THREE.Vector3(),
          uvs = [],
          normals = [];
      for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;
          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          var vertex = new THREE.Vector3();
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
          normals.push(vertex.clone().sub(center).normalize());
        }
      }
      for (var j = 1; j <= radialSegments; j++) {
        for (var i = 1; i <= tubularSegments; i++) {
          var a = (tubularSegments + 1) * j + i - 1;
          var b = (tubularSegments + 1) * (j - 1) + i - 1;
          var c = (tubularSegments + 1) * (j - 1) + i;
          var d = (tubularSegments + 1) * j + i;
          var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);
          face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
    THREE.TorusGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.TorusGeometry(parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.arc);
    };
    THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
      THREE.Geometry.call(this);
      this.type = 'TorusKnotGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 64;
      tubularSegments = tubularSegments || 8;
      p = p || 2;
      q = q || 3;
      heightScale = heightScale || 1;
      var grid = new Array(radialSegments);
      var tang = new THREE.Vector3();
      var n = new THREE.Vector3();
      var bitan = new THREE.Vector3();
      for (var i = 0; i < radialSegments; ++i) {
        grid[i] = new Array(tubularSegments);
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos(u, q, p, radius, heightScale);
        var p2 = getPos(u + 0.01, q, p, radius, heightScale);
        tang.subVectors(p2, p1);
        n.addVectors(p2, p1);
        bitan.crossVectors(tang, n);
        n.crossVectors(bitan, tang);
        bitan.normalize();
        n.normalize();
        for (var j = 0; j < tubularSegments; ++j) {
          var v = j / tubularSegments * 2 * Math.PI;
          var cx = -tube * Math.cos(v);
          var cy = tube * Math.sin(v);
          var pos = new THREE.Vector3();
          pos.x = p1.x + cx * n.x + cy * bitan.x;
          pos.y = p1.y + cx * n.y + cy * bitan.y;
          pos.z = p1.z + cx * n.z + cy * bitan.z;
          grid[i][j] = this.vertices.push(pos) - 1;
        }
      }
      for (var i = 0; i < radialSegments; ++i) {
        for (var j = 0; j < tubularSegments; ++j) {
          var ip = (i + 1) % radialSegments;
          var jp = (j + 1) % tubularSegments;
          var a = grid[i][j];
          var b = grid[ip][j];
          var c = grid[ip][jp];
          var d = grid[i][jp];
          var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);
          var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);
          var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);
          var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
      function getPos(u, in_q, in_p, radius, heightScale) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = in_q / in_p * u;
        var cs = Math.cos(quOverP);
        var tx = radius * (2 + cs) * 0.5 * cu;
        var ty = radius * (2 + cs) * su * 0.5;
        var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
        return new THREE.Vector3(tx, ty, tz);
      }
    };
    THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
    THREE.TorusKnotGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.TorusKnotGeometry(parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.p, parameters.q, parameters.heightScale);
    };
    THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
      THREE.Geometry.call(this);
      this.type = 'TubeGeometry';
      this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed,
        taper: taper
      };
      segments = segments || 64;
      radius = radius || 1;
      radialSegments = radialSegments || 8;
      closed = closed || false;
      taper = taper || THREE.TubeGeometry.NoTaper;
      var grid = [];
      var scope = this,
          tangent,
          normal,
          binormal,
          numpoints = segments + 1,
          u,
          v,
          r,
          cx,
          cy,
          pos,
          pos2 = new THREE.Vector3(),
          i,
          j,
          ip,
          jp,
          a,
          b,
          c,
          d,
          uva,
          uvb,
          uvc,
          uvd;
      var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),
          tangents = frames.tangents,
          normals = frames.normals,
          binormals = frames.binormals;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      function vert(x, y, z) {
        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
      }
      for (i = 0; i < numpoints; i++) {
        grid[i] = [];
        u = i / (numpoints - 1);
        pos = path.getPointAt(u);
        tangent = tangents[i];
        normal = normals[i];
        binormal = binormals[i];
        r = radius * taper(u);
        for (j = 0; j < radialSegments; j++) {
          v = j / radialSegments * 2 * Math.PI;
          cx = -r * Math.cos(v);
          cy = r * Math.sin(v);
          pos2.copy(pos);
          pos2.x += cx * normal.x + cy * binormal.x;
          pos2.y += cx * normal.y + cy * binormal.y;
          pos2.z += cx * normal.z + cy * binormal.z;
          grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
        }
      }
      for (i = 0; i < segments; i++) {
        for (j = 0; j < radialSegments; j++) {
          ip = (closed) ? (i + 1) % segments : i + 1;
          jp = (j + 1) % radialSegments;
          a = grid[i][j];
          b = grid[ip][j];
          c = grid[ip][jp];
          d = grid[i][jp];
          uva = new THREE.Vector2(i / segments, j / radialSegments);
          uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
          uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
          uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
    THREE.TubeGeometry.prototype.clone = function() {
      return new this.constructor(this.parameters.path, this.parameters.segments, this.parameters.radius, this.parameters.radialSegments, this.parameters.closed, this.parameters.taper);
    };
    THREE.TubeGeometry.NoTaper = function(u) {
      return 1;
    };
    THREE.TubeGeometry.SinusoidalTaper = function(u) {
      return Math.sin(Math.PI * u);
    };
    THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
      var normal = new THREE.Vector3(),
          tangents = [],
          normals = [],
          binormals = [],
          vec = new THREE.Vector3(),
          mat = new THREE.Matrix4(),
          numpoints = segments + 1,
          theta,
          smallest,
          tx,
          ty,
          tz,
          i,
          u;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      for (i = 0; i < numpoints; i++) {
        u = i / (numpoints - 1);
        tangents[i] = path.getTangentAt(u);
        tangents[i].normalize();
      }
      initialNormal3();
      function initialNormal3() {
        normals[0] = new THREE.Vector3();
        binormals[0] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs(tangents[0].x);
        ty = Math.abs(tangents[0].y);
        tz = Math.abs(tangents[0].z);
        if (tx <= smallest) {
          smallest = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= smallest) {
          smallest = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= smallest) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
      }
      for (i = 1; i < numpoints; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed) {
        theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
        theta /= (numpoints - 1);
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
          theta = -theta;
        }
        for (i = 1; i < numpoints; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
    };
    THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
      THREE.Geometry.call(this);
      this.type = 'PolyhedronGeometry';
      this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
      };
      radius = radius || 1;
      detail = detail || 0;
      var that = this;
      for (var i = 0,
          l = vertices.length; i < l; i += 3) {
        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
      }
      var p = this.vertices;
      var faces = [];
      for (var i = 0,
          j = 0,
          l = indices.length; i < l; i += 3, j++) {
        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];
        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, j);
      }
      var centroid = new THREE.Vector3();
      for (var i = 0,
          l = faces.length; i < l; i++) {
        subdivide(faces[i], detail);
      }
      for (var i = 0,
          l = this.faceVertexUvs[0].length; i < l; i++) {
        var uvs = this.faceVertexUvs[0][i];
        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvs[0].x += 1;
          if (x1 < 0.2)
            uvs[1].x += 1;
          if (x2 < 0.2)
            uvs[2].x += 1;
        }
      }
      for (var i = 0,
          l = this.vertices.length; i < l; i++) {
        this.vertices[i].multiplyScalar(radius);
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
      function prepare(vector) {
        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;
        var u = azimuth(vector) / 2 / Math.PI + 0.5;
        var v = inclination(vector) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2(u, 1 - v);
        return vertex;
      }
      function make(v1, v2, v3, materialIndex) {
        var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()], undefined, materialIndex);
        that.faces.push(face);
        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
        var azi = azimuth(centroid);
        that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)]);
      }
      function subdivide(face, detail) {
        var cols = Math.pow(2, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];
        var materialIndex = face.materialIndex;
        for (var i = 0; i <= cols; i++) {
          v[i] = [];
          var aj = prepare(a.clone().lerp(c, i / cols));
          var bj = prepare(b.clone().lerp(c, i / cols));
          var rows = cols - i;
          for (var j = 0; j <= rows; j++) {
            if (j === 0 && i === cols) {
              v[i][j] = aj;
            } else {
              v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
            }
          }
        }
        for (var i = 0; i < cols; i++) {
          for (var j = 0; j < 2 * (cols - i) - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 === 0) {
              make(v[i][k + 1], v[i + 1][k], v[i][k], materialIndex);
            } else {
              make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k], materialIndex);
            }
          }
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
      }
      function correctUV(uv, vector, azimuth) {
        if ((azimuth < 0) && (uv.x === 1))
          uv = new THREE.Vector2(uv.x - 1, uv.y);
        if ((vector.x === 0) && (vector.z === 0))
          uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
        return uv.clone();
      }
    };
    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
    THREE.PolyhedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.PolyhedronGeometry(parameters.vertices, parameters.indices, parameters.radius, parameters.detail);
    };
    THREE.DodecahedronGeometry = function(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var r = 1 / t;
      var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
      var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'DodecahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
    THREE.DodecahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.DodecahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.IcosahedronGeometry = function(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
      var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'IcosahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
    THREE.IcosahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.IcosahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.OctahedronGeometry = function(radius, detail) {
      var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
      var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'OctahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
    THREE.OctahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.OctahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.TetrahedronGeometry = function(radius, detail) {
      var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
      var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'TetrahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
    THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
    THREE.TetrahedronGeometry.prototype.clone = function() {
      var parameters = this.parameters;
      return new THREE.TetrahedronGeometry(parameters.radius, parameters.detail);
    };
    THREE.ParametricGeometry = function(func, slices, stacks) {
      THREE.Geometry.call(this);
      this.type = 'ParametricGeometry';
      this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
      };
      var verts = this.vertices;
      var faces = this.faces;
      var uvs = this.faceVertexUvs[0];
      var i,
          j,
          p;
      var u,
          v;
      var sliceCount = slices + 1;
      for (i = 0; i <= stacks; i++) {
        v = i / stacks;
        for (j = 0; j <= slices; j++) {
          u = j / slices;
          p = func(u, v);
          verts.push(p);
        }
      }
      var a,
          b,
          c,
          d;
      var uva,
          uvb,
          uvc,
          uvd;
      for (i = 0; i < stacks; i++) {
        for (j = 0; j < slices; j++) {
          a = i * sliceCount + j;
          b = i * sliceCount + j + 1;
          c = (i + 1) * sliceCount + j + 1;
          d = (i + 1) * sliceCount + j;
          uva = new THREE.Vector2(j / slices, i / stacks);
          uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
          uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
          uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
          faces.push(new THREE.Face3(a, b, d));
          uvs.push([uva, uvb, uvd]);
          faces.push(new THREE.Face3(b, c, d));
          uvs.push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
    THREE.WireframeGeometry = function(geometry) {
      THREE.BufferGeometry.call(this);
      var edge = [0, 0],
          hash = {};
      function sortFunction(a, b) {
        return a - b;
      }
      var keys = ['a', 'b', 'c'];
      if (geometry instanceof THREE.Geometry) {
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var numEdges = 0;
        var edges = new Uint32Array(6 * faces.length);
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            var key = edge.toString();
            if (hash[key] === undefined) {
              edges[2 * numEdges] = edge[0];
              edges[2 * numEdges + 1] = edge[1];
              hash[key] = true;
              numEdges++;
            }
          }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0,
            l = numEdges; i < l; i++) {
          for (var j = 0; j < 2; j++) {
            var vertex = vertices[edges[2 * i + j]];
            var index = 6 * i + 3 * j;
            coords[index + 0] = vertex.x;
            coords[index + 1] = vertex.y;
            coords[index + 2] = vertex.z;
          }
        }
        this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      } else if (geometry instanceof THREE.BufferGeometry) {
        if (geometry.index !== null) {
          var indices = geometry.index.array;
          var vertices = geometry.attributes.position;
          var drawcalls = geometry.drawcalls;
          var numEdges = 0;
          if (drawcalls.length === 0) {
            geometry.addGroup(0, indices.length);
          }
          var edges = new Uint32Array(2 * indices.length);
          for (var o = 0,
              ol = drawcalls.length; o < ol; ++o) {
            var drawcall = drawcalls[o];
            var start = drawcall.start;
            var count = drawcall.count;
            for (var i = start,
                il = start + count; i < il; i += 3) {
              for (var j = 0; j < 3; j++) {
                edge[0] = indices[i + j];
                edge[1] = indices[i + (j + 1) % 3];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                  edges[2 * numEdges] = edge[0];
                  edges[2 * numEdges + 1] = edge[1];
                  hash[key] = true;
                  numEdges++;
                }
              }
            }
          }
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
              var index = 6 * i + 3 * j;
              var index2 = edges[2 * i + j];
              coords[index + 0] = vertices.getX(index2);
              coords[index + 1] = vertices.getY(index2);
              coords[index + 2] = vertices.getZ(index2);
            }
          }
          this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        } else {
          var vertices = geometry.attributes.position.array;
          var numEdges = vertices.length / 3;
          var numTris = numEdges / 3;
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numTris; i < l; i++) {
            for (var j = 0; j < 3; j++) {
              var index = 18 * i + 6 * j;
              var index1 = 9 * i + 3 * j;
              coords[index + 0] = vertices[index1];
              coords[index + 1] = vertices[index1 + 1];
              coords[index + 2] = vertices[index1 + 2];
              var index2 = 9 * i + 3 * ((j + 1) % 3);
              coords[index + 3] = vertices[index2];
              coords[index + 4] = vertices[index2 + 1];
              coords[index + 5] = vertices[index2 + 2];
            }
          }
          this.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        }
      }
    };
    THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
    THREE.AxisHelper = function(size) {
      size = size || 1;
      var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size]);
      var colors = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      THREE.LineSegments.call(this, geometry, material);
    };
    THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
    THREE.ArrowHelper = (function() {
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
      var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
      coneGeometry.translate(0, -0.5, 0);
      return function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        THREE.Object3D.call(this);
        if (color === undefined)
          color = 0xffff00;
        if (length === undefined)
          length = 1;
        if (headLength === undefined)
          headLength = 0.2 * length;
        if (headWidth === undefined)
          headWidth = 0.2 * headLength;
        this.position.copy(origin);
        if (headLength < length) {
          this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({color: color}));
          this.line.matrixAutoUpdate = false;
          this.add(this.line);
        }
        this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color: color}));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
      };
    }());
    THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
    THREE.ArrowHelper.prototype.setDirection = (function() {
      var axis = new THREE.Vector3();
      var radians;
      return function setDirection(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          axis.set(dir.z, 0, -dir.x).normalize();
          radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(axis, radians);
        }
      };
    }());
    THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
      if (headLength === undefined)
        headLength = 0.2 * length;
      if (headWidth === undefined)
        headWidth = 0.2 * headLength;
      if (headLength < length) {
        this.line.scale.set(1, length - headLength, 1);
        this.line.updateMatrix();
      }
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    };
    THREE.ArrowHelper.prototype.setColor = function(color) {
      if (this.line !== undefined)
        this.line.material.color.set(color);
      this.cone.material.color.set(color);
    };
    THREE.BoxHelper = function(object) {
      var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      var positions = new Float32Array(8 * 3);
      var geometry = new THREE.BufferGeometry();
      geometry.setIndex(new THREE.BufferAttribute(indices, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
      THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({color: 0xffff00}));
      if (object !== undefined) {
        this.update(object);
      }
    };
    THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
    THREE.BoxHelper.prototype.update = (function() {
      var box = new THREE.Box3();
      return function(object) {
        box.setFromObject(object);
        if (box.empty())
          return;
        var min = box.min;
        var max = box.max;
        var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
      };
    })();
    THREE.BoundingBoxHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0x888888;
      this.object = object;
      this.box = new THREE.Box3();
      THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true
      }));
    };
    THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
    THREE.BoundingBoxHelper.prototype.update = function() {
      this.box.setFromObject(this.object);
      this.box.size(this.scale);
      this.box.center(this.position);
    };
    THREE.CameraHelper = function(camera) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        vertexColors: THREE.FaceColors
      });
      var pointMap = {};
      var hexFrustum = 0xffaa00;
      var hexCone = 0xff0000;
      var hexUp = 0x00aaff;
      var hexTarget = 0xffffff;
      var hexCross = 0x333333;
      addLine("n1", "n2", hexFrustum);
      addLine("n2", "n4", hexFrustum);
      addLine("n4", "n3", hexFrustum);
      addLine("n3", "n1", hexFrustum);
      addLine("f1", "f2", hexFrustum);
      addLine("f2", "f4", hexFrustum);
      addLine("f4", "f3", hexFrustum);
      addLine("f3", "f1", hexFrustum);
      addLine("n1", "f1", hexFrustum);
      addLine("n2", "f2", hexFrustum);
      addLine("n3", "f3", hexFrustum);
      addLine("n4", "f4", hexFrustum);
      addLine("p", "n1", hexCone);
      addLine("p", "n2", hexCone);
      addLine("p", "n3", hexCone);
      addLine("p", "n4", hexCone);
      addLine("u1", "u2", hexUp);
      addLine("u2", "u3", hexUp);
      addLine("u3", "u1", hexUp);
      addLine("c", "t", hexTarget);
      addLine("p", "c", hexCross);
      addLine("cn1", "cn2", hexCross);
      addLine("cn3", "cn4", hexCross);
      addLine("cf1", "cf2", hexCross);
      addLine("cf3", "cf4", hexCross);
      function addLine(a, b, hex) {
        addPoint(a, hex);
        addPoint(b, hex);
      }
      function addPoint(id, hex) {
        geometry.vertices.push(new THREE.Vector3());
        geometry.colors.push(new THREE.Color(hex));
        if (pointMap[id] === undefined) {
          pointMap[id] = [];
        }
        pointMap[id].push(geometry.vertices.length - 1);
      }
      THREE.LineSegments.call(this, geometry, material);
      this.camera = camera;
      this.camera.updateProjectionMatrix();
      this.matrix = camera.matrixWorld;
      this.matrixAutoUpdate = false;
      this.pointMap = pointMap;
      this.update();
    };
    THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
    THREE.CameraHelper.prototype.update = function() {
      var geometry,
          pointMap;
      var vector = new THREE.Vector3();
      var camera = new THREE.Camera();
      function setPoint(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
          for (var i = 0,
              il = points.length; i < il; i++) {
            geometry.vertices[points[i]].copy(vector);
          }
        }
      }
      return function() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1,
            h = 1;
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        setPoint("u1", w * 0.7, h * 1.1, -1);
        setPoint("u2", -w * 0.7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.verticesNeedUpdate = true;
      };
    }();
    THREE.DirectionalLightHelper = function(light, size) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      size = size || 1;
      var geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));
      var material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.lightPlane = new THREE.Line(geometry, material);
      this.add(this.lightPlane);
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
      material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.targetLine = new THREE.Line(geometry, material);
      this.add(this.targetLine);
      this.update();
    };
    THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
    THREE.DirectionalLightHelper.prototype.dispose = function() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    };
    THREE.DirectionalLightHelper.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var v3 = new THREE.Vector3();
      return function() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        this.lightPlane.lookAt(v3);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(v3);
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy(this.lightPlane.material.color);
      };
    }();
    THREE.EdgesHelper = function(object, hex, thresholdAngle) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      THREE.LineSegments.call(this, new THREE.EdgesGeometry(object.geometry, thresholdAngle), new THREE.LineBasicMaterial({color: color}));
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
    THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xffff00;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var nNormals = 0;
      var objGeometry = this.object.geometry;
      if (objGeometry instanceof THREE.Geometry) {
        nNormals = objGeometry.faces.length;
      } else {
        console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
      }
      var geometry = new THREE.BufferGeometry();
      var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
      geometry.addAttribute('position', positions);
      THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }));
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
    THREE.FaceNormalsHelper.prototype.update = (function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normalMatrix = new THREE.Matrix3();
      return function update() {
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        var objGeometry = this.object.geometry;
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          var normal = face.normal;
          v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
          v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
        position.needsUpdate = true;
        return this;
      };
    }());
    THREE.GridHelper = function(size, step) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      this.color1 = new THREE.Color(0x444444);
      this.color2 = new THREE.Color(0x888888);
      for (var i = -size; i <= size; i += step) {
        geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
        var color = i === 0 ? this.color1 : this.color2;
        geometry.colors.push(color, color, color, color);
      }
      THREE.LineSegments.call(this, geometry, material);
    };
    THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.GridHelper.prototype.constructor = THREE.GridHelper;
    THREE.GridHelper.prototype.setColors = function(colorCenterLine, colorGrid) {
      this.color1.set(colorCenterLine);
      this.color2.set(colorGrid);
      this.geometry.colorsNeedUpdate = true;
    };
    THREE.HemisphereLightHelper = function(light, sphereSize) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.colors = [new THREE.Color(), new THREE.Color()];
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      geometry.rotateX(-Math.PI / 2);
      for (var i = 0,
          il = 8; i < il; i++) {
        geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: true
      });
      this.lightSphere = new THREE.Mesh(geometry, material);
      this.add(this.lightSphere);
      this.update();
    };
    THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
    THREE.HemisphereLightHelper.prototype.dispose = function() {
      this.lightSphere.geometry.dispose();
      this.lightSphere.material.dispose();
    };
    THREE.HemisphereLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
      };
    }();
    THREE.PointLightHelper = function(light, sphereSize) {
      this.light = light;
      this.light.updateMatrixWorld();
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      THREE.Mesh.call(this, geometry, material);
      this.matrix = this.light.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
    THREE.PointLightHelper.prototype.dispose = function() {
      this.geometry.dispose();
      this.material.dispose();
    };
    THREE.PointLightHelper.prototype.update = function() {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
    THREE.SkeletonHelper = function(object) {
      this.bones = this.getBoneList(object);
      var geometry = new THREE.Geometry();
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          geometry.vertices.push(new THREE.Vector3());
          geometry.vertices.push(new THREE.Vector3());
          geometry.colors.push(new THREE.Color(0, 0, 1));
          geometry.colors.push(new THREE.Color(0, 1, 0));
        }
      }
      geometry.dynamic = true;
      var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      THREE.LineSegments.call(this, geometry, material);
      this.root = object;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
    THREE.SkeletonHelper.prototype.getBoneList = function(object) {
      var boneList = [];
      if (object instanceof THREE.Bone) {
        boneList.push(object);
      }
      for (var i = 0; i < object.children.length; i++) {
        boneList.push.apply(boneList, this.getBoneList(object.children[i]));
      }
      return boneList;
    };
    THREE.SkeletonHelper.prototype.update = function() {
      var geometry = this.geometry;
      var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
      var boneMatrix = new THREE.Matrix4();
      var j = 0;
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
          geometry.vertices[j].setFromMatrixPosition(boneMatrix);
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
          geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
          j += 2;
        }
      }
      geometry.verticesNeedUpdate = true;
      geometry.computeBoundingSphere();
    };
    THREE.SpotLightHelper = function(light) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
      geometry.translate(0, -0.5, 0);
      geometry.rotateX(-Math.PI / 2);
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      this.cone = new THREE.Mesh(geometry, material);
      this.add(this.cone);
      this.update();
    };
    THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
    THREE.SpotLightHelper.prototype.dispose = function() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    };
    THREE.SpotLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      var vector2 = new THREE.Vector3();
      return function() {
        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      };
    }();
    THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xff0000;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var nNormals = 0;
      var objGeometry = this.object.geometry;
      if (objGeometry instanceof THREE.Geometry) {
        nNormals = objGeometry.faces.length * 3;
      } else if (objGeometry instanceof THREE.BufferGeometry) {
        nNormals = objGeometry.attributes.normal.count;
      }
      var geometry = new THREE.BufferGeometry();
      var positions = new THREE.Float32Attribute(nNormals * 2 * 3, 3);
      geometry.addAttribute('position', positions);
      THREE.LineSegments.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }));
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
    THREE.VertexNormalsHelper.prototype.update = (function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var normalMatrix = new THREE.Matrix3();
      return function update() {
        var keys = ['a', 'b', 'c'];
        this.object.updateMatrixWorld(true);
        normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var matrixWorld = this.object.matrixWorld;
        var position = this.geometry.attributes.position;
        var objGeometry = this.object.geometry;
        if (objGeometry instanceof THREE.Geometry) {
          var vertices = objGeometry.vertices;
          var faces = objGeometry.faces;
          var idx = 0;
          for (var i = 0,
              l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0,
                jl = face.vertexNormals.length; j < jl; j++) {
              var vertex = vertices[face[keys[j]]];
              var normal = face.vertexNormals[j];
              v1.copy(vertex).applyMatrix4(matrixWorld);
              v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
              position.setXYZ(idx, v1.x, v1.y, v1.z);
              idx = idx + 1;
              position.setXYZ(idx, v2.x, v2.y, v2.z);
              idx = idx + 1;
            }
          }
        } else if (objGeometry instanceof THREE.BufferGeometry) {
          var objPos = objGeometry.attributes.position;
          var objNorm = objGeometry.attributes.normal;
          var idx = 0;
          for (var j = 0,
              jl = objPos.count; j < jl; j++) {
            v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
            v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
          }
        }
        position.needsUpdate = true;
        return this;
      };
    }());
    THREE.WireframeHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      THREE.LineSegments.call(this, new THREE.WireframeGeometry(object.geometry), new THREE.LineBasicMaterial({color: color}));
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);
    THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
    THREE.ImmediateRenderObject = function(material) {
      THREE.Object3D.call(this);
      this.material = material;
      this.render = function(renderCallback) {};
    };
    THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
    THREE.MorphBlendMesh = function(geometry, material) {
      THREE.Mesh.call(this, geometry, material);
      this.animationsMap = {};
      this.animationsList = [];
      var numFrames = this.geometry.morphTargets.length;
      var name = "__default";
      var startFrame = 0;
      var endFrame = numFrames - 1;
      var fps = numFrames / 1;
      this.createAnimation(name, startFrame, endFrame, fps);
      this.setAnimationWeight(name, 1);
    };
    THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
    THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
      var animation = {
        start: start,
        end: end,
        length: end - start + 1,
        fps: fps,
        duration: (end - start) / fps,
        lastFrame: 0,
        currentFrame: 0,
        active: false,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: false,
        mirroredLoop: false
      };
      this.animationsMap[name] = animation;
      this.animationsList.push(animation);
    };
    THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
      var pattern = /([a-z]+)_?(\d+)/;
      var firstAnimation,
          frameRanges = {};
      var geometry = this.geometry;
      for (var i = 0,
          il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var chunks = morph.name.match(pattern);
        if (chunks && chunks.length > 1) {
          var name = chunks[1];
          if (!frameRanges[name])
            frameRanges[name] = {
              start: Infinity,
              end: -Infinity
            };
          var range = frameRanges[name];
          if (i < range.start)
            range.start = i;
          if (i > range.end)
            range.end = i;
          if (!firstAnimation)
            firstAnimation = name;
        }
      }
      for (var name in frameRanges) {
        var range = frameRanges[name];
        this.createAnimation(name, range.start, range.end, fps);
      }
      this.firstAnimation = firstAnimation;
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = 1;
        animation.directionBackwards = false;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = -1;
        animation.directionBackwards = true;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.fps = fps;
        animation.duration = (animation.end - animation.start) / animation.fps;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.duration = duration;
        animation.fps = (animation.end - animation.start) / animation.duration;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.weight = weight;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = time;
      }
    };
    THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
      var time = 0;
      var animation = this.animationsMap[name];
      if (animation) {
        time = animation.time;
      }
      return time;
    };
    THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
      var duration = -1;
      var animation = this.animationsMap[name];
      if (animation) {
        duration = animation.duration;
      }
      return duration;
    };
    THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = 0;
        animation.active = true;
      } else {
        console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
      }
    };
    THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.active = false;
      }
    };
    THREE.MorphBlendMesh.prototype.update = function(delta) {
      for (var i = 0,
          il = this.animationsList.length; i < il; i++) {
        var animation = this.animationsList[i];
        if (!animation.active)
          continue;
        var frameTime = animation.duration / animation.length;
        animation.time += animation.direction * delta;
        if (animation.mirroredLoop) {
          if (animation.time > animation.duration || animation.time < 0) {
            animation.direction *= -1;
            if (animation.time > animation.duration) {
              animation.time = animation.duration;
              animation.directionBackwards = true;
            }
            if (animation.time < 0) {
              animation.time = 0;
              animation.directionBackwards = false;
            }
          }
        } else {
          animation.time = animation.time % animation.duration;
          if (animation.time < 0)
            animation.time += animation.duration;
        }
        var keyframe = animation.start + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
        var weight = animation.weight;
        if (keyframe !== animation.currentFrame) {
          this.morphTargetInfluences[animation.lastFrame] = 0;
          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
          this.morphTargetInfluences[keyframe] = 0;
          animation.lastFrame = animation.currentFrame;
          animation.currentFrame = keyframe;
        }
        var mix = (animation.time % frameTime) / frameTime;
        if (animation.directionBackwards)
          mix = 1 - mix;
        if (animation.currentFrame !== animation.lastFrame) {
          this.morphTargetInfluences[animation.currentFrame] = mix * weight;
          this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
        } else {
          this.morphTargetInfluences[animation.currentFrame] = weight;
        }
      }
    };
    this["THREE"] = THREE;
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("ef", ["123"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('123');
  global.define = __define;
  return module.exports;
});

$__System.register("10d", ["106", "f4", "f5", "f6", "f7", "10a", "ef"], function (_export) {
  var Signal, _get, _inherits, _createClass, _classCallCheck, _Map, THREE, pointers, Pointer;

  return {
    setters: [function (_) {
      Signal = _["default"];
    }, function (_f4) {
      _get = _f4["default"];
    }, function (_f5) {
      _inherits = _f5["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_a) {
      _Map = _a["default"];
    }, function (_ef) {
      THREE = _ef["default"];
    }],
    execute: function () {
      "use strict";

      pointers = new _Map();

      Pointer = (function (_THREE$Vector2) {
        _inherits(Pointer, _THREE$Vector2);

        _createClass(Pointer, [{
          key: "downed",
          get: function get() {
            return this._downed;
          }
        }], [{
          key: "get",
          value: function get(domElement) {
            var pointer = pointers.get(domElement);
            if (!pointer) {
              pointer = new Pointer(domElement);
            }
            return pointer;
          }
        }, {
          key: "TOUCH_TYPE",
          get: function get() {
            return "touchtype";
          }
        }, {
          key: "MOUSE_TYPE",
          get: function get() {
            return "mousetype";
          }
        }]);

        function Pointer() {
          var domElement = arguments.length <= 0 || arguments[0] === undefined ? document.body : arguments[0];

          _classCallCheck(this, Pointer);

          _get(Object.getPrototypeOf(Pointer.prototype), "constructor", this).call(this);

          this.domElement = domElement;

          this.type = Pointer.TOUCH_TYPE;

          this._position = new THREE.Vector2();

          this.velocity = new THREE.Vector2();
          this.dragOffset = new THREE.Vector2();

          this.centered = new THREE.Vector2();
          this.centeredFlippedY = new THREE.Vector2();
          this.normalized = new THREE.Vector2();
          this.normalizedFlippedY = new THREE.Vector2();
          this.normalizedCentered = new THREE.Vector2();
          this.normalizedCenteredFlippedY = new THREE.Vector2();

          this._downed = false;

          pointers.set(this.domElement, this);

          this.onDown = new Signal();
          this.onMove = new Signal();
          this.onUp = new Signal();
          this.onClick = new Signal();
          this.onTypeChange = new Signal();

          this._preventMouseTypeChange = false;

          this._onPointerMoveBinded = this._onPointerMove.bind(this);
          this._onPointerDownBinded = this._onPointerDown.bind(this);
          this._onPointerUpBinded = this._onPointerUp.bind(this);

          this._updateBinded = this._update.bind(this);
          this._resizeBinded = this.resize.bind(this);

          this.resize();
          this.enable();
        }

        _createClass(Pointer, [{
          key: "resize",
          value: function resize() {
            this._domElementBoundingRect = this.domElement.getBoundingClientRect();
          }
        }, {
          key: "_onPointerDown",
          value: function _onPointerDown(e) {
            if (e.type === "touchstart") {
              this._preventMouseTypeChange = true;
              this._changeType(Pointer.TOUCH_TYPE);
            }
            this._downed = true;
            this.dragOffset.set(0, 0);
            this.copy(this._position);
            this._onPointerEvent(e);
            this._updatePositions();
            this.onDown.dispatch();
          }
        }, {
          key: "_onPointerMove",
          value: function _onPointerMove(e) {
            if (e.type === "mousemove") {
              if (this._preventMouseTypeChange) {
                return;
              } else {
                this._changeType(Pointer.MOUSE_TYPE);
              }
            } else {
              e.preventDefault();
            }
            this._onPointerEvent(e);
            this.onMove.dispatch();
          }
        }, {
          key: "_onPointerUp",
          value: function _onPointerUp(e) {
            var _this = this;

            this._downed = false;
            this._onPointerEvent(e);
            this._updatePositions();
            this.onUp.dispatch();
            if (this.dragOffset.length < 4) {
              this.onClick.dispatch();
            }
            clearTimeout(this._timeout);
            this._timeout = setTimeout(function () {
              _this._preventMouseTypeChange = false;
            }, 2000);
          }
        }, {
          key: "_onPointerEvent",
          value: function _onPointerEvent(e) {
            if (!!window.TouchEvent && e instanceof window.TouchEvent) {
              if (e.type === "touchend") {
                e = e.changedTouches[0];
              } else {
                e = e.touches[0];
              }
            }
            this._position.x = e.clientX - this._domElementBoundingRect.left;
            this._position.y = e.clientY - this._domElementBoundingRect.top;
          }
        }, {
          key: "_changeType",
          value: function _changeType(type) {
            if (this.type === type) {
              return;
            }
            this.type = type;
            this.disable();
            this.enable();
            this.onTypeChange.dispatch(this.type);
          }
        }, {
          key: "_update",
          value: function _update() {
            this._requestAnimationFrameId = requestAnimationFrame(this._updateBinded);

            if (this.x || this.y) {
              this.velocity.x = this._position.x - this.x;
              this.velocity.y = this._position.y - this.y;
              if (this.downed) {
                this.dragOffset.add(this.velocity);
              }
            }

            this._updatePositions();
          }
        }, {
          key: "_updatePositions",
          value: function _updatePositions() {
            this.x = this._position.x;
            this.y = this._position.y;

            this.centered.x = this.centeredFlippedY.x = this.x - this._domElementBoundingRect.width * .5;
            this.centered.y = this.centeredFlippedY.y = this.y - this._domElementBoundingRect.height * .5;
            this.centeredFlippedY.y *= -1;

            this.normalized.x = this.normalizedFlippedY.x = this.x / this._domElementBoundingRect.width;
            this.normalized.y = this.normalizedFlippedY.y = this.y / this._domElementBoundingRect.height;
            this.normalizedFlippedY.y = 1 - this.normalizedFlippedY.y;

            this.normalizedCentered.x = this.normalizedCenteredFlippedY.x = this.normalized.x * 2 - 1;
            this.normalizedCentered.y = this.normalizedCenteredFlippedY.y = this.normalized.y * 2 - 1;
            this.normalizedCenteredFlippedY.y *= -1;
          }
        }, {
          key: "enable",
          value: function enable() {
            this.disable();
            this.resize();
            if (this.type === Pointer.TOUCH_TYPE) {
              this.domElement.addEventListener("touchmove", this._onPointerMoveBinded);
              window.addEventListener("touchend", this._onPointerUpBinded);
            } else {
              this.domElement.addEventListener("mousedown", this._onPointerDownBinded);
              window.addEventListener("mouseup", this._onPointerUpBinded);
            }
            this.domElement.addEventListener("touchstart", this._onPointerDownBinded);
            this.domElement.addEventListener("mousemove", this._onPointerMoveBinded);
            window.addEventListener("resize", this._resizeBinded);
            this._update();
          }
        }, {
          key: "disable",
          value: function disable() {
            cancelAnimationFrame(this._requestAnimationFrameId);
            this.domElement.removeEventListener("touchstart", this._onPointerDownBinded);
            this.domElement.removeEventListener("mousedown", this._onPointerDownBinded);
            this.domElement.removeEventListener("touchmove", this._onPointerMoveBinded);
            this.domElement.removeEventListener("mousemove", this._onPointerMoveBinded);
            window.removeEventListener("touchend", this._onPointerUpBinded);
            window.removeEventListener("mouseup", this._onPointerUpBinded);
            window.removeEventListener("resize", this._resizeBinded);
          }
        }]);

        return Pointer;
      })(THREE.Vector2);

      _export("default", Pointer);
    }
  };
});
$__System.registerDynamic("124", ["125", "e0", "126", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('125'),
      ITERATOR = $__require('e0')('iterator'),
      Iterators = $__require('126');
  module.exports = $__require('eb').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("127", ["128", "ea", "124"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('128');
  $__require('ea');
  module.exports = $__require('124');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("129", ["127"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('127'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fd", ["fb", "129"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _getIterator = $__require('fb')["default"];
  var _isIterable = $__require('129')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("117", ["e3", "eb", "12a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('e3'),
      core = $__require('eb'),
      fails = $__require('12a');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12b", ["e4", "117"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('e4');
  $__require('117')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12c", ["12b", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('12b');
  module.exports = $__require('eb').Object.keys;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("112", ["12c"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('12c'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12d", ["11f", "e8", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('11f'),
      get = $__require('e8');
  module.exports = $__require('eb').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12e", ["128", "ea", "12d"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('128');
  $__require('ea');
  module.exports = $__require('12d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("fb", ["12e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('12e'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e4", ["12f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('12f');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("130", ["119", "e4", "131", "12a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119'),
      toObject = $__require('e4'),
      IObject = $__require('131');
  module.exports = $__require('12a')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("132", ["e3", "130"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('e3');
  $export($export.S + $export.F, 'Object', {assign: $__require('130')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("133", ["132", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('132');
  module.exports = $__require('eb').Object.assign;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f8", ["133"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('133'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("134", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var MinSignal = (function(undef) {
    function MinSignal() {
      this._listeners = [];
    }
    var _p = MinSignal.prototype;
    _p.add = add;
    _p.addOnce = addOnce;
    _p.remove = remove;
    _p.dispatch = dispatch;
    var ERROR_MESSAGE_MISSING_CALLBACK = 'Callback function is missing!';
    var _slice = Array.prototype.slice;
    function _sort(list) {
      list.sort(function(a, b) {
        a = a.p;
        b = b.p;
        return b < a ? 1 : a > b ? -1 : 0;
      });
    }
    function add(fn, context, priority, args) {
      if (!fn) {
        throw ERROR_MESSAGE_MISSING_CALLBACK;
      }
      priority = priority || 0;
      var listeners = this._listeners;
      var listener,
          realFn,
          sliceIndex;
      var i = listeners.length;
      while (i--) {
        listener = listeners[i];
        if (listener.f === fn && listener.c === context) {
          return false;
        }
      }
      if (typeof priority === 'function') {
        realFn = priority;
        priority = args;
        sliceIndex = 4;
      }
      listeners.unshift({
        f: fn,
        c: context,
        p: priority,
        r: realFn || fn,
        a: _slice.call(arguments, sliceIndex || 3),
        j: 0
      });
      _sort(listeners);
    }
    function addOnce(fn, context, priority, args) {
      if (!fn) {
        throw ERROR_MESSAGE_MISSING_CALLBACK;
      }
      var self = this;
      var realFn = function() {
        self.remove.call(self, fn, context);
        return fn.apply(context, _slice.call(arguments, 0));
      };
      args = _slice.call(arguments, 0);
      if (args.length === 1) {
        args.push(undef);
      }
      args.splice(2, 0, realFn);
      add.apply(self, args);
    }
    function remove(fn, context) {
      if (!fn) {
        this._listeners.length = 0;
        return true;
      }
      var listeners = this._listeners;
      var listener;
      var i = listeners.length;
      while (i--) {
        listener = listeners[i];
        if (listener.f === fn && (!context || (listener.c === context))) {
          listener.j = 1;
          listeners.splice(i, 1);
          return true;
        }
      }
      return false;
    }
    function dispatch(args) {
      args = _slice.call(arguments, 0);
      var listeners = this._listeners;
      var listener,
          context,
          stoppedListener;
      var i = listeners.length;
      while (i--) {
        listener = listeners[i];
        if (listener && !listener.j) {
          listener.j = 1;
          if (listener.r.apply(listener.c, listener.a.concat(args)) === false) {
            stoppedListener = listener;
            break;
          }
        }
      }
      listeners = this._listeners;
      i = listeners.length;
      while (i--) {
        listeners[i].j = 0;
      }
      return stoppedListener;
    }
    if (typeof module !== 'undefined') {
      module.exports = MinSignal;
    }
  }());
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("106", ["134"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('134');
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(self) {
  var Stats = function(realTime) {
    if (this instanceof Stats) {
      return Stats.methods.initialize(realTime);
    } else {
      return new Stats(realTime);
    }
    ;
  };
  var PIXEL_RATIO = Math.floor(window.devicePixelRatio || 1);
  var SIZE = {
    WIDTH: 80 * PIXEL_RATIO,
    HEIGHT: 50 * PIXEL_RATIO,
    FRAMES: {
      WIDTH: 74 * PIXEL_RATIO,
      HEIGHT: 32 * PIXEL_RATIO,
      X: 3 * PIXEL_RATIO,
      Y: 15 * PIXEL_RATIO
    },
    TEXT: {
      HEIGHT: 8 * PIXEL_RATIO,
      X: 75 * PIXEL_RATIO,
      Y: 10 * PIXEL_RATIO
    }
  };
  var STYLE = {
    FPS: {
      DATAS: "#1AFFFF",
      FRAMES: "#1B314C",
      BACKGROUND: "#1A1A38"
    },
    MS: {
      DATAS: "#1AFF1A",
      FRAMES: "#1B4C1B",
      BACKGROUND: "#1A381A"
    },
    MB: {
      DATAS: "#FF1A94",
      FRAMES: "#4C1B34",
      BACKGROUND: "#381A29"
    },
    PING: {
      DATAS: "#FFFFFF",
      FRAMES: "#555555",
      BACKGROUND: "#222222"
    },
    CUSTOM: {
      DATAS: "#666",
      FRAMES: "#0F0F0F",
      BACKGROUND: "#242424"
    }
  };
  var MODES = {
    FPS: 0,
    MS: 1,
    MB: 2,
    PING: 3,
    CUSTOM: 4
  };
  var SUPPORT_MODE_MB = (window.performance != undefined && window.performance.memory != undefined && window.performance.memory.usedJSHeapSize != undefined ? true : false);
  Stats.methods = {
    initialize: function(realTime) {
      this.mode = MODES.FPS;
      this.realTime = (realTime || false);
      this.frameTime = 0;
      this.beginTime = 0;
      this.endTime = 0;
      this.isPinging = false;
      this.beginPinging = 0;
      this.endPinging = 0;
      this.fps = {
        value: 0,
        current: 0,
        min: Infinity,
        max: -Infinity,
        array: new Array(SIZE.FRAMES.WIDTH)
      };
      this.ms = {
        value: 0,
        current: 0,
        min: Infinity,
        max: -Infinity,
        array: new Array(SIZE.FRAMES.WIDTH)
      };
      this.mb = {
        value: 0,
        current: 0,
        min: Infinity,
        max: -Infinity,
        array: new Array(SIZE.FRAMES.WIDTH)
      };
      this.ping = {
        value: 0,
        current: 0,
        min: Infinity,
        max: -Infinity,
        array: new Array(SIZE.FRAMES.WIDTH)
      };
      this.customs = [];
      this.customIndex = 0;
      this.domElement = document.createElement("canvas");
      this.domElement.className = "statsjs";
      this.domElement.width = SIZE.WIDTH;
      this.domElement.height = SIZE.HEIGHT;
      this.domElement.style.width = (SIZE.WIDTH / PIXEL_RATIO) + "px";
      this.domElement.style.height = (SIZE.HEIGHT / PIXEL_RATIO) + "px";
      this.domElement.addEventListener("click", function(event) {
        this.switchMode();
      }.bind(this), false);
      this.context = this.domElement.getContext("2d");
      this.context.imageSmoothingEnabled = false;
      this.context.font = "bold " + SIZE.TEXT.HEIGHT + "px sans-serif";
      this.context.textAlign = "right";
      return this;
    },
    switchMode: function() {
      if (this.mode === MODES.FPS) {
        this.mode = MODES.MS;
      } else if (this.mode === MODES.MS) {
        if (SUPPORT_MODE_MB === true) {
          this.mode = MODES.MB;
        } else {
          this.mode = MODES.PING;
        }
        ;
      } else if (this.mode === MODES.MB) {
        this.mode = MODES.PING;
      } else if (this.mode === MODES.PING) {
        this.mode = (this.customs.length > 0) ? MODES.CUSTOM : MODES.FPS;
      } else if (this.mode === MODES.CUSTOM) {
        this.customIndex++;
        if (this.customIndex >= this.customs.length) {
          this.mode = MODES.FPS;
          this.customIndex = 0;
        }
      }
      this.draw();
    },
    begin: function() {
      this.beginTime = window.performance.now();
    },
    end: function() {
      var now = window.performance.now();
      var deltaTime = (now - this.frameTime);
      this.endTime = now;
      this.fps.current++;
      this.fps.max = Math.max(this.fps.current, this.fps.max);
      this.ms.current = (this.endTime - this.beginTime).toFixed(0);
      this.ms.min = Math.min(this.ms.current, this.ms.min);
      this.ms.max = Math.max(this.ms.current, this.ms.max);
      if (SUPPORT_MODE_MB === true) {
        this.mb.current = Math.round(window.performance.memory.usedJSHeapSize * 0.000000954);
        this.mb.min = Math.min(this.mb.current, this.mb.min);
        this.mb.max = Math.max(this.mb.current, this.mb.max);
      }
      ;
      for (var i = 0; i < this.customs.length; i++) {
        var custom = this.customs[i];
        custom.current = custom.object[custom.key];
        custom.value = custom.current;
        custom.min = Math.min(custom.current, custom.min);
        custom.max = Math.max(custom.current, custom.max);
        custom.array[custom.array.length - 1] = custom.value;
      }
      if (this.realTime === true) {
        this.fps.value = this.fps.current;
        this.fps.array[this.fps.array.length - 1] = this.fps.value;
      }
      ;
      if (deltaTime < 1000 && this.realTime === true) {
        this.draw();
      } else if (deltaTime >= 1000) {
        this.fps.min = Math.min(this.fps.current, this.fps.min);
        this.frameTime = now;
        this.fps.value = this.fps.current;
        this.ms.value = this.ms.current;
        this.mb.value = this.mb.current;
        this.ping.value = this.ping.current;
        for (var index = 0,
            length = SIZE.FRAMES.WIDTH; index < length; index++) {
          this.fps.array[index] = this.fps.array[index + 1];
          this.ms.array[index] = this.ms.array[index + 1];
          this.mb.array[index] = this.mb.array[index + 1];
          this.ping.array[index] = this.ping.array[index + 1];
        }
        ;
        for (var i = 0; i < this.customs.length; i++) {
          var custom = this.customs[i];
          for (var index = 0,
              length = SIZE.FRAMES.WIDTH; index < length; index++) {
            custom.array[index] = custom.array[index + 1];
          }
          custom.array[custom.array.length - 1] = custom.value;
        }
        this.fps.array[this.fps.array.length - 1] = this.fps.value;
        this.ms.array[this.ms.array.length - 1] = this.ms.value;
        this.mb.array[this.mb.array.length - 1] = this.mb.value;
        this.ping.array[this.ping.array.length - 1] = this.ping.value;
        this.draw();
        this.fps.current = 0;
      }
      ;
    },
    beginPing: function() {
      this.beginPinging = window.performance.now();
    },
    endPing: function() {
      this.endPinging = window.performance.now();
      this.ping.current = parseInt(this.endPinging - this.beginPinging);
      this.ping.min = Math.min(this.ping.current, this.ping.min);
      this.ping.max = Math.max(this.ping.current, this.ping.max);
    },
    addCustom: function(name, object, key) {
      this.customs.push({
        name: name,
        object: object,
        key: key,
        value: 0,
        current: 0,
        min: Infinity,
        max: -Infinity,
        array: new Array(SIZE.FRAMES.WIDTH)
      });
    },
    draw: function() {
      this.context.clearRect(0, 0, SIZE.WIDTH, SIZE.HEIGHT);
      if (this.mode === MODES.FPS) {
        this.context.fillStyle = STYLE.FPS.BACKGROUND;
        this.context.fillRect(0, 0, SIZE.WIDTH, SIZE.HEIGHT);
        this.context.fillStyle = STYLE.FPS.FRAMES;
        this.context.fillRect(SIZE.FRAMES.X, SIZE.FRAMES.Y, SIZE.FRAMES.WIDTH, SIZE.FRAMES.HEIGHT);
        this.context.fillStyle = STYLE.FPS.DATAS;
        var min = (this.fps.min === Infinity ? "∞" : this.fps.min);
        var max = (this.fps.max === -Infinity ? "∞" : this.fps.max);
        if (this.realTime === true) {
          this.context.fillText(this.fps.current + " FPS (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        } else {
          this.context.fillText(this.fps.value + " FPS (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        }
        ;
        for (var line = 0,
            length = this.fps.array.length; line < length; line++) {
          var height = (((this.fps.array[line] / this.fps.max) * SIZE.FRAMES.HEIGHT) || 0);
          var x = SIZE.FRAMES.X + line;
          var y = (SIZE.FRAMES.Y + SIZE.FRAMES.HEIGHT) - height;
          this.context.fillRect(x, y, 1, height);
        }
        ;
      } else if (this.mode === MODES.MS) {
        this.context.fillStyle = STYLE.MS.BACKGROUND;
        this.context.fillRect(0, 0, SIZE.WIDTH, SIZE.HEIGHT);
        this.context.fillStyle = STYLE.MS.FRAMES;
        this.context.fillRect(SIZE.FRAMES.X, SIZE.FRAMES.Y, SIZE.FRAMES.WIDTH, SIZE.FRAMES.HEIGHT);
        this.context.fillStyle = STYLE.MS.DATAS;
        var min = (this.ms.min === Infinity ? "∞" : this.ms.min);
        var max = (this.ms.max === -Infinity ? "∞" : this.ms.max);
        if (this.realTime === true) {
          this.context.fillText(this.ms.current + " MS (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        } else {
          this.context.fillText(this.ms.value + " MS (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        }
        ;
        for (var line = 0,
            length = this.ms.array.length; line < length; line++) {
          var height = (((this.ms.array[line] / this.ms.max) * SIZE.FRAMES.HEIGHT) || 0);
          var x = SIZE.FRAMES.X + line;
          var y = (SIZE.FRAMES.Y + SIZE.FRAMES.HEIGHT) - height;
          this.context.fillRect(x, y, 1, height);
        }
        ;
      } else if (this.mode === MODES.MB) {
        this.context.fillStyle = STYLE.MB.BACKGROUND;
        this.context.fillRect(0, 0, SIZE.WIDTH, SIZE.HEIGHT);
        this.context.fillStyle = STYLE.MB.FRAMES;
        this.context.fillRect(SIZE.FRAMES.X, SIZE.FRAMES.Y, SIZE.FRAMES.WIDTH, SIZE.FRAMES.HEIGHT);
        this.context.fillStyle = STYLE.MB.DATAS;
        var min = (this.mb.min === Infinity ? "∞" : this.mb.min);
        var max = (this.mb.max === -Infinity ? "∞" : this.mb.max);
        if (this.realTime === true) {
          this.context.fillText(this.mb.current + " MB (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        } else {
          this.context.fillText(this.mb.value + " MB (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        }
        ;
        for (var line = 0,
            length = this.mb.array.length; line < length; line++) {
          var height = (((this.mb.array[line] / this.mb.max) * SIZE.FRAMES.HEIGHT) || 0);
          var x = SIZE.FRAMES.X + line;
          var y = (SIZE.FRAMES.Y + SIZE.FRAMES.HEIGHT) - height;
          this.context.fillRect(x, y, 1, height);
        }
        ;
      } else if (this.mode === MODES.PING) {
        this.context.fillStyle = STYLE.PING.BACKGROUND;
        this.context.fillRect(0, 0, SIZE.WIDTH, SIZE.HEIGHT);
        this.context.fillStyle = STYLE.PING.FRAMES;
        this.context.fillRect(SIZE.FRAMES.X, SIZE.FRAMES.Y, SIZE.FRAMES.WIDTH, SIZE.FRAMES.HEIGHT);
        this.context.fillStyle = STYLE.PING.DATAS;
        var min = (this.ping.min === Infinity ? "∞" : this.ping.min);
        var max = (this.ping.max === -Infinity ? "∞" : this.ping.max);
        if (this.realTime === true) {
          this.context.fillText(this.ping.current + " PING (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        } else {
          this.context.fillText(this.ping.value + " PING (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
        }
        ;
        for (var line = 0,
            length = this.ping.array.length; line < length; line++) {
          var height = (((this.ping.array[line] / this.ping.max) * SIZE.FRAMES.HEIGHT) || 0);
          var x = SIZE.FRAMES.X + line;
          var y = (SIZE.FRAMES.Y + SIZE.FRAMES.HEIGHT) - height;
          this.context.fillRect(x, y, 1, height);
        }
        ;
      } else if (this.mode === MODES.CUSTOM) {
        this.context.fillStyle = STYLE.CUSTOM.BACKGROUND;
        this.context.fillRect(0, 0, SIZE.WIDTH, SIZE.HEIGHT);
        this.context.fillStyle = STYLE.CUSTOM.FRAMES;
        this.context.fillRect(SIZE.FRAMES.X, SIZE.FRAMES.Y, SIZE.FRAMES.WIDTH, SIZE.FRAMES.HEIGHT);
        this.context.fillStyle = STYLE.CUSTOM.DATAS;
        var custom = this.customs[this.customIndex];
        var min = (custom.min === Infinity ? "∞" : custom.min);
        var max = (custom.max === -Infinity ? "∞" : custom.max);
        for (var line = 0,
            length = custom.array.length; line < length; line++) {
          var height = (((custom.array[line] / custom.max) * SIZE.FRAMES.HEIGHT) || 0);
          var x = SIZE.FRAMES.X + line;
          var y = (SIZE.FRAMES.Y + SIZE.FRAMES.HEIGHT) - height;
          this.context.fillRect(x, y, 1, height);
        }
        ;
        this.context.fillStyle = "#DDDDDD";
        if (this.realTime === true) {
          if (min < -99 || max > 99) {
            this.context.fillText(custom.object[custom.key] + " " + custom.name, SIZE.TEXT.X, SIZE.TEXT.Y);
            this.context.fillText(min + " min", SIZE.TEXT.X, SIZE.TEXT.Y + 70);
            this.context.fillText(max + " max", SIZE.TEXT.X, SIZE.TEXT.Y + 28);
          } else {
            this.context.fillText(custom.object[custom.key] + " " + custom.name + " (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
          }
        } else {
          if (min < -99 || max > 99) {
            this.context.fillText(custom.value + " " + custom.name, SIZE.TEXT.X, SIZE.TEXT.Y);
            this.context.fillText(min + " min", SIZE.TEXT.X, SIZE.TEXT.Y + 70);
            this.context.fillText(max + " max", SIZE.TEXT.X, SIZE.TEXT.Y + 28);
          } else {
            this.context.fillText(custom.value + " " + custom.name + " (" + min + "-" + max + ")", SIZE.TEXT.X, SIZE.TEXT.Y);
          }
        }
        ;
      }
      ;
    }
  };
  Stats.methods.initialize.prototype = Stats.methods;
  if (typeof define !== "undefined" && define instanceof Function && define.amd !== undefined) {
    define("135", [], function() {
      return Stats;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = Stats;
  } else if (self != undefined) {
    self.Stats = Stats;
  }
  ;
})(this || {});

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("136", ["135"], function(main) {
  return main;
});

_removeDefine();
})();
$__System.register("fe", ["102", "106", "112", "136", "f6", "f7", "fd", "10a", "fb", "f8", "10e"], function (_export) {
  var DATA, Signal, _Object$keys, Stats, _createClass, _classCallCheck, _slicedToArray, _Map, _getIterator, _Object$assign, SoundManager, KEY_MAP, sceneNames, QWERTY_KEYCODES, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, i, keyCode, isSupported, App;

  return {
    setters: [function (_4) {
      DATA = _4["default"];
    }, function (_2) {
      Signal = _2["default"];
    }, function (_) {
      _Object$keys = _["default"];
    }, function (_3) {
      Stats = _3["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fd) {
      _slicedToArray = _fd["default"];
    }, function (_a) {
      _Map = _a["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_f8) {
      _Object$assign = _f8["default"];
    }, function (_e) {
      SoundManager = _e["default"];
    }],
    execute: function () {
      "use strict";

      KEY_MAP = new _Map();
      sceneNames = _Object$keys(DATA.scenes);

      sceneNames.splice(sceneNames.indexOf("default"), 1);

      QWERTY_KEYCODES = [81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 65, 83, 68, 70, 71, 72, 74, 75, 76, 90, 88, 67, 86, 66, 78, 77];
      _iteratorNormalCompletion = true;
      _didIteratorError = false;
      _iteratorError = undefined;

      try {

        for (_iterator = _getIterator(QWERTY_KEYCODES.entries()); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _step$value = _slicedToArray(_step.value, 2);
          i = _step$value[0];
          keyCode = _step$value[1];

          KEY_MAP.set(keyCode, sceneNames[i % sceneNames.length]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"]) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      isSupported = (function () {
        var isSupported = false;
        try {
          var canvas = document.createElement('canvas');
          isSupported = !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
        } catch (e) {
          return false;
        }
        return isSupported && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')).getExtension('OES_texture_float') !== null;
      })();

      App = (function () {
        function App() {
          _classCallCheck(this, App);

          this.data = DATA;
          this._timeoutID = -1;
          this._currentSceneName = "";
          this._preventSceneChange = false;

          this.isSupported = isSupported;

          if (/\bstats\b/.test(window.location.search)) {
            this.stats = new Stats();
            this.stats.domElement.style.position = "absolute";
            this.stats.domElement.style.top = 0;
            document.body.appendChild(this.stats.domElement);
          }

          this.onStart = new Signal();
          this.onStop = new Signal();
          this.onRestart = new Signal();
          this.onResize = new Signal();
          this.onSceneChange = new Signal();
        }

        _createClass(App, [{
          key: "_onKeyDown",
          value: function _onKeyDown(e) {
            var sceneName = KEY_MAP.get(e.keyCode);
            if (!sceneName || this._preventSceneChange) {
              return;
            }
            this._preventSceneChange = true;
            this.changeSceneByName(sceneName);
          }
        }, {
          key: "_onKeyUp",
          value: function _onKeyUp() {
            this._preventSceneChange = false;
          }
        }, {
          key: "start",
          value: function start() {
            SoundManager.muted = false;
            this.onStart.dispatch();
          }
        }, {
          key: "stop",
          value: function stop() {
            SoundManager.muted = true;
            this.onStop.dispatch();
          }
        }, {
          key: "restart",
          value: function restart() {
            this.changeSceneByName("default");
            this.onRestart.dispatch();
          }
        }, {
          key: "resize",
          value: function resize(width, height) {
            var lowQuality = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

            this.onResize.dispatch(width, height, lowQuality);
          }
        }, {
          key: "changeSceneByName",
          value: function changeSceneByName(name) {
            var _this = this;

            var data = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            clearTimeout(this._timeoutID);

            if (name !== "default") {
              this._timeoutID = setTimeout(function () {
                _this.changeSceneByName("default", {
                  transitionDuration: 10
                });
              }, 5000);
            }

            this._currentSceneName = name;

            this.onSceneChange.dispatch(name, _Object$assign(DATA.scenes[name], data));
          }
        }, {
          key: "interactive",
          set: function set(value) {
            this._interactive = value;
            if (value) {
              window.addEventListener("keydown", this._onKeyDownBinded = this._onKeyDown.bind(this));
              window.addEventListener("keyup", this._onKeyUpBinded = this._onKeyUp.bind(this));
            } else {
              window.removeEventListener("keydown", this._onKeyDownBinded);
              window.removeEventListener("keyup", this._onKeyUpBinded);
            }
          },
          get: function get() {
            return this._interactive;
          }
        }]);

        return App;
      })();

      _export("default", new App());
    }
  };
});
$__System.register("102", [], function (_export) {
  "use strict";

  return {
    setters: [],
    execute: function () {
      _export("default", {
        assets: {
          sounds: ["sounds/Drone_02.mp3", "sounds/Day_01.mp3", "sounds/Day_02.mp3", "sounds/Day_03.mp3", "sounds/Day_04.mp3", "sounds/Day_05.mp3", "sounds/Day_06.mp3", "sounds/Night_01.mp3", "sounds/Night_02.mp3", "sounds/Night_03.mp3", "sounds/Night_04.mp3", "sounds/Night_05.mp3", "sounds/Night_06.mp3"]
        },
        scenes: {
          "default": {
            background: {
              main: 0x000000,
              assets: [0x202020],
              detail: {
                colors: [0x313131],
                opacities: [1],
                scale: [10, 10],
                numberRatio: .2
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0x9e9292,
              crossTip: true,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: .4
            }]
          },
          "front-bumper": {
            sound: "Day_02",

            background: {
              main: 0xc7c1c1,
              assets: [0x7b7d80, 0xbdb7b7],
              detail: {
                colors: [0xffa770],
                opacities: [1],
                scale: [10, .3],
                numberRatio: 1
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xffd400,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [1, -2, 2],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0x565656,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 2, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0x8c8c8c,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-0, -0, 100],
              radius: .1
            }, {
              tipColor: 0xFFFFFF,
              color: 0xFFFFFF,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-200, -0, 0],
              radius: .2
            }]
          },
          "rear-bumper": {
            sound: "Day_01",
            tunnel: {
              color: 0xfffada
            },
            background: {
              main: 0xf2f1ee,
              assets: [0xd3c5c1, 0x6e695f],
              detail: {
                colors: [0xfffada],
                opacities: [1],
                scale: [15, 15],
                numberRatio: .1
              }
            },
            lines: [{
              tipColor: 0xfffbe1,
              color: 0xf4f1dc,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: .4
            }, {
              tipColor: 0xfffbe1,
              color: 0xf4f1dc,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [1, -1, -1],
              radius: 1
            }, {
              tipColor: 0xfffbe1,
              color: 0xf6f4ef,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-1, 1, -2],
              radius: 1
            }, {
              tipColor: 0xfffbe1,
              color: 0xf4f1dc,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-20, 20, 0],
              radius: .1
            }]
          },
          "headlight-front": {
            sound: "Night_01",
            tunnel: {
              color: 0xa898ef
            },
            background: {
              main: 0x210044,
              assets: [0x2c0024, 0x2b0128, 0x210044, 0x000000],
              detail: {
                colors: [0xa898ef, 0xc598ef, 0xdc98ef, 0xef98e0, 0xef98c4],
                opacities: [.6, .25, .33, .1],
                scale: [2, 2],
                numberRatio: 1
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xa898ef,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xc598ef,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [10, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xdc98ef,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 60, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xef98e0,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [-10, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xef98c4,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [-0, 0, 0],
              radius: .3
            }]
          },
          "mirror": {
            sound: "Night_02",
            tunnel: {
              color: 0xffd2f1
            },
            background: {
              main: 0x7500ff,
              assets: [0xff4ea8, 0x7500ff],
              detail: {
                colors: [0xcb72df],
                opacities: [.6],
                scale: [30, 20],
                numberRatio: .4
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xffd2f1,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-10, 10, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0xffd2f1,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0xffd2f1,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [10, -10, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0xffd2f1,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-10, -20, 0],
              radius: 1
            }]
          },
          "chassis": {
            sound: "Night_03",
            tunnel: {
              color: 0x000e79
            },
            background: {
              main: 0x090018,
              assets: [0x410337, 0x000e79],
              detail: {
                colors: [0x1f0033],
                opacities: [1],
                scale: [10, 10],
                numberRatio: 0
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [6, -1, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [12, -5, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-12, -5, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [-6, -1, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xffecff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: .1
            }]
          },
          "door": {
            sound: "Day_03",
            tunnel: {
              color: 0xa39e9d
            },
            background: {
              main: 0xd6d6d6,
              assets: [0xfffbed, 0xf4f2ec],
              detail: {
                colors: [0xa39e9d],
                opacities: [.2],
                scale: [15, 15],
                numberRatio: .3
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xf7ece6,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: 2
            }, {
              tipColor: 0xffc4be,
              color: 0xff4835,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [-2, 2, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0xddc8c4,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xe8e5e5,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: .1
            }]
          },
          "roof": {
            sound: "Day_04",
            tunnel: {
              color: 0x101010
            },
            background: {
              main: 0xffffff,
              assets: [0xf4f2ec, 0xededed],
              detail: {
                colors: [0xffffff],
                opacities: [1],
                scale: [10, 10],
                numberRatio: 0
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xefece2,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 1.5
            }, {
              tipColor: 0xffffff,
              color: 0xffffff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [1, -1, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0xfff9e7,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [8, -15, 0],
              radius: .2
            }, {
              tipColor: 0xffffff,
              color: 0xc6c6c6,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [10, -25, 0],
              radius: .2
            }]
          },
          "headlight-rear": {
            sound: "Night_04",
            tunnel: {
              color: 0xffffff
            },

            background: {
              main: 0x000760,
              assets: [0x000000, 0x000000],
              detail: {
                colors: [0x000874],
                opacities: [1],
                scale: [50, 50],
                numberRatio: .5
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0xc0c0c0,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: .8
            }, {
              tipColor: 0xffffff,
              color: 0xc0c0c0,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [4, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xc0c0c0,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [200, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xc0c0c0,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [-1000, 0, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0xc0c0c0,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [-200, 0, 0],
              radius: .1
            }]
          },
          "gearshift": {
            sound: "Day_05",
            tunnel: {
              color: 0xede8e0
            },
            background: {
              main: 0xf4f0e7,
              assets: [0xddd5c9, 0xe3ddcc],
              detail: {
                colors: [0xede8e0],
                opacities: [1],
                scale: [20, 3],
                numberRatio: .3
              }
            },
            lines: [{
              tipColor: 0xccd1ff,
              color: 0x0014a8,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [3, 2, 0],
              radius: .5
            }, {
              tipColor: 0xf4f0e7,
              color: 0xffffff,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: 1
            }, {
              tipColor: 0xf4f0e7,
              color: 0x000000,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [2, -1, 0],
              radius: .1
            }, {
              tipColor: 0xf4f0e7,
              color: 0x000000,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [2, 1, 0],
              radius: .1
            }, {
              tipColor: 0xf4f0e7,
              color: 0x000000,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }, {
              tipColor: 0xf4f0e7,
              color: 0x000000,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }]
          },
          "suspension": {
            sound: "Day_06",
            tunnel: {
              color: 0x004539
            },

            background: {
              main: 0x000000,
              assets: [0x00062e, 0x006254],
              detail: {
                colors: [0x004539],
                opacities: [1, .5, .2],
                scale: [20, 12],
                numberRatio: .4
              }
            },
            lines: [{
              tipColor: 0xffffff,
              color: 0x00fff6,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [3, 2, 0],
              radius: .5
            }, {
              tipColor: 0xffffff,
              color: 0x000000,
              crossTip: false,
              style: "square",
              shading: true,
              offset: [0, 0, 0],
              radius: 1
            }, {
              tipColor: 0xffffff,
              color: 0x0050fe,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [2, -1, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0x0050fe,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [2, 1, 0],
              radius: .1
            }, {
              tipColor: 0xffffff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }, {
              tipColor: 0xffffff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }]
          },
          "wheel": {
            sound: "Night_05",
            tunnel: {
              color: 0xece4e2
            },

            background: {
              main: 0xeae2ce,
              assets: [0x70c6a3, 0xf9b7b9],
              detail: {
                colors: [0xece4e2],
                opacities: [1],
                scale: [15, 8],
                numberRatio: .6
              }
            },
            lines: [{
              tipColor: 0x9691ff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 1
            }, {
              tipColor: 0x9691ff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [60, 0, 0],
              radius: 0.2
            }, {
              tipColor: 0x9691ff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0.0
            }, {
              tipColor: 0x9691ff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0.0
            }, {
              tipColor: 0x9691ff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }, {
              tipColor: 0x9691ff,
              color: 0x5a53a3,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }]
          },
          "logo": {
            sound: "Night_06",
            tunnel: {
              color: 0x006865
            },

            background: {
              main: 0x00111a,
              assets: [0x000d5e, 0x006865],
              detail: {
                colors: [0x000d5e],
                opacities: [.8],
                scale: [6, 3],
                numberRatio: .7
              }
            },
            lines: [{
              tipColor: 0xffccc5,
              color: 0xff0048,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 1
            }, {
              tipColor: 0xffccc5,
              color: 0xff0048,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [6, 6, 0],
              radius: .2
            }, {
              tipColor: 0xffccc5,
              color: 0xff0048,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [9, -4, 0],
              radius: .1
            }, {
              tipColor: 0xffccc5,
              color: 0xff0048,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [11, 3, 0],
              radius: .1
            }, {
              tipColor: 0xffccc5,
              color: 0xff0048,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }, {
              tipColor: 0xffccc5,
              color: 0xff0048,
              crossTip: false,
              style: "square",
              shading: false,
              offset: [0, 0, 0],
              radius: 0
            }]
          }
        }
      });
    }
  };
});
$__System.registerDynamic("137", ["119"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("138", ["137"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('137'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f6", ["138"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('138')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f7", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("139", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13a", ["13b", "12f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('13b'),
      defined = $__require('12f');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ea", ["13a", "13c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('13a')(true);
  $__require('13c')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13d", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("131", ["13e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('13e');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("116", ["131", "12f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('131'),
      defined = $__require('12f');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13f", ["13d", "140", "126", "116", "13c"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('13d'),
      step = $__require('140'),
      Iterators = $__require('126'),
      toIObject = $__require('116');
  module.exports = $__require('13c')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("128", ["13f", "126"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('13f');
  var Iterators = $__require('126');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12f", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("141", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("142", ["119", "143", "144", "145", "e0"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119'),
      descriptor = $__require('143'),
      setToStringTag = $__require('144'),
      IteratorPrototype = {};
  $__require('145')(IteratorPrototype, $__require('e0')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13c", ["141", "e3", "146", "145", "147", "126", "142", "144", "119", "e0"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('141'),
      $export = $__require('e3'),
      redefine = $__require('146'),
      hide = $__require('145'),
      has = $__require('147'),
      Iterators = $__require('126'),
      $iterCreate = $__require('142'),
      setToStringTag = $__require('144'),
      getProto = $__require('119').getProto,
      ITERATOR = $__require('e0')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("140", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("148", ["eb", "119", "149", "e0"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = $__require('eb'),
      $ = $__require('119'),
      DESCRIPTORS = $__require('149'),
      SPECIES = $__require('e0')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14a", ["119", "145", "14b", "e2", "14c", "12f", "14d", "13c", "140", "14e", "147", "11e", "148", "149"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119'),
      hide = $__require('145'),
      redefineAll = $__require('14b'),
      ctx = $__require('e2'),
      strictNew = $__require('14c'),
      defined = $__require('12f'),
      forOf = $__require('14d'),
      $iterDefine = $__require('13c'),
      step = $__require('140'),
      ID = $__require('14e')('id'),
      $has = $__require('147'),
      isObject = $__require('11e'),
      setSpecies = $__require('148'),
      DESCRIPTORS = $__require('149'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("143", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("145", ["119", "143", "149"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119'),
      createDesc = $__require('143');
  module.exports = $__require('149') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("146", ["145"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('145');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14b", ["146"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = $__require('146');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14c", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("119", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("147", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("144", ["119", "147", "e0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('119').setDesc,
      has = $__require('147'),
      TAG = $__require('e0')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12a", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("149", ["12a"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('12a')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14f", ["119", "150", "e3", "12a", "145", "14b", "14d", "14c", "11e", "144", "149"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('119'),
      global = $__require('150'),
      $export = $__require('e3'),
      fails = $__require('12a'),
      hide = $__require('145'),
      redefineAll = $__require('14b'),
      forOf = $__require('14d'),
      strictNew = $__require('14c'),
      isObject = $__require('11e'),
      setToStringTag = $__require('144'),
      DESCRIPTORS = $__require('149');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function(target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function(KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
          hide(C.prototype, KEY, function(a, b) {
            if (!IS_ADDER && IS_WEAK && !isObject(a))
              return KEY == 'get' ? undefined : false;
            var result = this._c[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
      });
      if ('size' in proto)
        $.setDesc(C.prototype, 'size', {get: function() {
            return this._c.size;
          }});
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("151", ["14a", "14f"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var strong = $__require('14a');
  $__require('14f')('Map', function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e3", ["150", "eb", "e2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('150'),
      core = $__require('eb'),
      ctx = $__require('e2'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("152", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e2", ["152"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('152');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e5", ["11f"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('11f');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e6", ["126", "e0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('126'),
      ITERATOR = $__require('e0')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11f", ["11e"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('11e');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13b", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e7", ["13b"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('13b'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("126", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e8", ["125", "e0", "126", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('125'),
      ITERATOR = $__require('e0')('iterator'),
      Iterators = $__require('126');
  module.exports = $__require('eb').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14d", ["e2", "e5", "e6", "11f", "e7", "e8"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('e2'),
      call = $__require('e5'),
      isArrayIter = $__require('e6'),
      anObject = $__require('11f'),
      toLength = $__require('e7'),
      getIterFn = $__require('e8');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("153", ["150"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('150'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14e", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("150", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e0", ["153", "14e", "150"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('153')('wks'),
      uid = $__require('14e'),
      Symbol = $__require('150').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("125", ["13e", "e0"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('13e'),
      TAG = $__require('e0')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("154", ["14d", "125"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forOf = $__require('14d'),
      classof = $__require('125');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("155", ["e3", "154"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('e3');
  $export($export.P, 'Map', {toJSON: $__require('154')('Map')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("eb", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("156", ["139", "ea", "128", "151", "155", "eb"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('139');
  $__require('ea');
  $__require('128');
  $__require('151');
  $__require('155');
  module.exports = $__require('eb').Map;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10a", ["156"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('156'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register("10e", ["f6", "f7", "10a"], function (_export) {
  var _createClass, _classCallCheck, _Map, soundMap, muteLooped, enabled, muted, SoundManager;

  return {
    setters: [function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_a) {
      _Map = _a["default"];
    }],
    execute: function () {
      //import {Howler, Howl} from "howler";

      "use strict";

      soundMap = new _Map();
      muteLooped = /\bmutelooped\b/.test(window.location.search);
      enabled = true;
      muted = false;

      SoundManager = (function () {
        function SoundManager() {
          _classCallCheck(this, SoundManager);
        }

        _createClass(SoundManager, null, [{
          key: "add",
          value: function add(url) {
            var split = url.split("/");
            var name = split[split.length - 1].split(".")[0];
            if (soundMap.get(name)) {
              console.warn("Sound " + name + " is added twice");
              return;
            }
            var sound = new Howl({
              urls: [url]
            });
            soundMap.set(name, sound);
          }
        }, {
          key: "remove",
          value: function remove(key) {
            if (key === undefined) soundMap.forEach(function (v, k) {
              return SoundManager.remove(k);
            });else {
              soundMap.get(key).unload();
              soundMap["delete"](key);
            }
          }
        }, {
          key: "play",
          value: function play(name) {
            var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var _ref$loop = _ref.loop;
            var loop = _ref$loop === undefined ? false : _ref$loop;
            var _ref$volume = _ref.volume;
            var volume = _ref$volume === undefined ? 1 : _ref$volume;

            var sound = soundMap.get(name);
            if (!sound) {
              console.error("Sound " + name + " hasn't been added");
              return;
            }

            sound.loop(loop);
            sound.volume(volume || sound.volume);

            if (sound.loop() && muteLooped) {
              sound.mute();
            }
            sound.play();
          }
        }, {
          key: "stop",
          value: function stop(name) {
            var sound = soundMap.get(name);
            sound.stop();
          }
        }, {
          key: "muted",
          set: function set(value) {
            if (value) {
              muted = true;
              soundMap.forEach(function (sound) {
                return sound.mute();
              });
            } else {
              if (!enabled) {
                return;
              }
              muted = false;
              soundMap.forEach(function (sound) {
                return sound.unmute();
              });
            }
          },
          get: function get() {
            return muted;
          }
        }]);

        return SoundManager;
      })();

      _export("default", SoundManager);

      if (/\bmute\b/.test(window.location.search)) {
        enabled = false;
        Howler.mute();
      }
    }
  };
});
$__System.registerDynamic("157", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(define, undefined) {
    define(function() {
      'use strict';
      var impl = {};
      impl.mobileDetectRules = {
        "phones": {
          "iPhone": "\\biPhone\\b|\\biPod\\b",
          "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+",
          "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m",
          "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
          "Dell": "Dell.*Streak|Dell.*Aero|Dell.*Venue|DELL.*Venue Pro|Dell Flash|Dell Smoke|Dell Mini 3iX|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
          "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b",
          "Samsung": "Samsung|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205",
          "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323)",
          "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
          "Asus": "Asus.*Galaxy|PadFone.*Mobile",
          "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
          "Palm": "PalmSource|Palm",
          "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
          "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
          "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
          "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
          "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
          "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
          "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
          "Alcatel": "Alcatel",
          "Nintendo": "Nintendo 3DS",
          "Amoi": "Amoi",
          "INQ": "INQ",
          "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
        },
        "tablets": {
          "iPad": "iPad|iPad.*Mobile",
          "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
          "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715",
          "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI)\\b",
          "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
          "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
          "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K017 |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C",
          "BlackBerryTablet": "PlayBook|RIM Tablet",
          "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
          "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
          "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
          "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b",
          "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
          "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
          "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
          "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
          "LenovoTablet": "Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)",
          "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
          "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
          "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
          "ArnovaTablet": "AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
          "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
          "IRUTablet": "M702pro",
          "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
          "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
          "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
          "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
          "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
          "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP612|SOT31",
          "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
          "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
          "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
          "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733",
          "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
          "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
          "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
          "FlyTablet": "IQ310|Fly Vision",
          "bqTablet": "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris E10)|Maxwell.*Lite|Maxwell.*Plus",
          "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim",
          "NecTablet": "\\bN-06D|\\bN-08D",
          "PantechTablet": "Pantech.*P4100",
          "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
          "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
          "ZyncTablet": "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900",
          "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
          "NabiTablet": "Android.*\\bNabi",
          "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
          "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
          "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
          "PlaystationTablet": "Playstation.*(Portable|Vita)",
          "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
          "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
          "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
          "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
          "GalapadTablet": "Android.*\\bG1\\b",
          "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
          "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
          "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
          "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
          "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
          "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
          "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
          "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
          "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)",
          "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
          "DPSTablet": "DPS Dream 9|DPS Dual 7",
          "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
          "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
          "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
          "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
          "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
          "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
          "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
          "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
          "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
          "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7",
          "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
          "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
          "iMobileTablet": "i-mobile i-note",
          "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
          "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
          "AMPETablet": "Android.* A78 ",
          "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
          "TecnoTablet": "TECNO P9",
          "JXDTablet": "Android.*\\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
          "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
          "FX2Tablet": "FX2 PAD7|FX2 PAD10",
          "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
          "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
          "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
          "CaptivaTablet": "CAPTIVA PAD",
          "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
          "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
          "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+",
          "JaytechTablet": "TPC-PA762",
          "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
          "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
          "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
          "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
          "AocTablet": "MW0811|MW0812|MW0922|MTK8382",
          "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
          "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
          "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
          "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
          "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
          "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
          "UbislateTablet": "UbiSlate[\\s]?7C",
          "PocketBookTablet": "Pocketbook",
          "Hudl": "Hudl HT7S3|Hudl 2",
          "TelstraTablet": "T-Hub2",
          "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bJolla\\b|\\bTP750\\b"
        },
        "oss": {
          "AndroidOS": "Android",
          "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
          "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
          "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
          "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;",
          "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
          "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad",
          "MeeGoOS": "MeeGo",
          "MaemoOS": "Maemo",
          "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
          "webOS": "webOS|hpwOS",
          "badaOS": "\\bBada\\b",
          "BREWOS": "BREW"
        },
        "uas": {
          "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
          "Dolfin": "\\bDolfin\\b",
          "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+|Coast\/[0-9.]+",
          "Skyfire": "Skyfire",
          "IE": "IEMobile|MSIEMobile",
          "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile",
          "Bolt": "bolt",
          "TeaShark": "teashark",
          "Blazer": "Blazer",
          "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
          "Tizen": "Tizen",
          "UCBrowser": "UC.*Browser|UCWEB",
          "baiduboxapp": "baiduboxapp",
          "baidubrowser": "baidubrowser",
          "DiigoBrowser": "DiigoBrowser",
          "Puffin": "Puffin",
          "Mercury": "\\bMercury\\b",
          "ObigoBrowser": "Obigo",
          "NetFront": "NF-Browser",
          "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger"
        },
        "props": {
          "Mobile": "Mobile\/[VER]",
          "Build": "Build\/[VER]",
          "Version": "Version\/[VER]",
          "VendorID": "VendorID\/[VER]",
          "iPad": "iPad.*CPU[a-z ]+[VER]",
          "iPhone": "iPhone.*CPU[a-z ]+[VER]",
          "iPod": "iPod.*CPU[a-z ]+[VER]",
          "Kindle": "Kindle\/[VER]",
          "Chrome": ["Chrome\/[VER]", "CriOS\/[VER]", "CrMo\/[VER]"],
          "Coast": ["Coast\/[VER]"],
          "Dolfin": "Dolfin\/[VER]",
          "Firefox": "Firefox\/[VER]",
          "Fennec": "Fennec\/[VER]",
          "IE": ["IEMobile\/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident\/[0-9.]+;.*rv:[VER]"],
          "NetFront": "NetFront\/[VER]",
          "NokiaBrowser": "NokiaBrowser\/[VER]",
          "Opera": [" OPR\/[VER]", "Opera Mini\/[VER]", "Version\/[VER]"],
          "Opera Mini": "Opera Mini\/[VER]",
          "Opera Mobi": "Version\/[VER]",
          "UC Browser": "UC Browser[VER]",
          "MQQBrowser": "MQQBrowser\/[VER]",
          "MicroMessenger": "MicroMessenger\/[VER]",
          "baiduboxapp": "baiduboxapp\/[VER]",
          "baidubrowser": "baidubrowser\/[VER]",
          "Iron": "Iron\/[VER]",
          "Safari": ["Version\/[VER]", "Safari\/[VER]"],
          "Skyfire": "Skyfire\/[VER]",
          "Tizen": "Tizen\/[VER]",
          "Webkit": "webkit[ \/][VER]",
          "Gecko": "Gecko\/[VER]",
          "Trident": "Trident\/[VER]",
          "Presto": "Presto\/[VER]",
          "iOS": " \\bi?OS\\b [VER][ ;]{1}",
          "Android": "Android [VER]",
          "BlackBerry": ["BlackBerry[\\w]+\/[VER]", "BlackBerry.*Version\/[VER]", "Version\/[VER]"],
          "BREW": "BREW [VER]",
          "Java": "Java\/[VER]",
          "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"],
          "Windows Phone": "Windows Phone [VER]",
          "Windows CE": "Windows CE\/[VER]",
          "Windows NT": "Windows NT [VER]",
          "Symbian": ["SymbianOS\/[VER]", "Symbian\/[VER]"],
          "webOS": ["webOS\/[VER]", "hpwOS\/[VER];"]
        },
        "utils": {
          "Bot": "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom",
          "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
          "DesktopMode": "WPDesktop",
          "TV": "SonyDTV|HbbTV",
          "WebKit": "(webkit)[ \/]([\\w.]+)",
          "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|PLAYSTATION|Xbox)\\b",
          "Watch": "SM-V700"
        }
      };
      impl.detectMobileBrowsers = {
        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
        tabletPattern: /android|ipad|playbook|silk/i
      };
      var hasOwnProp = Object.prototype.hasOwnProperty,
          isArray;
      impl.FALLBACK_PHONE = 'UnknownPhone';
      impl.FALLBACK_TABLET = 'UnknownTablet';
      impl.FALLBACK_MOBILE = 'UnknownMobile';
      isArray = ('isArray' in Array) ? Array.isArray : function(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
      };
      function equalIC(a, b) {
        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
      }
      function containsIC(array, value) {
        var valueLC,
            i,
            len = array.length;
        if (!len || !value) {
          return false;
        }
        valueLC = value.toLowerCase();
        for (i = 0; i < len; ++i) {
          if (valueLC === array[i].toLowerCase()) {
            return true;
          }
        }
        return false;
      }
      function convertPropsToRegExp(object) {
        for (var key in object) {
          if (hasOwnProp.call(object, key)) {
            object[key] = new RegExp(object[key], 'i');
          }
        }
      }
      (function init() {
        var key,
            values,
            value,
            i,
            len,
            verPos,
            mobileDetectRules = impl.mobileDetectRules;
        for (key in mobileDetectRules.props) {
          if (hasOwnProp.call(mobileDetectRules.props, key)) {
            values = mobileDetectRules.props[key];
            if (!isArray(values)) {
              values = [values];
            }
            len = values.length;
            for (i = 0; i < len; ++i) {
              value = values[i];
              verPos = value.indexOf('[VER]');
              if (verPos >= 0) {
                value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
              }
              values[i] = new RegExp(value, 'i');
            }
            mobileDetectRules.props[key] = values;
          }
        }
        convertPropsToRegExp(mobileDetectRules.oss);
        convertPropsToRegExp(mobileDetectRules.phones);
        convertPropsToRegExp(mobileDetectRules.tablets);
        convertPropsToRegExp(mobileDetectRules.uas);
        convertPropsToRegExp(mobileDetectRules.utils);
        mobileDetectRules.oss0 = {
          WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
          WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
        };
      }());
      impl.findMatch = function(rules, userAgent) {
        for (var key in rules) {
          if (hasOwnProp.call(rules, key)) {
            if (rules[key].test(userAgent)) {
              return key;
            }
          }
        }
        return null;
      };
      impl.findMatches = function(rules, userAgent) {
        var result = [];
        for (var key in rules) {
          if (hasOwnProp.call(rules, key)) {
            if (rules[key].test(userAgent)) {
              result.push(key);
            }
          }
        }
        return result;
      };
      impl.getVersionStr = function(propertyName, userAgent) {
        var props = impl.mobileDetectRules.props,
            patterns,
            i,
            len,
            match;
        if (hasOwnProp.call(props, propertyName)) {
          patterns = props[propertyName];
          len = patterns.length;
          for (i = 0; i < len; ++i) {
            match = patterns[i].exec(userAgent);
            if (match !== null) {
              return match[1];
            }
          }
        }
        return null;
      };
      impl.getVersion = function(propertyName, userAgent) {
        var version = impl.getVersionStr(propertyName, userAgent);
        return version ? impl.prepareVersionNo(version) : NaN;
      };
      impl.prepareVersionNo = function(version) {
        var numbers;
        numbers = version.split(/[a-z._ \/\-]/i);
        if (numbers.length === 1) {
          version = numbers[0];
        }
        if (numbers.length > 1) {
          version = numbers[0] + '.';
          numbers.shift();
          version += numbers.join('');
        }
        return Number(version);
      };
      impl.isMobileFallback = function(userAgent) {
        return impl.detectMobileBrowsers.fullPattern.test(userAgent) || impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0, 4));
      };
      impl.isTabletFallback = function(userAgent) {
        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
      };
      impl.prepareDetectionCache = function(cache, userAgent, maxPhoneWidth) {
        if (cache.mobile !== undefined) {
          return;
        }
        var phone,
            tablet,
            phoneSized;
        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
        if (tablet) {
          cache.mobile = cache.tablet = tablet;
          cache.phone = null;
          return;
        }
        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
        if (phone) {
          cache.mobile = cache.phone = phone;
          cache.tablet = null;
          return;
        }
        if (impl.isMobileFallback(userAgent)) {
          phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
          if (phoneSized === undefined) {
            cache.mobile = impl.FALLBACK_MOBILE;
            cache.tablet = cache.phone = null;
          } else if (phoneSized) {
            cache.mobile = cache.phone = impl.FALLBACK_PHONE;
            cache.tablet = null;
          } else {
            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
            cache.phone = null;
          }
        } else if (impl.isTabletFallback(userAgent)) {
          cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
          cache.phone = null;
        } else {
          cache.mobile = cache.tablet = cache.phone = null;
        }
      };
      impl.mobileGrade = function(t) {
        var $isMobile = t.mobile() !== null;
        if (t.os('iOS') && t.version('iPad') >= 4.3 || t.os('iOS') && t.version('iPhone') >= 3.1 || t.os('iOS') && t.version('iPod') >= 3.1 || (t.version('Android') > 2.1 && t.is('Webkit')) || t.version('Windows Phone OS') >= 7.0 || t.is('BlackBerry') && t.version('BlackBerry') >= 6.0 || t.match('Playbook.*Tablet') || (t.version('webOS') >= 1.4 && t.match('Palm|Pre|Pixi')) || t.match('hp.*TouchPad') || (t.is('Firefox') && t.version('Firefox') >= 12) || (t.is('Chrome') && t.is('AndroidOS') && t.version('Android') >= 4.0) || (t.is('Skyfire') && t.version('Skyfire') >= 4.1 && t.is('AndroidOS') && t.version('Android') >= 2.3) || (t.is('Opera') && t.version('Opera Mobi') > 11 && t.is('AndroidOS')) || t.is('MeeGoOS') || t.is('Tizen') || t.is('Dolfin') && t.version('Bada') >= 2.0 || ((t.is('UC Browser') || t.is('Dolfin')) && t.version('Android') >= 2.3) || (t.match('Kindle Fire') || t.is('Kindle') && t.version('Kindle') >= 3.0) || t.is('AndroidOS') && t.is('NookTablet') || t.version('Chrome') >= 11 && !$isMobile || t.version('Safari') >= 5.0 && !$isMobile || t.version('Firefox') >= 4.0 && !$isMobile || t.version('MSIE') >= 7.0 && !$isMobile || t.version('Opera') >= 10 && !$isMobile) {
          return 'A';
        }
        if (t.os('iOS') && t.version('iPad') < 4.3 || t.os('iOS') && t.version('iPhone') < 3.1 || t.os('iOS') && t.version('iPod') < 3.1 || t.is('Blackberry') && t.version('BlackBerry') >= 5 && t.version('BlackBerry') < 6 || (t.version('Opera Mini') >= 5.0 && t.version('Opera Mini') <= 6.5 && (t.version('Android') >= 2.3 || t.is('iOS'))) || t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') || t.version('Opera Mobi') >= 11 && t.is('SymbianOS')) {
          return 'B';
        }
        if (t.version('BlackBerry') < 5.0 || t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile') <= 5.2) {
          return 'C';
        }
        return 'C';
      };
      impl.detectOS = function(ua) {
        return impl.findMatch(impl.mobileDetectRules.oss0, ua) || impl.findMatch(impl.mobileDetectRules.oss, ua);
      };
      impl.getDeviceSmallerSide = function() {
        return window.screen.width < window.screen.height ? window.screen.width : window.screen.height;
      };
      function MobileDetect(userAgent, maxPhoneWidth) {
        this.ua = userAgent || '';
        this._cache = {};
        this.maxPhoneWidth = maxPhoneWidth || 600;
      }
      MobileDetect.prototype = {
        constructor: MobileDetect,
        mobile: function() {
          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
          return this._cache.mobile;
        },
        phone: function() {
          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
          return this._cache.phone;
        },
        tablet: function() {
          impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
          return this._cache.tablet;
        },
        userAgent: function() {
          if (this._cache.userAgent === undefined) {
            this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
          }
          return this._cache.userAgent;
        },
        userAgents: function() {
          if (this._cache.userAgents === undefined) {
            this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
          }
          return this._cache.userAgents;
        },
        os: function() {
          if (this._cache.os === undefined) {
            this._cache.os = impl.detectOS(this.ua);
          }
          return this._cache.os;
        },
        version: function(key) {
          return impl.getVersion(key, this.ua);
        },
        versionStr: function(key) {
          return impl.getVersionStr(key, this.ua);
        },
        is: function(key) {
          return containsIC(this.userAgents(), key) || equalIC(key, this.os()) || equalIC(key, this.phone()) || equalIC(key, this.tablet()) || containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
        },
        match: function(pattern) {
          if (!(pattern instanceof RegExp)) {
            pattern = new RegExp(pattern, 'i');
          }
          return pattern.test(this.ua);
        },
        isPhoneSized: function(maxPhoneWidth) {
          return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
        },
        mobileGrade: function() {
          if (this._cache.grade === undefined) {
            this._cache.grade = impl.mobileGrade(this);
          }
          return this._cache.grade;
        }
      };
      if (typeof window !== 'undefined' && window.screen) {
        MobileDetect.isPhoneSized = function(maxPhoneWidth) {
          return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
        };
      } else {
        MobileDetect.isPhoneSized = function() {};
      }
      MobileDetect._impl = impl;
      return MobileDetect;
    });
  })((function(undefined) {
    if (typeof module !== 'undefined' && module.exports) {
      return function(factory) {
        module.exports = factory();
      };
    } else if (typeof define === 'function' && define.amd) {
      return define;
    } else if (typeof window !== 'undefined') {
      return function(factory) {
        window.MobileDetect = factory();
      };
    } else {
      throw new Error('unknown environment');
    }
  })());
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("158", ["157"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('157');
  global.define = __define;
  return module.exports;
});

$__System.register("159", ["102", "106", "111", "113", "114", "158", "f6", "f7", "fb", "de", "ef", "10c", "10d", "fe", "10e"], function (_export) {
  var DATA, Signal, UIScene, View, Ticker, MobileDetect, _createClass, _classCallCheck, _getIterator, THREE, MainScene, Pointer, App, SoundManager, isMobile, lowQuality, ToyotaCHRExperience;

  return {
    setters: [function (_5) {
      DATA = _5["default"];
    }, function (_) {
      Signal = _["default"];
    }, function (_2) {
      UIScene = _2["default"];
    }, function (_3) {
      View = _3["default"];
    }, function (_4) {
      Ticker = _4["default"];
    }, function (_6) {
      MobileDetect = _6["default"];
    }, function (_f6) {
      _createClass = _f6["default"];
    }, function (_f7) {
      _classCallCheck = _f7["default"];
    }, function (_fb) {
      _getIterator = _fb["default"];
    }, function (_de) {}, function (_ef) {
      THREE = _ef["default"];
    }, function (_c) {
      MainScene = _c["default"];
    }, function (_d) {
      Pointer = _d["default"];
    }, function (_fe) {
      App = _fe["default"];
    }, function (_e) {
      SoundManager = _e["default"];
    }],
    execute: function () {
      "use strict";

      isMobile = false;
      lowQuality = false;

      ToyotaCHRExperience = (function () {
        _createClass(ToyotaCHRExperience, null, [{
          key: "isSupported",
          get: function get() {
            return App.isSupported;
          }
        }, {
          key: "assets",
          get: function get() {
            return DATA.assets;
          }
        }]);

        function ToyotaCHRExperience(canvas) {
          var baseURL = arguments.length <= 1 || arguments[1] === undefined ? './' : arguments[1];
          var opts = arguments.length <= 2 || arguments[2] === undefined ? { timeScale: 1 } : arguments[2];

          _classCallCheck(this, ToyotaCHRExperience);

          isMobile = !!new MobileDetect(window.navigator.userAgent).mobile();

          this.opts = opts;
          this.opts.timeScale = this.opts.timeScale === undefined ? 1 : this.opts.timeScale;
          this.opts.viewOffset = this.opts.viewOffset === undefined ? [0, 0] : this.opts.viewOffset;
          this.opts.useTextureNoise = this.opts.useTextureNoise === undefined ? true : this.opts.useTextureNoise;

          this.app = App;
          this.canvas = canvas;

          this._width = this.canvas.offsetWidth;
          this._height = this.canvas.offsetHeight;

          this._timeScale = 1;
          this._gotoLowQualityCounter = 30;

          // Add sounds
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _getIterator(DATA.assets.sounds), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var soundUrl = _step.value;

              SoundManager.add(baseURL + soundUrl);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"]) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.view = new View(this.canvas, opts);

          this.mainScene = new MainScene(this.canvas, this.opts.useTextureNoise, opts.fov, opts.viewOffset);
          this.uiScene = new UIScene(this.canvas);

          this.pointer = Pointer.get(this.canvas);
          this.pointer.disable();

          this.resize(this._width, this._height);

          this.render = new Signal();

          App.onStart.add(this._onStart, this);
          App.onStop.add(this._onStop, this);
          App.onResize.add(this._onResize, this);

          App.changeSceneByName("default", {
            transitionDuration: 10
          });

          this.interactive = true;
        }

        // Private

        _createClass(ToyotaCHRExperience, [{
          key: "_onStart",
          value: function _onStart() {
            Ticker.add(this._update, this);
          }
        }, {
          key: "_onStop",
          value: function _onStop() {
            Ticker.remove(this._update);
          }
        }, {
          key: "_onResize",
          value: function _onResize() {
            this.view.render(this.mainScene, this.uiScene);
          }
        }, {
          key: "_update",
          value: function _update() {
            if (App.stats) {
              App.stats.begin();
            }

            var timeScale = Ticker.deltaTime / 16;
            if (timeScale > 3 && !lowQuality) {
              this._gotoLowQualityCounter--;
              if (this._gotoLowQualityCounter <= 0) {
                lowQuality = true;
                this.resize();
              }
            }

            this._timeScale += (timeScale - this._timeScale) * .1;
            this._timeScale = Math.min(this._timeScale, 1.5);

            this._timeScale *= this.opts.timeScale;

            this.mainScene.update(this._timeScale);
            this.view.render(this.mainScene, this.uiScene);
            this.render.dispatch(this.canvas);

            if (App.stats) {
              App.stats.end();
            }
          }

          // Public

        }, {
          key: "start",
          value: function start() {
            App.start();
          }
        }, {
          key: "stop",
          value: function stop() {
            App.stop();
          }
        }, {
          key: "restart",
          value: function restart() {
            App.restart();
          }
        }, {
          key: "resize",
          value: function resize() {
            var width = arguments.length <= 0 || arguments[0] === undefined ? this._width : arguments[0];
            var height = arguments.length <= 1 || arguments[1] === undefined ? this._height : arguments[1];

            this._width = width;
            this._height = height;
            App.resize(this._width, this._height, lowQuality);
          }
        }, {
          key: "clear",
          value: function clear() {
            this.view.renderer.clear();
          }
        }, {
          key: "dispose",
          value: function dispose() {
            console.warn("dispose has been deprecated");
          }
        }, {
          key: "interactive",
          set: function set(value) {
            App.interactive = value && !isMobile;
            if (value && (isMobile || this.opts.forceTouchEnabled)) {
              this.pointer.enable();
            } else {
              this.pointer.disable();
            }
          },
          get: function get() {
            return App.interactive;
          }
        }]);

        return ToyotaCHRExperience;
      })();

      _export("default", ToyotaCHRExperience);

      window.ToyotaCHRExperience = ToyotaCHRExperience;
    }
  };
});
$__System.register("15a", ["159"], function (_export) {
  "use strict";

  return {
    setters: [function (_) {
      var _exportObj = {};

      for (var _key in _) {
        if (_key !== "default") _exportObj[_key] = _[_key];
      }

      _exportObj["default"] = _["default"];

      _export(_exportObj);
    }],
    execute: function () {}
  };
});
$__System.register("15b", [], function (_export) {
	// Copyright Google Inc. All Rights Reserved.
	"use strict";

	return {
		setters: [],
		execute: function () {
			(function () {
				'use strict';var g,
				    h = this,
				    k = function k(a) {
					return void 0 !== a;
				},
				    aa = function aa() {},
				    m = function m(a) {
					var b = typeof a;if ("object" == b) if (a) {
						if (a instanceof Array) return "array";if (a instanceof Object) return b;var c = Object.prototype.toString.call(a);if ("[object Window]" == c) return "object";if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
					} else return "null";else if ("function" == b && "undefined" == typeof a.call) return "object";return b;
				},
				    ba = function ba(a) {
					return "string" == typeof a;
				},
				    n = function n(a) {
					return "number" == typeof a;
				},
				    ca = function ca(a, b, c) {
					return a.call.apply(a.bind, arguments);
				},
				    da = function da(a, b, c) {
					if (!a) throw Error();if (2 < arguments.length) {
						var d = Array.prototype.slice.call(arguments, 2);return function () {
							var c = Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c, d);return a.apply(b, c);
						};
					}return function () {
						return a.apply(b, arguments);
					};
				},
				    _p = function p(a, b, c) {
					_p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ca : da;return _p.apply(null, arguments);
				},
				    ea = function ea(a, b) {
					var c = Array.prototype.slice.call(arguments, 1);return function () {
						var b = c.slice();b.push.apply(b, arguments);return a.apply(this, b);
					};
				},
				    fa = Date.now || function () {
					return +new Date();
				},
				    r = function r(a, b) {
					var c = a.split("."),
					    d = h;c[0] in d || !d.execScript || d.execScript("var " + c[0]);for (var e; c.length && (e = c.shift());) !c.length && k(b) ? d[e] = b : d = d[e] ? d[e] : d[e] = {};
				},
				    t = function t(a, b) {
					function c() {}c.prototype = b.prototype;a.D = b.prototype;a.prototype = new c();a.prototype.constructor = a;a.vd = function (a, c, f) {
						for (var l = Array(arguments.length - 2), q = 2; q < arguments.length; q++) l[q - 2] = arguments[q];return b.prototype[c].apply(a, l);
					};
				};var cast = h.cast || {};r("cast.receiver.VERSION", "2.0.0");var ga = function ga(a) {
					if (Error.captureStackTrace) Error.captureStackTrace(this, ga);else {
						var b = Error().stack;b && (this.stack = b);
					}a && (this.message = String(a));
				};t(ga, Error);ga.prototype.name = "CustomError";var ha = function ha(a, b) {
					for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;) d += c.shift() + e.shift();return d + c.join("%s");
				},
				    ia = String.prototype.trim ? function (a) {
					return a.trim();
				} : function (a) {
					return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
				},
				    ja = function ja(a, b) {
					var c = String(a).toLowerCase(),
					    d = String(b).toLowerCase();return c < d ? -1 : c == d ? 0 : 1;
				},
				    v = function v(a, b) {
					return -1 != a.indexOf(b);
				},
				    ka = function ka(a, b) {
					return a < b ? -1 : a > b ? 1 : 0;
				};var la = function la(a, b) {
					b.unshift(a);ga.call(this, ha.apply(null, b));b.shift();
				};t(la, ga);la.prototype.name = "AssertionError";var w = function w(a, b, c) {
					if (!a) {
						var d = "Assertion failed";if (b) var d = d + (": " + b),
						    e = Array.prototype.slice.call(arguments, 2);throw new la("" + d, e || []);
					}
				},
				    ma = function ma(a, b) {
					throw new la("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
				};var x = Array.prototype,
				    y = x.indexOf ? function (a, b, c) {
					w(null != a.length);return x.indexOf.call(a, b, c);
				} : function (a, b, c) {
					c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;if (ba(a)) return ba(b) && 1 == b.length ? a.indexOf(b, c) : -1;for (; c < a.length; c++) if (c in a && a[c] === b) return c;return -1;
				},
				    pa = x.lastIndexOf ? function (a, b, c) {
					w(null != a.length);return x.lastIndexOf.call(a, b, null == c ? a.length - 1 : c);
				} : function (a, b, c) {
					c = null == c ? a.length - 1 : c;0 > c && (c = Math.max(0, a.length + c));if (ba(a)) return ba(b) && 1 == b.length ? a.lastIndexOf(b, c) : -1;for (; 0 <= c; c--) if (c in a && a[c] === b) return c;return -1;
				},
				    ra = function ra(a, b) {
					var c = y(a, b),
					    d;(d = 0 <= c) && qa(a, c);return d;
				},
				    qa = function qa(a, b) {
					w(null != a.length);x.splice.call(a, b, 1);
				},
				    ta = function ta(a, b, c, d) {
					w(null != a.length);return x.splice.apply(a, sa(arguments, 1));
				},
				    sa = function sa(a, b, c) {
					w(null != a.length);return 2 >= arguments.length ? x.slice.call(a, b) : x.slice.call(a, b, c);
				};var ua = function ua(a, b, c) {
					for (var d in a) b.call(c, a[d], d, a);
				},
				    va = function va(a, b) {
					for (var c in a) if (b.call(void 0, a[c], c, a)) return !0;return !1;
				},
				    wa = function wa(a) {
					var b = [],
					    c = 0,
					    d;for (d in a) b[c++] = d;return b;
				},
				    xa = function xa(a) {
					var b = {},
					    c;for (c in a) b[c] = a[c];return b;
				},
				    ya = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),
				    za = function za(a, b) {
					for (var c, d, e = 1; e < arguments.length; e++) {
						d = arguments[e];for (c in d) a[c] = d[c];for (var f = 0; f < ya.length; f++) c = ya[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
					}
				};var z;a: {
					var Aa = h.navigator;if (Aa) {
						var Ba = Aa.userAgent;if (Ba) {
							z = Ba;break a;
						}
					}z = "";
				};var Ca = v(z, "Opera") || v(z, "OPR"),
				    A = v(z, "Trident") || v(z, "MSIE"),
				    Da = v(z, "Edge"),
				    Ea = v(z, "Gecko") && !(v(z.toLowerCase(), "webkit") && !v(z, "Edge")) && !(v(z, "Trident") || v(z, "MSIE")) && !v(z, "Edge"),
				    Fa = v(z.toLowerCase(), "webkit") && !v(z, "Edge"),
				    Ga = function Ga() {
					var a = z;if (Ea) return (/rv\:([^\);]+)(\)|;)/.exec(a)
					);if (Da) return (/Edge\/([\d\.]+)/.exec(a)
					);if (A) return (/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
					);if (Fa) return (/WebKit\/(\S+)/.exec(a)
					);
				},
				    Ha = function Ha() {
					var a = h.document;return a ? a.documentMode : void 0;
				},
				    Ia = (function () {
					if (Ca && h.opera) {
						var a;var b = h.opera.version;try {
							a = b();
						} catch (c) {
							a = b;
						}return a;
					}a = "";(b = Ga()) && (a = b ? b[1] : "");return A && (b = Ha(), b > parseFloat(a)) ? String(b) : a;
				})(),
				    Ja = {},
				    B = function B(a) {
					var b;if (!(b = Ja[a])) {
						b = 0;for (var c = ia(String(Ia)).split("."), d = ia(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
							var l = c[f] || "",
							    q = d[f] || "",
							    u = /(\d*)(\D*)/g,
							    H = /(\d*)(\D*)/g;do {
								var na = u.exec(l) || ["", "", ""],
								    oa = H.exec(q) || ["", "", ""];if (0 == na[0].length && 0 == oa[0].length) break;b = ka(0 == na[1].length ? 0 : parseInt(na[1], 10), 0 == oa[1].length ? 0 : parseInt(oa[1], 10)) || ka(0 == na[2].length, 0 == oa[2].length) || ka(na[2], oa[2]);
							} while (0 == b);
						}b = Ja[a] = 0 <= b;
					}return b;
				},
				    Ka = h.document,
				    La = Ka && A ? Ha() || ("CSS1Compat" == Ka.compatMode ? parseInt(Ia, 10) : 5) : void 0;var Ma = function Ma(a, b, c, d, e) {
					this.reset(a, b, c, d, e);
				};Ma.prototype.fb = null;var Na = 0;Ma.prototype.reset = function (a, b, c, d, e) {
					"number" == typeof e || Na++;this.hc = d || fa();this.W = a;this.Rb = b;this.Pb = c;delete this.fb;
				};Ma.prototype.hb = function () {
					return this.W;
				};Ma.prototype.Bb = function (a) {
					this.W = a;
				};var C = function C(a) {
					this.Sb = a;this.ua = this.Za = this.W = this.Qa = null;
				},
				    D = function D(a, b) {
					this.name = a;this.value = b;
				};D.prototype.toString = function () {
					return this.name;
				};
				var Oa = new D("SHOUT", 1200),
				    Pa = new D("SEVERE", 1E3),
				    Qa = new D("WARNING", 900),
				    Ra = new D("INFO", 800),
				    Sa = new D("CONFIG", 700),
				    Ta = new D("FINE", 500),
				    E = new D("FINER", 400),
				    Ua = [new D("OFF", Infinity), Oa, Pa, Qa, Ra, Sa, Ta, E, new D("FINEST", 300), new D("ALL", 0)],
				    Va = null,
				    Wa = function Wa(a) {
					if (!Va) {
						Va = {};for (var b = 0, c; c = Ua[b]; b++) Va[c.value] = c, Va[c.name] = c;
					}if (a in Va) return Va[a];for (b = 0; b < Ua.length; ++b) if ((c = Ua[b], c.value <= a)) return c;return null;
				};C.prototype.getName = function () {
					return this.Sb;
				};C.prototype.getParent = function () {
					return this.Qa;
				};
				C.prototype.Bb = function (a) {
					this.W = a;
				};C.prototype.hb = function () {
					return this.W;
				};var Xa = function Xa(_x) {
					var _again = true;

					_function: while (_again) {
						var a = _x;
						_again = false;
						if (a.W) return a.W;if (a.Qa) {
							_x = a.Qa;
							_again = true;
							continue _function;
						}ma("Root logger has no level set.");return null;
					}
				};
				C.prototype.log = function (a, b, c) {
					if (a.value >= Xa(this).value) for ("function" == m(b) && (b = b()), a = new Ma(a, String(b), this.Sb), c && (a.fb = c), c = "log:" + a.Rb, h.console && (h.console.timeStamp ? h.console.timeStamp(c) : h.console.markTimeline && h.console.markTimeline(c)), h.msWriteProfilerMark && h.msWriteProfilerMark(c), c = this; c;) {
						b = c;var d = a;if (b.ua) for (var e = 0, f = void 0; f = b.ua[e]; e++) f(d);c = c.getParent();
					}
				};C.prototype.info = function (a, b) {
					this.log(Ra, a, b);
				};
				var Ya = {},
				    Za = null,
				    $a = function $a() {
					Za || (Za = new C(""), Ya[""] = Za, Za.Bb(Sa));
				},
				    F = function F(a) {
					$a();var b;if (!(b = Ya[a])) {
						b = new C(a);var c = a.lastIndexOf("."),
						    d = a.substr(c + 1),
						    c = F(a.substr(0, c));c.Za || (c.Za = {});c.Za[d] = b;b.Qa = c;Ya[a] = b;
					}return b;
				};var G = function G() {
					this.ra = this.ra;this.X = this.X;
				};G.prototype.ra = !1;G.prototype.S = function () {
					this.ra || (this.ra = !0, this.l());
				};var ab = function ab(a, b) {
					a.ra ? b.call(void 0) : (a.X || (a.X = []), a.X.push(k(void 0) ? _p(b, void 0) : b));
				};G.prototype.l = function () {
					if (this.X) for (; this.X.length;) this.X.shift()();
				};var bb = function bb(a) {
					a && "function" == typeof a.S && a.S();
				};var I = function I(a, b) {
					this.type = a;this.currentTarget = this.target = b;this.defaultPrevented = this.Z = !1;this.Zb = !0;
				};I.prototype.stopPropagation = function () {
					this.Z = !0;
				};I.prototype.preventDefault = function () {
					this.defaultPrevented = !0;this.Zb = !1;
				};var cb = function cb(a) {
					cb[" "](a);return a;
				};cb[" "] = aa;var db = !A || 9 <= La,
				    eb = A && !B("9");!Fa || B("528");Ea && B("1.9b") || A && B("8") || Ca && B("9.5") || Fa && B("528");Ea && !B("8") || A && B("9");var fb = function fb(a, b) {
					I.call(this, a ? a.type : "");this.relatedTarget = this.currentTarget = this.target = null;this.charCode = this.keyCode = this.button = this.screenY = this.screenX = this.clientY = this.clientX = this.offsetY = this.offsetX = 0;this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;this.ha = this.state = null;if (a) {
						var c = this.type = a.type,
						    d = a.changedTouches ? a.changedTouches[0] : null;this.target = a.target || a.srcElement;this.currentTarget = b;var e = a.relatedTarget;if (e) {
							if (Ea) {
								var f;a: {
									try {
										cb(e.nodeName);f = !0;break a;
									} catch (l) {}f = !1;
								}f || (e = null);
							}
						} else "mouseover" == c ? e = a.fromElement : "mouseout" == c && (e = a.toElement);this.relatedTarget = e;null === d ? (this.offsetX = Fa || void 0 !== a.offsetX ? a.offsetX : a.layerX, this.offsetY = Fa || void 0 !== a.offsetY ? a.offsetY : a.layerY, this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0) : (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0);this.button = a.button;this.keyCode = a.keyCode || 0;this.charCode = a.charCode || ("keypress" == c ? a.keyCode : 0);this.ctrlKey = a.ctrlKey;this.altKey = a.altKey;this.shiftKey = a.shiftKey;this.metaKey = a.metaKey;this.state = a.state;this.ha = a;a.defaultPrevented && this.preventDefault();
					}
				};t(fb, I);fb.prototype.stopPropagation = function () {
					fb.D.stopPropagation.call(this);this.ha.stopPropagation ? this.ha.stopPropagation() : this.ha.cancelBubble = !0;
				};
				fb.prototype.preventDefault = function () {
					fb.D.preventDefault.call(this);var a = this.ha;if (a.preventDefault) a.preventDefault();else if ((a.returnValue = !1, eb)) try {
						if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) a.keyCode = -1;
					} catch (b) {}
				};var gb = "closure_listenable_" + (1E6 * Math.random() | 0),
				    hb = 0;var ib = function ib(a, b, c, d, e) {
					this.listener = a;this.Ra = null;this.src = b;this.type = c;this.qa = !!d;this.Ja = e;this.key = ++hb;this.oa = this.Ha = !1;
				},
				    jb = function jb(a) {
					a.oa = !0;a.listener = null;a.Ra = null;a.src = null;a.Ja = null;
				};var J = function J(a) {
					this.src = a;this.s = {};this.Fa = 0;
				};J.prototype.add = function (a, b, c, d, e) {
					var f = a.toString();a = this.s[f];a || (a = this.s[f] = [], this.Fa++);var l = kb(a, b, d, e);-1 < l ? (b = a[l], c || (b.Ha = !1)) : (b = new ib(b, this.src, f, !!d, e), b.Ha = c, a.push(b));return b;
				};J.prototype.remove = function (a, b, c, d) {
					a = a.toString();if (!(a in this.s)) return !1;var e = this.s[a];b = kb(e, b, c, d);return -1 < b ? (jb(e[b]), qa(e, b), 0 == e.length && (delete this.s[a], this.Fa--), !0) : !1;
				};
				var lb = function lb(a, b) {
					var c = b.type;c in a.s && ra(a.s[c], b) && (jb(b), 0 == a.s[c].length && (delete a.s[c], a.Fa--));
				};J.prototype.zb = function (a) {
					a = a && a.toString();var b = 0,
					    c;for (c in this.s) if (!a || c == a) {
						for (var d = this.s[c], e = 0; e < d.length; e++) ++b, jb(d[e]);delete this.s[c];this.Fa--;
					}return b;
				};J.prototype.sa = function (a, b, c, d) {
					a = this.s[a.toString()];var e = -1;a && (e = kb(a, b, c, d));return -1 < e ? a[e] : null;
				};
				J.prototype.hasListener = function (a, b) {
					var c = k(a),
					    d = c ? a.toString() : "",
					    e = k(b);return va(this.s, function (a) {
						for (var l = 0; l < a.length; ++l) if (!(c && a[l].type != d || e && a[l].qa != b)) return !0;return !1;
					});
				};var kb = function kb(a, b, c, d) {
					for (var e = 0; e < a.length; ++e) {
						var f = a[e];if (!f.oa && f.listener == b && f.qa == !!c && f.Ja == d) return e;
					}return -1;
				};var mb = "closure_lm_" + (1E6 * Math.random() | 0),
				    nb = {},
				    ob = 0,
				    K = function K(a, b, c, d, e) {
					if ("array" == m(b)) {
						for (var f = 0; f < b.length; f++) K(a, b[f], c, d, e);return null;
					}c = pb(c);if (a && a[gb]) a = a.ma(b, c, d, e);else {
						if (!b) throw Error("Invalid event type");var f = !!d,
						    l = qb(a);l || (a[mb] = l = new J(a));c = l.add(b, c, !1, d, e);if (!c.Ra) {
							d = rb();c.Ra = d;d.src = a;d.listener = c;if (a.addEventListener) a.addEventListener(b.toString(), d, f);else if (a.attachEvent) a.attachEvent(sb(b.toString()), d);else throw Error("addEventListener and attachEvent are unavailable.");
							ob++;
						}a = c;
					}return a;
				},
				    rb = function rb() {
					var a = tb,
					    b = db ? function (c) {
						return a.call(b.src, b.listener, c);
					} : function (c) {
						c = a.call(b.src, b.listener, c);if (!c) return c;
					};return b;
				},
				    ub = function ub(a, b, c, d, e) {
					if ("array" == m(b)) for (var f = 0; f < b.length; f++) ub(a, b[f], c, d, e);else c = pb(c), a && a[gb] ? a.Cb(b, c, d, e) : a && (a = qb(a)) && (b = a.sa(b, c, !!d, e)) && vb(b);
				},
				    vb = function vb(a) {
					if (!n(a) && a && !a.oa) {
						var b = a.src;if (b && b[gb]) lb(b.G, a);else {
							var c = a.type,
							    d = a.Ra;b.removeEventListener ? b.removeEventListener(c, d, a.qa) : b.detachEvent && b.detachEvent(sb(c), d);ob--;(c = qb(b)) ? (lb(c, a), 0 == c.Fa && (c.src = null, b[mb] = null)) : jb(a);
						}
					}
				},
				    sb = function sb(a) {
					return a in nb ? nb[a] : nb[a] = "on" + a;
				},
				    xb = function xb(a, b, c, d) {
					var e = !0;if (a = qb(a)) if (b = a.s[b.toString()]) for (b = b.concat(), a = 0; a < b.length; a++) {
						var f = b[a];f && f.qa == c && !f.oa && (f = wb(f, d), e = e && !1 !== f);
					}return e;
				},
				    wb = function wb(a, b) {
					var c = a.listener,
					    d = a.Ja || a.src;a.Ha && vb(a);return c.call(d, b);
				},
				    tb = function tb(a, b) {
					if (a.oa) return !0;if (!db) {
						var c;if (!(c = b)) a: {
							c = ["window", "event"];for (var d = h, e; e = c.shift();) if (null != d[e]) d = d[e];else {
								c = null;break a;
							}c = d;
						}e = c;c = new fb(e, this);d = !0;if (!(0 > e.keyCode || void 0 != e.returnValue)) {
							a: {
								var f = !1;if (0 == e.keyCode) try {
									e.keyCode = -1;break a;
								} catch (l) {
									f = !0;
								}if (f || void 0 == e.returnValue) e.returnValue = !0;
							}e = [];for (f = c.currentTarget; f; f = f.parentNode) e.push(f);for (var f = a.type, q = e.length - 1; !c.Z && 0 <= q; q--) {
								c.currentTarget = e[q];var u = xb(e[q], f, !0, c),
								    d = d && u;
							}for (q = 0; !c.Z && q < e.length; q++) c.currentTarget = e[q], u = xb(e[q], f, !1, c), d = d && u;
						}return d;
					}return wb(a, new fb(b, this));
				},
				    qb = function qb(a) {
					a = a[mb];return a instanceof J ? a : null;
				},
				    yb = "__closure_events_fn_" + (1E9 * Math.random() >>> 0),
				    pb = function pb(a) {
					w(a, "Listener can not be null.");if ("function" == m(a)) return a;w(a.handleEvent, "An object listener must have handleEvent method.");a[yb] || (a[yb] = function (b) {
						return a.handleEvent(b);
					});return a[yb];
				};var L = function L() {
					G.call(this);this.G = new J(this);this.ic = this;this.yb = null;
				};t(L, G);L.prototype[gb] = !0;g = L.prototype;g.addEventListener = function (a, b, c, d) {
					K(this, a, b, c, d);
				};g.removeEventListener = function (a, b, c, d) {
					ub(this, a, b, c, d);
				};
				g.dispatchEvent = function (a) {
					zb(this);var b,
					    c = this.yb;if (c) {
						b = [];for (var d = 1; c; c = c.yb) b.push(c), w(1E3 > ++d, "infinite loop");
					}c = this.ic;d = a.type || a;if (ba(a)) a = new I(a, c);else if (a instanceof I) a.target = a.target || c;else {
						var e = a;a = new I(d, c);za(a, e);
					}var e = !0,
					    f;if (b) for (var l = b.length - 1; !a.Z && 0 <= l; l--) f = a.currentTarget = b[l], e = Ab(f, d, !0, a) && e;a.Z || (f = a.currentTarget = c, e = Ab(f, d, !0, a) && e, a.Z || (e = Ab(f, d, !1, a) && e));if (b) for (l = 0; !a.Z && l < b.length; l++) f = a.currentTarget = b[l], e = Ab(f, d, !1, a) && e;return e;
				};
				g.l = function () {
					L.D.l.call(this);this.G && this.G.zb(void 0);this.yb = null;
				};g.ma = function (a, b, c, d) {
					zb(this);return this.G.add(String(a), b, !1, c, d);
				};g.Cb = function (a, b, c, d) {
					return this.G.remove(String(a), b, c, d);
				};var Ab = function Ab(a, b, c, d) {
					b = a.G.s[String(b)];if (!b) return !0;b = b.concat();for (var e = !0, f = 0; f < b.length; ++f) {
						var l = b[f];if (l && !l.oa && l.qa == c) {
							var q = l.listener,
							    u = l.Ja || l.src;l.Ha && lb(a.G, l);e = !1 !== q.call(u, d) && e;
						}
					}return e && 0 != d.Zb;
				};L.prototype.sa = function (a, b, c, d) {
					return this.G.sa(String(a), b, c, d);
				};
				L.prototype.hasListener = function (a, b) {
					return this.G.hasListener(k(a) ? String(a) : void 0, b);
				};var zb = function zb(a) {
					w(a.G, "Event target is not initialized. Did you call the superclass (goog.events.EventTarget) constructor?");
				};var M = function M(a, b, c) {
					a && a.log(b, c, void 0);
				},
				    N = function N(a, b) {
					a && a.log(Pa, b, void 0);
				},
				    Bb = function Bb(a, b) {
					a && a.log(Qa, b, void 0);
				},
				    O = function O(a, b) {
					a && a.info(b, void 0);
				},
				    Cb = function Cb(a, b) {
					a && a.log(Ta, b, void 0);
				};var P = function P(a, b) {
					L.call(this);this.ca = b;this.lb = !0;this.fa = a;this.onClose = this.onMessage = null;this.fa.ma(this.ca, this.ub, !1, this);
				};t(P, L);r("cast.receiver.CastChannel", P);P.EventType = { MESSAGE: "message", CLOSE: "close" };var Db = function Db(a, b) {
					I.call(this, a);this.message = b;
				};t(Db, I);P.Event = Db;P.prototype.a = F("cast.receiver.CastChannel");P.prototype.J = function () {
					return "CastChannel[" + this.ca + " " + this.fa.T() + "]";
				};P.prototype.T = function () {
					return this.fa.T();
				};P.prototype.getNamespace = P.prototype.T;
				P.prototype.Sc = function () {
					return this.ca;
				};P.prototype.getSenderId = P.prototype.Sc;P.prototype.ub = function (a) {
					M(this.a, E, "Dispatching CastChannel message [" + this.fa.T() + ", " + this.ca + "]: " + a.data);a = new Db("message", a.data);if (this.onMessage) this.onMessage(a);this.dispatchEvent(a);
				};P.prototype.close = function () {
					if (this.lb) {
						this.lb = !1;O(this.a, "Closing CastChannel [" + this.fa.T() + ", " + this.ca + "]");var a = new Db("close", this.ca);if (this.onClose) this.onClose(a);this.dispatchEvent(a);this.S();
					}
				};
				P.prototype.send = function (a) {
					if (!this.lb) throw Error("Invalid state, socket not open");this.fa.send(this.ca, a);
				};P.prototype.send = P.prototype.send;P.prototype.l = function () {
					P.D.l.call(this);M(this.a, E, "Disposed " + this.J());
				};var Eb = function Eb(a, b, c) {
					if ("function" == m(a)) c && (a = _p(a, c));else if (a && "function" == typeof a.handleEvent) a = _p(a.handleEvent, a);else throw Error("Invalid listener argument");return 2147483647 < b ? -1 : h.setTimeout(a, b || 0);
				};var Gb = function Gb(a, b) {
					L.call(this);this.kc = k(a) ? a : !0;this.ib = b || Fb;this.Oa = this.ib(this.Da);
				};t(Gb, L);g = Gb.prototype;g.w = null;g.M = null;g.na = void 0;g.$a = !1;g.Da = 0;g.$ = null;var Hb = Gb.prototype,
				    Ib = F("goog.net.WebSocket");Hb.a = Ib;var Fb = function Fb(a) {
					return Math.min(1E3 * Math.pow(2, a), 6E4);
				};g = Gb.prototype;
				g.open = function (a, b) {
					w(h.WebSocket, "This browser does not support WebSocket");w(!this.wa(), "The WebSocket is already open");null != this.$ && h.clearTimeout(this.$);this.$ = null;this.M = a;(this.na = b) ? (O(this.a, "Opening the WebSocket on " + this.M + " with protocol " + this.na), this.w = new WebSocket(this.M, this.na)) : (O(this.a, "Opening the WebSocket on " + this.M), this.w = new WebSocket(this.M));this.w.onopen = _p(this.bd, this);this.w.onclose = _p(this.$c, this);this.w.onmessage = _p(this.vb, this);this.w.onerror = _p(this.sb, this);
				};
				g.close = function () {
					null != this.$ && h.clearTimeout(this.$);this.$ = null;this.w && (O(this.a, "Closing the WebSocket."), this.$a = !0, this.w.close(), this.w = null);
				};g.send = function (a) {
					w(this.wa(), "Cannot send without an open socket");this.w.send(a);
				};g.wa = function () {
					return !!this.w && 1 == this.w.readyState;
				};g.bd = function () {
					O(this.a, "WebSocket opened on " + this.M);this.dispatchEvent("d");this.Da = 0;this.Oa = this.ib(this.Da);
				};
				g.$c = function (a) {
					O(this.a, "The WebSocket on " + this.M + " closed.");this.dispatchEvent("a");this.w = null;this.$a ? (O(this.a, "The WebSocket closed normally."), this.M = null, this.na = void 0) : (N(this.a, "The WebSocket disconnected unexpectedly: " + a.data), this.kc && (O(this.a, "Seconds until next reconnect attempt: " + Math.floor(this.Oa / 1E3)), this.$ = Eb(_p(this.open, this, this.M, this.na), this.Oa, this), this.Da++, this.Oa = this.ib(this.Da)));this.$a = !1;
				};g.vb = function (a) {
					this.dispatchEvent(new Jb(a.data));
				};
				g.sb = function (a) {
					a = a.data;N(this.a, "An error occurred: " + a);this.dispatchEvent(new Kb(a));
				};g.l = function () {
					Gb.D.l.call(this);this.close();
				};var Jb = function Jb(a) {
					I.call(this, "c");this.message = a;
				};t(Jb, I);var Kb = function Kb(a) {
					I.call(this, "b");this.data = a;
				};t(Kb, I);var Lb = { "port-for-web-server": "8008" },
				    Mb = cast.__platform__ && cast.__platform__.queryPlatformValue || function (a) {
					if (a in Lb) return Lb[a];
				};F("cast.receiver.platform.WebSocket");r("cast.receiver.system.NAMESPACE_PREFIX", "urn:x-cast:");r("cast.receiver.system.ApplicationData", function () {
					this.name = this.id = "";this.sessionId = 0;this.namespaces = [];this.launchingSenderId = "";
				});r("cast.receiver.system.SystemVolumeData", function () {
					this.level = 1;this.muted = !1;
				});r("cast.receiver.system.Sender", function () {
					this.userAgent = this.id = "";
				});r("cast.receiver.system.VisibilityState", { VISIBLE: "visible", NOT_VISIBLE: "notvisible", UNKNOWN: "unknown" });
				r("cast.receiver.system.StandbyState", { STANDBY: "standby", NOT_STANDBY: "notstandby", UNKNOWN: "unknown" });r("cast.receiver.system.SystemState", { NOT_STARTED: "notstarted", STARTING_IN_BACKGROUND: "startinginbackground", STARTING: "starting", READY: "ready", STOPPING_IN_BACKGROUND: "stoppinginbackground", STOPPING: "stopping" });var Nb = function Nb() {
					L.call(this);this.A = null;O(this.a, "Opening net websocket");var a = new Gb(!0);this.A && this.A.S();this.A = a;ab(this, ea(bb, this.A));K(this.A, "d", this.cd, !1, this);K(this.A, "a", this.ad, !1, this);K(this.A, "b", this.sb, !1, this);K(this.A, "c", this.vb, !1, this);
				};t(Nb, L);var Ob = function Ob(a, b, c) {
					I.call(this, a);this.senderId = b;this.data = c;
				};t(Ob, I);Nb.prototype.a = F("cast.receiver.IpcChannel");Nb.prototype.gb = function () {
					return "IpcChannel";
				};
				var Pb = function Pb(a, b) {
					Cb(a.a, a.gb() + " " + b);a.dispatchEvent(new Ob("urn:x-cast:com.google.cast.system", "SystemSender", JSON.stringify({ type: b })));
				};g = Nb.prototype;g.cd = function () {
					Pb(this, "opened");
				};g.ad = function () {
					Pb(this, "closed");
				};g.sb = function () {
					Pb(this, "error");
				};g.vb = function (a) {
					Cb(this.a, "Received message: " + a.message);var b = (a = JSON.parse(a.message)) && a.namespace;a && b && a.senderId && a.data ? this.dispatchEvent(new Ob(b, a.senderId, a.data)) : N(this.a, this.gb() + " Message received is invalid");
				};
				g.open = function () {
					O(this.a, "Opening message bus websocket");this.A.open("ws://localhost:" + Mb("port-for-web-server") + "/v2/ipc");
				};g.close = function () {
					O(this.a, "Closing message bus websocket");this.A.close();
				};g.wa = function () {
					return this.A.wa();
				};g.send = function (a, b, c) {
					if (!this.wa) throw Error("Underlying websocket is not open");a = JSON.stringify({ namespace: a, senderId: b, data: c });Cb(this.a, "IPC message sent: " + a);this.A.send(a);
				};g.l = function () {
					Nb.D.l.call(this);M(this.a, E, "Disposed " + this.gb());
				};var Q = function Q(a, b, c, d) {
					L.call(this);this.K = a;this.V = b;this.nb = !1;this.Ba = d || "STRING";this.onMessage = null;this.serializeMessage = this.Ic;this.deserializeMessage = this.pc;this.u = {};for (a = 0; a < c.length; a++) this.u[c[a]] = null;this.V.ma(this.K, this.ub, !1, this);
				};t(Q, L);r("cast.receiver.CastMessageBus", Q);Q.MessageType = { STRING: "STRING", JSON: "JSON", CUSTOM: "CUSTOM" };Q.EventType = { MESSAGE: "message" };var Qb = function Qb(a, b, c) {
					I.call(this, a);this.senderId = b;this.data = c;
				};t(Qb, I);Q.Event = Qb;Q.prototype.a = F("cast.receiver.CastMessageBus");
				Q.prototype.J = function () {
					return "CastMessageBus[" + this.K + "]";
				};Q.prototype.T = function () {
					return this.K;
				};Q.prototype.getNamespace = Q.prototype.T;Q.prototype.Kb = function () {
					return this.Ba;
				};Q.prototype.getMessageType = Q.prototype.Kb;Q.prototype.ub = function (a) {
					M(this.a, E, "Dispatching CastMessageBus message");var b = "STRING" == this.Ba ? a.data : this.deserializeMessage(a.data);this.dispatchEvent(new Qb(a.senderId, a.senderId, b));a = new Qb("message", a.senderId, b);if (this.onMessage) this.onMessage(a);this.dispatchEvent(a);
				};
				Q.prototype.send = function (a, b) {
					this.nb || "urn:x-cast:com.google.cast.system" == this.K || Bb(this.a, "Application should not send requests before the system is ready (they will be ignored)");if ("STRING" == this.Ba) {
						if (!ba(b)) throw Error("Wrong argument, CastMessageBus type is STRING");this.V.send(this.K, a, b);
					} else this.V.send(this.K, a, this.serializeMessage(b));
				};Q.prototype.send = Q.prototype.send;Q.prototype.Eb = function (a) {
					this.send("*:*", a);
				};Q.prototype.broadcast = Q.prototype.Eb;
				Q.prototype.Lc = function (a) {
					if (a in this.u) return this.u[a] || (this.u[a] = new P(this, a)), this.u[a];throw Error("Requested a socket for a disconnected sender: " + a);
				};Q.prototype.getCastChannel = Q.prototype.Lc;Q.prototype.Ic = function (a) {
					if ("JSON" != this.Ba) throw Error("Unexpected message type for JSON serialization");return JSON.stringify(a);
				};Q.prototype.pc = function (a) {
					if ("JSON" != this.Ba) throw Error("Unexpected message type for JSON serialization");return JSON.parse(a);
				};
				Q.prototype.l = function () {
					Q.D.l.call(this);for (var a in this.u) this.u[a] && this.u[a].close();this.u = {};M(this.a, E, "Disposed " + this.J());
				};var Rb = function Rb() {
					this.Xb = fa();
				},
				    Sb = new Rb();Rb.prototype.set = function (a) {
					this.Xb = a;
				};Rb.prototype.reset = function () {
					this.set(fa());
				};Rb.prototype.get = function () {
					return this.Xb;
				};var Tb = function Tb(a) {
					this.fd = a || "";this.sd = Sb;
				};g = Tb.prototype;g.Db = !0;g.ec = !0;g.qd = !0;g.pd = !0;g.fc = !1;g.rd = !1;var Ub = function Ub(a) {
					return 10 > a ? "0" + a : String(a);
				},
				    Vb = function Vb(a, b) {
					var c = (a.hc - b) / 1E3,
					    d = c.toFixed(3),
					    e = 0;if (1 > c) e = 2;else for (; 100 > c;) e++, c *= 10;for (; 0 < e--;) d = " " + d;return d;
				},
				    Wb = function Wb(a) {
					Tb.call(this, a);
				};t(Wb, Tb);var Xb = function Xb() {
					this.gd = _p(this.jc, this);this.Ia = new Wb();this.Ia.ec = !1;this.Ia.fc = !1;this.Nb = this.Ia.Db = !1;this.Ob = "";this.Jc = {};
				};
				Xb.prototype.jc = function (a) {
					if (!this.Jc[a.Pb]) {
						var b;b = this.Ia;var c = [];c.push(b.fd, " ");if (b.ec) {
							var d = new Date(a.hc);c.push("[", Ub(d.getFullYear() - 2E3) + Ub(d.getMonth() + 1) + Ub(d.getDate()) + " " + Ub(d.getHours()) + ":" + Ub(d.getMinutes()) + ":" + Ub(d.getSeconds()) + "." + Ub(Math.floor(d.getMilliseconds() / 10)), "] ");
						}b.qd && c.push("[", Vb(a, b.sd.get()), "s] ");b.pd && c.push("[", a.Pb, "] ");b.rd && c.push("[", a.hb().name, "] ");c.push(a.Rb);b.fc && (d = a.fb) && c.push("\n", d instanceof Error ? d.message : d.toString());b.Db && c.push("\n");
						b = c.join("");if (c = Yb) switch (a.hb()) {case Oa:
								Zb(c, "info", b);break;case Pa:
								Zb(c, "error", b);break;case Qa:
								Zb(c, "warn", b);break;default:
								Zb(c, "debug", b);} else this.Ob += b;
					}
				};var Yb = h.console,
				    Zb = function Zb(a, b, c) {
					if (a[b]) a[b](c);else a.log(c);
				};var R = function R() {
					L.call(this);if (this.Fb = new Xb()) {
						var a = this.Fb;if (1 != a.Nb) {
							$a();var b = Za,
							    c = a.gd;b.ua || (b.ua = []);b.ua.push(c);a.Nb = !0;
						}
					}this.o = xa($b);this.Ca = !1;this.V = new Nb();this.H = {};this.da = new Q("urn:x-cast:com.google.cast.system", this.V, wa(this.H), "JSON");ab(this, ea(bb, this.da));this.Gb = this.Ga = null;this.Mb = !1;this.ya = this.za = null;this.Sa = !0;this.Yc = "1.11";this.ea = "notstarted";this.v = {};this.onStandbyChanged = this.onVisibilityChanged = this.onSystemVolumeChanged = this.onSenderDisconnected = this.onSenderConnected = this.onShutdown = this.onReady = null;K(this.da, "SystemSender", this.dd, !1, this);K(window, "unload", this.xb, !1, this);K(document, "visibilitychange", this.Tb, !1, this);M(this.a, Oa, "Version: 2.0.0.0040");
				};t(R, L);r("cast.receiver.CastReceiverManager", R);R.Ib = function () {
					return R.kb ? R.kb : R.kb = new R();
				};R.getInstance = R.Ib;var ac = ["A59513CE", "67FE9D30", "B03290DF", "E8C28D3C"];
				R.EventType = { READY: "ready", SHUTDOWN: "shutdown", SENDER_CONNECTED: "senderconnected", SENDER_DISCONNECTED: "senderdisconnected", ERROR: "error", SYSTEM_VOLUME_CHANGED: "systemvolumechanged", VISIBILITY_CHANGED: "visibilitychanged", STANDBY_CHANGED: "standbychanged" };var S = function S(a, b) {
					I.call(this, a);this.data = b;
				};t(S, I);R.Event = S;r("cast.receiver.system.DisconnectReason", { REQUESTED_BY_SENDER: "requested_by_sender", ERROR: "error", UNKNOWN: "unknown" });
				var bc = function bc(a, b, c) {
					S.call(this, "senderdisconnected", a);this.senderId = a;this.userAgent = b;this.reason = c;
				};t(bc, S);R.SenderDisconnectedEvent = bc;var cc = function cc(a, b) {
					S.call(this, "senderconnected", a);this.senderId = a;this.userAgent = b;
				};t(cc, S);R.SenderConnectedEvent = cc;var dc = function dc(a) {
					S.call(this, "visibilitychanged", a);this.isVisible = a;
				};t(dc, S);R.VisibilityChangedEvent = dc;var ec = function ec(a) {
					S.call(this, "standbychanged", null);this.isStandby = a;
				};t(ec, S);R.StandbyChangedEvent = ec;
				var fc = function fc(a) {
					S.call(this, "systemvolumechanged", a);this.data = a;
				};t(fc, S);R.SystemVolumeChangedEvent = fc;var gc = function gc(a) {
					S.call(this, "ready", a);this.data = a;
				};t(gc, S);R.ReadyEvent = gc;var hc = function hc() {
					S.call(this, "shutdown", null);
				};t(hc, S);R.ShutdownEvent = hc;R.Config = function () {
					this.disableChromecastAppFiltering = this.dialData = this.maxInactivity = this.statusText = void 0;
				};var $b = { maxInactivity: 10 };R.prototype.a = F("cast.receiver.CastReceiverManager");R.prototype.J = function () {
					return "CastReceiverManager";
				};
				R.prototype.start = function (a) {
					if (a) {
						if (!a) throw Error("Cannot validate undefined config.");if (void 0 != a.maxInactivity && 5 > a.maxInactivity) throw Error("config.maxInactivity must be greater than or equal to 5 seconds.");za(this.o, a || {});
					}this.Mb = !0;this.V.open();
				};R.prototype.start = R.prototype.start;R.prototype.stop = function () {
					this.S();window.close();
				};R.prototype.stop = R.prototype.stop;R.prototype.mb = function () {
					return "ready" == this.ea;
				};R.prototype.isSystemReady = R.prototype.mb;R.prototype.Tc = function () {
					return wa(this.H);
				};
				R.prototype.getSenders = R.prototype.Tc;R.prototype.Rc = function (a) {
					return this.H[a] ? xa(this.H[a]) : null;
				};R.prototype.getSender = R.prototype.Rc;R.prototype.Vc = function () {
					return null == this.za ? this.ya ? "notvisible" : "unknown" : this.za ? "visible" : "notvisible";
				};R.prototype.getVisibilityState = R.prototype.Vc;R.prototype.Uc = function () {
					return null == this.ya ? this.za ? "notstandby" : "unknown" : this.ya ? "standby" : "notstandby";
				};R.prototype.getStandbyState = R.prototype.Uc;
				R.prototype.Lb = function () {
					"notstarted" == this.ea && (this.ea = /[&?]google_cast_bg=true(&|$)/.test(window.location.search) ? "startinginbackground" : "starting");return this.ea;
				};R.prototype.getSystemState = R.prototype.Lb;R.prototype.Kc = function () {
					return this.Ga;
				};R.prototype.getApplicationData = R.prototype.Kc;R.prototype.Nc = function () {
					return this.Gb;
				};R.prototype.getDeviceCapabilities = R.prototype.Nc;R.prototype.jd = function (a) {
					this.mb() ? ic(this, a) : this.o.statusText != a && (this.o.statusText = a, this.Ca = !0);
				};
				R.prototype.setApplicationState = R.prototype.jd;R.prototype.ld = function (a, b) {
					this.mb() ? ic(this, a, b) : (void 0 != a && a != this.o.statusText && (this.o.statusText = a, this.Ca = !0), void 0 != b && b != this.o.dialData && (this.o.dialData = b, this.Ca = !0));
				};R.prototype.setLegacyApplicationState = R.prototype.ld;R.prototype.nd = function (a) {
					if (0 > a || 1 < a) throw Error("Invalid level value");this.da.send("SystemSender", { type: "setvolume", level: a });
				};R.prototype.setSystemVolumeLevel = R.prototype.nd;
				R.prototype.od = function (a) {
					this.da.send("SystemSender", { type: "setvolume", muted: a });
				};R.prototype.setSystemVolumeMuted = R.prototype.od;var ic = function ic(a, b, c) {
					var d = { type: "setappstate" };void 0 != b && (d.statusText = b);void 0 != c && (d.dialData = c);a.da.send("SystemSender", d);
				};R.prototype.bc = function (a) {
					this.da.send("SystemSender", { type: "startheartbeat", maxInactivity: a });
				};R.prototype.setInactivityTimeout = R.prototype.bc;
				R.prototype.Hb = function (a, b) {
					if ("urn:x-cast:com.google.cast.system" == a) throw Error("Protected namespace");if (0 != a.lastIndexOf("urn:x-cast:", 0)) throw Error("Invalid namespace prefix");if (!this.v[a]) {
						if (this.Mb) throw Error("New namespaces can not be requested after start has been called");this.v[a] = new Q(a, this.V, wa(this.H), b);ab(this, ea(bb, this.v[a]));
					}if (b && this.v[a].Kb() != b) throw Error("Invalid messageType for the namespace");return this.v[a];
				};R.prototype.getCastMessageBus = R.prototype.Hb;
				R.prototype.dd = function (a) {
					a = a.data;switch (a.type) {case "opened":
							O(this.a, "Underlying message bus is open");var b = wa(this.v),
							    c = this.o.statusText;a = this.o.dialData;var d = { type: "ready" };c && (d.statusText = c);a && (d.dialData = a);d.activeNamespaces = b;d.version = "2.0.0";d.messagesVersion = "1.0";this.da.send("SystemSender", d);this.o.maxInactivity && this.bc(this.o.maxInactivity);break;case "closed":
							this.xb();break;case "error":
							this.dispatchEvent("error");break;case "ready":
							b = a.launchingSenderId;c = wa(this.v);this.Va = a.version;this.Sa = !jc(this, this.Yc);var e = a.deviceCapabilities;this.Gb = e ? xa(e) : {};this.Ga = { id: a.applicationId, name: a.applicationName, sessionId: a.sessionId, namespaces: c, launchingSenderId: b };0 <= y(ac, this.Ga.id) && (this.o.disableChromecastAppFiltering = !0);this.ea = "ready";for (d in this.v) this.v[d].nb = !0;this.Ca && (this.Ca = !1, ic(this, this.o.statusText, this.o.dialData));O(this.a, "Dispatching CastReceiverManager system ready event");b = new gc(this.Ga);if (this.onReady) this.onReady(b);this.dispatchEvent(b);break;
						case "senderconnected":
							b = { id: a.senderId, userAgent: a.userAgent };if (this.o.disableChromecastAppFiltering || !v(b.id.toLowerCase(), "com.google.android.apps.chromecast.app")) {
								O(this.a, "Dispatching CastReceiverManager sender connected event [" + b.id + "]");b.id in this.H && N(this.a, "Unexpected connected message for already connected sender: " + b.id);this.H[b.id] = b;a = new cc(b.id, b.userAgent);for (c in this.v) d = this.v[c], e = b.id, e in d.u ? N(d.a, "Unexpected sender already registered [" + d.K + ", " + e + "]") : (O(d.a, "Registering sender [" + d.K + ", " + e + "]"), d.u[e] = null);if (this.onSenderConnected) this.onSenderConnected(a);this.dispatchEvent(a);
							}break;case "senderdisconnected":
							c = a.senderId;if (this.o.disableChromecastAppFiltering || !v(c.toLowerCase(), "com.google.android.apps.chromecast.app")) {
								switch (a.reason) {case "closed_by_peer":
										a = "requested_by_sender";break;case "transport_invalid_message":
										a = "error";break;default:
										a = "unknown";}O(this.a, "Dispatching sender disconnected event [" + c + "] Reason: " + a);if (c in this.H) {
									d = this.H[c].userAgent;delete this.H[c];
									a = new bc(c, d, a);for (b in this.v) d = this.v[b], e = c, e in d.u && (O(d.a, "Unregistering sender [" + d.K + ", " + e + "]"), d.u[e] && d.u[e].close(), delete d.u[e]);if (this.onSenderDisconnected) this.onSenderDisconnected(a);this.dispatchEvent(a);
								} else N(this.a, "Unknown sender disconnected: " + c);
							}break;case "volumechanged":
							b = { level: a.level, muted: a.muted };O(this.a, "Dispatching system volume changed event [" + b.level + ", " + b.muted + "]");b = new fc(b);if (this.onSystemVolumeChanged) this.onSystemVolumeChanged(b);this.dispatchEvent(b);
							break;case "visibilitychanged":
							this.Sa || (b = a.visible, kc(this, k(b) ? b : null));break;case "standbychanged":
							if (!this.Sa && (b = a.standby, b = k(b) ? b : null, b != this.ya)) {
								O(this.a, "Dispatching standby changed event " + b);this.ya = b;b = new ec(!0 === b);if (this.onStandbyChanged) this.onStandbyChanged(b);this.dispatchEvent(b);
							}break;default:
							throw Error("Unexpected message type: " + a.type);}
				};
				var kc = function kc(a, b) {
					if (b == a.za) O(a.a, "Ignoring visibility changed event, state is already " + b);else {
						O(a.a, "Dispatching visibility changed event " + b);a.za = b;var c = new dc(!1 !== b);if (a.onVisibilityChanged) a.onVisibilityChanged(c);a.dispatchEvent(c);
					}
				};R.prototype.Tb = function () {
					this.Sa && kc(this, "visible" == document.visibilityState);
				};
				R.prototype.xb = function () {
					O(this.a, "Dispatching shutdown event");this.Lb();this.ea = "startinginbackground" == this.ea ? "stoppinginbackground" : "stopping";for (var a in this.v) this.v[a].nb = !1;a = new hc();if (this.onShutdown) this.onShutdown(a);this.dispatchEvent(a);
				};
				var jc = function jc(a, b) {
					if (!b) return N(a.a, "Version not provided"), !1;if (!a.Va) return N(a.a, "No System Version"), !1;var c = b.split(".");if (!c.length) return N(a.a, "Version provided is not valid: " + b), !1;var d = a.Va.split(".");if (!d.length) return N(a.a, "System Version format is not valid " + a.Va), !1;for (var e = 0; e < c.length; e++) {
						var f = parseInt(c[e], 10);if (isNaN(f)) return N(a.a, "Version is not numeric: " + b), !1;var l = d.length > e ? parseInt(d[e], 10) : 0;if (isNaN(l)) return N(a.a, "System Version is not numeric: " + a.Va), !1;if (f > l) return !1;
					}return !0;
				};R.prototype.l = function () {
					R.D.l.call(this);window && ub(window, "unload", this.xb, !1, this);document && ub(document, "visibilitychange", this.Tb, !1, this);delete R.kb;Cb(this.a, "Disposed " + this.J());
				};var lc = Boolean(cast.__platform__ && cast.__platform__.crypto);r("cast.receiver.cryptokeys.getKeyByName", Boolean(cast.__platform__ && cast.__platform__.cryptokeys) ? cast.__platform__.cryptokeys.getKeyByName : window.cryptokeys && window.cryptokeys.getKeyByName);r("cast.receiver.crypto.decrypt", lc ? cast.__platform__.crypto.decrypt : window.crypto.subtle.decrypt);r("cast.receiver.crypto.encrypt", lc ? cast.__platform__.crypto.encrypt : window.crypto.subtle.encrypt);
				r("cast.receiver.crypto.sign", lc ? cast.__platform__.crypto.sign : window.crypto.subtle.sign);r("cast.receiver.crypto.unwrapKey", lc ? cast.__platform__.crypto.unwrapKey : window.crypto.subtle.unwrapKey);r("cast.receiver.crypto.verify", lc ? cast.__platform__.crypto.verify : window.crypto.subtle.verify);r("cast.receiver.crypto.wrapKey", lc ? cast.__platform__.crypto.wrapKey : window.crypto.subtle.wrapKey);var mc = function mc(a, b) {
					this.a = a;this.c = b;this.eb = function () {};this.cb = function () {};this.ob = function () {};this.ja = 0;this.L = this.ga = null;this.Wb = 0;this.B = this.F = null;this.xa = !1;this.Ka = !0;K(this.c, "error", this.rb, !1, this);K(this.c, "ended", this.Pa, !1, this);K(this.c, "loadedmetadata", this.wb, !1, this);O(this.a, "Using default Player");
				};g = mc.prototype;g.Vb = function (a, b, c, d) {
					nc(this);this.Ka = a;this.ja = b;this.Wb = d || 0;this.L = c || null;
				};g.rb = function (a) {
					nc(this);this.eb(a);
				};g.Pa = function () {
					nc(this);this.cb();
				};
				g.wb = function () {
					this.F && this.B && oc(this.F, this.B);this.ob();
				};g.registerErrorCallback = function (a) {
					this.eb = a;
				};g.registerEndedCallback = function (a) {
					this.cb = a;
				};g.registerLoadCallback = function (a) {
					this.ob = a;
				};g.unregisterErrorCallback = function () {
					this.eb = function () {};
				};g.unregisterEndedCallback = function () {
					this.cb = function () {};
				};g.unregisterLoadCallback = function () {
					this.ob = function () {};
				};
				var pc = function pc(a) {
					var b = a.c.duration;if (isNaN(b) || null == a.L) return b;if (null != a.ga) return a.ga;if (0 <= a.L) {
						var c = a.Wb + a.L;a.ga = Math.min(c, b);
					} else c = b + a.L, a.ga = Math.max(c, a.ja);return a.ga;
				},
				    nc = function nc(a) {
					null != a.L && (ub(a.c, "timeupdate", a.Ub, !1, a), a.ga = null, a.L = null);
				};mc.prototype.Ub = function () {
					qc(this);
				};var qc = function qc(a) {
					if (null == a.L) return !1;var b = pc(a);return isNaN(b) ? !1 : a.c.currentTime >= b ? (a.Pa(), !0) : !1;
				};g = mc.prototype;
				g.load = function (a, b, c, d, e) {
					this.xa = !1;d && d.tracks && this.c && (this.F && this.F.S(), this.F = new rc(this.c, d.tracks, d.activeTrackIds || [], d.textTrackStyle || null));null != this.L && K(this.c, "timeupdate", this.Ub, !1, this);e || (this.ja = c && 0 < c ? c : 0, O(this.a, "Load - contentId: " + a + " autoplay: " + b + " time: " + this.ja), this.c.autoplay = !1, a && (this.c.src = a), this.c.autoplay = b, this.c.load());
				};
				g.reset = function () {
					this.xa = !1;this.F && (this.F.S(), this.F = null);this.activeTrackIds = null;this.c.removeAttribute("src");this.ja = 0;this.c.load();nc(this);
				};g.play = function () {
					this.xa = !1;this.c.play();
				};g.seek = function (a, b) {
					this.c.currentTime != a && (this.c.currentTime = a);qc(this) || ("PLAYBACK_START" == b && this.c.paused ? this.c.play() : "PLAYBACK_PAUSE" != b || this.c.paused || this.c.pause());
				};g.pause = function () {
					this.xa = !0;this.c.pause();
				};
				g.getState = function () {
					null == this.Ka && (this.Ka = this.c.autoplay);return this.c.paused || isNaN(this.c.duration) ? this.c.duration && (this.c.currentTime || 0 == this.c.currentTime) && this.c.currentTime < pc(this) ? this.c.currentTime == this.ja && this.Ka && !this.xa ? "BUFFERING" : "PAUSED" : "IDLE" : "PLAYING";
				};g.getCurrentTimeSec = function () {
					var a = pc(this);return isNaN(a) ? this.c.currentTime : this.c.currentTime < a ? this.c.currentTime : a;
				};g.getDurationSec = function () {
					return pc(this);
				};
				g.getVolume = function () {
					return { level: this.c.volume, muted: this.c.muted };
				};g.setVolume = function (a) {
					void 0 != a.level && (this.c.volume = a.level);void 0 != a.muted && (this.c.muted = a.muted);
				};g.editTracksInfo = function (a) {
					if (this.F) {
						if (a.textTrackStyle) {
							var b = this.F,
							    c = a.textTrackStyle;sc(b);tc(b, c);
						}a.activeTrackIds && oc(this.F, a.activeTrackIds);this.B = a.activeTrackIds || [];
					}
				};var uc = function uc(a) {
					G.call(this);this.ta = a;this.Aa = {};
				};t(uc, G);var vc = [];g = uc.prototype;g.ma = function (a, b, c, d) {
					"array" != m(b) && (b && (vc[0] = b.toString()), b = vc);for (var e = 0; e < b.length; e++) {
						var f = K(a, b[e], c || this.handleEvent, d || !1, this.ta || this);if (!f) break;this.Aa[f.key] = f;
					}return this;
				};
				g.Cb = function (a, b, c, d, e) {
					if ("array" == m(b)) for (var f = 0; f < b.length; f++) this.Cb(a, b[f], c, d, e);else c = c || this.handleEvent, e = e || this.ta || this, c = pb(c), d = !!d, b = a && a[gb] ? a.sa(b, c, d, e) : a ? (a = qb(a)) ? a.sa(b, c, d, e) : null : null, b && (vb(b), delete this.Aa[b.key]);return this;
				};g.zb = function () {
					ua(this.Aa, function (a, b) {
						this.Aa.hasOwnProperty(b) && vb(a);
					}, this);this.Aa = {};
				};g.l = function () {
					uc.D.l.call(this);this.zb();
				};g.handleEvent = function () {
					throw Error("EventHandler.handleEvent not implemented");
				};var wc = { ud: "persistent-release-message" },
				    xc = new Uint8Array([43, 248, 102, 128, 198, 229, 78, 36, 190, 35, 15, 129, 90, 96, 110, 178]),
				    T = function T(a, b) {
					L.call(this);this.Xc = b;this.C = a.createSession("persistent-license");this.sessionId = "";this.expiration = this.C.expiration;this.closed = this.C.closed;this.keyStatuses = this.C.keyStatuses;this.ta = new uc(this);ab(this, ea(bb, this.ta));
				};t(T, L);
				r("cast.receiver.eme.KeySession.createSession", function (a, b) {
					a: {
						for (var c in wc) if (wc[c] === b) break a;throw Error("Unknown key session type: " + b);
					}c = new T(a, b);c.ta.ma(c.C, "message", c.Yb).ma(c.C, "keystatuseschange", c.Yb);return c;
				});
				T.prototype.generateRequest = function (a, b) {
					if ("persistent-release-message" == this.Xc) {
						if ("cenc" != a) throw Error("Only cenc initDataType is supported for persistent-release-message session type.");var c = new Uint8Array([0, 0, 0, 0, 112, 115, 115, 104, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2]);c.set(xc, 12);new DataView(c.buffer).setUint32(0, c.length);var d = new Uint8Array(b.byteLength + c.byteLength);d.set(new Uint8Array(b), 0);d.set(c, b.byteLength);b = d;
					}return this.C.generateRequest(a, b).then(_p(function () {
						this.sessionId = this.C.sessionId;
					}, this));
				};T.prototype.generateRequest = T.prototype.generateRequest;T.prototype.load = function (a) {
					return this.C.load(a);
				};T.prototype.load = T.prototype.load;T.prototype.update = function (a) {
					return this.C.update(a);
				};T.prototype.update = T.prototype.update;T.prototype.close = function () {
					return this.C.close();
				};T.prototype.close = T.prototype.close;T.prototype.remove = function () {
					return this.C.remove();
				};T.prototype.remove = T.prototype.remove;
				T.prototype.Yb = function (a) {
					var b = new I(a.type);za(b, a.ha);b.target = this;this.dispatchEvent(b);
				};var U = F("cast");r("cast.receiver.logger", U);r("cast.receiver.LoggerLevel", { DEBUG: 0, VERBOSE: 500, INFO: 800, WARNING: 900, ERROR: 1E3, NONE: 1500 });U.cc = function (a) {
					U && U.Bb(Wa(a));
				};U.setLevelValue = U.cc;if (U) {
					var yc = parseInt(Mb("log-level-cast-receiver"), 10);U.cc(yc || 1E3);
				};var zc = function zc() {
					this.I = [];this.R = [];
				};zc.prototype.enqueue = function (a) {
					this.R.push(a);
				};var Ac = function Ac(a) {
					0 == a.I.length && (a.I = a.R, a.I.reverse(), a.R = []);return a.I.pop();
				},
				    Bc = function Bc(a) {
					return 0 == a.I.length && 0 == a.R.length;
				};zc.prototype.clear = function () {
					this.I = [];this.R = [];
				};zc.prototype.contains = function (a) {
					return 0 <= y(this.I, a) || 0 <= y(this.R, a);
				};zc.prototype.remove = function (a) {
					var b = pa(this.I, a);if (0 > b) return ra(this.R, a);qa(this.I, b);return !0;
				};r("cast.receiver.media.MEDIA_NAMESPACE", "urn:x-cast:com.google.cast.media");r("cast.receiver.media.StreamType", { BUFFERED: "BUFFERED", LIVE: "LIVE", NONE: "NONE" });r("cast.receiver.media.ErrorType", { INVALID_PLAYER_STATE: "INVALID_PLAYER_STATE", LOAD_FAILED: "LOAD_FAILED", LOAD_CANCELLED: "LOAD_CANCELLED", INVALID_REQUEST: "INVALID_REQUEST" });r("cast.receiver.media.ErrorReason", { INVALID_COMMAND: "INVALID_COMMAND", INVALID_PARAMS: "INVALID_PARAMS", INVALID_MEDIA_SESSION_ID: "INVALID_MEDIA_SESSION_ID", DUPLICATE_REQUEST_ID: "DUPLICATE_REQUEST_ID" });
				r("cast.receiver.media.IdleReason", { CANCELLED: "CANCELLED", INTERRUPTED: "INTERRUPTED", FINISHED: "FINISHED", ERROR: "ERROR" });r("cast.receiver.media.SeekResumeState", { PLAYBACK_START: "PLAYBACK_START", PLAYBACK_PAUSE: "PLAYBACK_PAUSE" });r("cast.receiver.media.PlayerState", { IDLE: "IDLE", PLAYING: "PLAYING", PAUSED: "PAUSED", BUFFERING: "BUFFERING" });var Cc = function Cc() {
					this.contentId = "";this.streamType = "NONE";this.contentType = "";this.customData = this.textTrackStyle = this.tracks = this.duration = this.metadata = void 0;
				};
				r("cast.receiver.media.MediaInformation", Cc);var Dc = function Dc() {
					this.muted = this.level = void 0;
				};r("cast.receiver.media.Volume", Dc);r("cast.receiver.media.MediaStatus", function () {
					this.mediaSessionId = 0;this.media = void 0;this.playbackRate = 1;this.playerState = "IDLE";this.idleReason = void 0;this.supportedMediaCommands = this.currentTime = 0;this.volume = { level: 0, muted: !1 };this.activeTrackIds = null;this.customData = this.preloadedItemId = this.loadingItemId = this.currentItemId = void 0;
				});
				r("cast.receiver.media.Command", { PAUSE: 1, SEEK: 2, STREAM_VOLUME: 4, STREAM_MUTE: 8, ALL_BASIC_MEDIA: 15, QUEUE_NEXT: 64, QUEUE_PREV: 128 });r("cast.receiver.media.TrackType", { TEXT: "TEXT", AUDIO: "AUDIO", VIDEO: "VIDEO" });r("cast.receiver.media.TextTrackType", { SUBTITLES: "SUBTITLES", CAPTIONS: "CAPTIONS", DESCRIPTIONS: "DESCRIPTIONS", CHAPTERS: "CHAPTERS", METADATA: "METADATA" });r("cast.receiver.media.TextTrackEdgeType", { NONE: "NONE", OUTLINE: "OUTLINE", DROP_SHADOW: "DROP_SHADOW", RAISED: "RAISED", DEPRESSED: "DEPRESSED" });
				r("cast.receiver.media.TextTrackWindowType", { NONE: "NONE", NORMAL: "NORMAL", ROUNDED_CORNERS: "ROUNDED_CORNERS" });r("cast.receiver.media.TextTrackFontGenericFamily", { SANS_SERIF: "SANS_SERIF", MONOSPACED_SANS_SERIF: "MONOSPACED_SANS_SERIF", SERIF: "SERIF", MONOSPACED_SERIF: "MONOSPACED_SERIF", CASUAL: "CASUAL", CURSIVE: "CURSIVE", SMALL_CAPITALS: "SMALL_CAPITALS" });r("cast.receiver.media.TextTrackFontStyle", { NORMAL: "NORMAL", BOLD: "BOLD", BOLD_ITALIC: "BOLD_ITALIC", ITALIC: "ITALIC" });
				r("cast.receiver.media.Track", function (a, b) {
					this.trackId = a;this.trackContentType = this.trackContentId = void 0;this.type = b;this.customData = this.subtype = this.language = this.name = void 0;
				});r("cast.receiver.media.TextTrackStyle", function () {
					this.customData = this.fontStyle = this.fontGenericFamily = this.fontFamily = this.windowRoundedCornerRadius = this.windowColor = this.windowType = this.edgeColor = this.edgeType = this.backgroundColor = this.foregroundColor = this.fontScale = void 0;
				});
				r("cast.receiver.media.TracksInfo", function () {
					this.textTrackStyle = this.activeTrackIds = this.tracks = void 0;
				});r("cast.receiver.media.repeatMode", { REPEAT_OFF: "REPEAT_OFF", REPEAT_ALL: "REPEAT_ALL", REPEAT_SINGLE: "REPEAT_SINGLE", REPEAT_ALL_AND_SHUFFLE: "REPEAT_ALL_AND_SHUFFLE" });var Ec = function Ec(a) {
					return "REPEAT_OFF" == a || "REPEAT_ALL" == a || "REPEAT_SINGLE" == a || "REPEAT_ALL_AND_SHUFFLE" == a;
				};r("cast.receiver.media.GetStatusOptions", { NO_METADATA: 1, NO_QUEUE_ITEMS: 2 });var Fc = function Fc(a) {
					this.itemId = a;this.customData = this.activeTrackIds = this.preloadTime = this.playbackDuration = this.startTime = this.autoplay = this.media = void 0;
				};r("cast.receiver.media.QueueItem", Fc);Fc.prototype.clone = function (a) {
					var b = new Fc(this.itemId);b.autoplay = this.autoplay;b.startTime = this.startTime;b.playbackDuration = this.playbackDuration;b.preloadTime = this.preloadTime;b.activeTrackIds = this.activeTrackIds;b.customData = this.customData;if (!k(a) || a) b.media = this.media;return b;
				};
				var V = function V(a, b, c) {
					this.b = a;this.aa = b;this.i = c;
				};r("cast.receiver.MediaQueue", V);V.prototype.a = F("cast.receiver.MediaQueue");V.prototype.Jb = function (a) {
					if (!k(a) || a) return this.b;for (var b = [], c = 0; c < this.b.length; c++) b.push(this.b[c].clone(a));return b;
				};V.prototype.getItems = V.prototype.Jb;V.prototype.Oc = function () {
					return this.b.length;
				};V.prototype.getLength = V.prototype.Oc;V.prototype.jb = function () {
					return this.aa;
				};V.prototype.getRepeatMode = V.prototype.jb;
				V.prototype.Mc = function () {
					return 0 > this.i ? null : this.b[this.i].itemId;
				};V.prototype.getCurrentItemId = V.prototype.Mc;V.prototype.ia = function () {
					return 0 > this.i ? null : this.b[this.i];
				};V.prototype.getCurrentItem = V.prototype.ia;
				var Gc = function Gc(a, b) {
					for (var c = [], d = 0; d < b.length; d++) for (var e = 0; e < a.b.length; e++) if (b[d] == a.b[e].itemId) {
						c.push(b[d]);break;
					}return c;
				},
				    Hc = function Hc(a) {
					return "REPEAT_ALL_AND_SHUFFLE" == a.aa;
				},
				    Ic = function Ic(a, b) {
					for (var c = 0; c < a.b.length; c++) if (b == a.b[c].itemId) return c;return -1;
				},
				    Jc = function Jc(a) {
					return "REPEAT_ALL_AND_SHUFFLE" == a.aa || "REPEAT_ALL" == a.aa;
				};V.prototype.reset = function () {
					this.i = -1;
				};
				var Kc = function Kc(a, b) {
					var c = Ic(a, b);if (-1 == c || a.i == c) return !1;a.i = c;return !0;
				},
				    Mc = function Mc(a, b, c) {
					if (0 > a.i) return "QUEUE_ENDED";b = a.i + b;var d = !1;b >= a.b.length ? (b = Jc(a) ? b % a.b.length : -1, d = !0) : 0 > b && (b = Jc(a) ? a.b.length + (b + 1) % a.b.length - 1 : 0, d = !0);c && (a.i = b);return -1 == b ? "QUEUE_ENDED" : d ? Hc(a) ? (Lc(a), "QUEUE_SHUFFLED") : "QUEUE_LOOP" : "QUEUE_ACTIVE";
				},
				    Lc = function Lc(a) {
					var b = a.b.length,
					    c,
					    d;if (!(3 > a.b.length)) for (; 0 < b;) d = Math.floor(Math.random() * b), --b, c = a.b[d], a.b[d] = a.b[b], a.b[b] = c;
				};var Nc = /#(.)(.)(.)(.)/,
				    Pc = function Pc(a) {
					if (!Oc.test(a)) throw Error("'" + a + "' is not a valid alpha hex color");5 == a.length && (a = a.replace(Nc, "#$1$1$2$2$3$3$4$4"));a = a.toLowerCase();return [parseInt(a.substr(1, 2), 16), parseInt(a.substr(3, 2), 16), parseInt(a.substr(5, 2), 16), parseInt(a.substr(7, 2), 16) / 255];
				},
				    Oc = /^#(?:[0-9a-f]{4}){1,2}$/i,
				    Qc = function Qc(a) {
					var b = a.slice(0);b[3] = Math.round(1E3 * a[3]) / 1E3;return "rgba(" + b.join(",") + ")";
				};!Ea && !A || A && 9 <= La || Ea && B("1.9.1");A && B("9");var rc = function rc(a, b, c, d) {
					G.call(this);this.c = a;this.bb = this.Ua = null;this.P = [];this.ab = !1;this.Ya = "cast-captions-" + Math.floor(1E6 * Math.random()).toString();this.mc = "[" + this.Ya + '="true"]::cue ';this.nc = new RegExp(/^[\.'":%,;\s\-0-9a-z]+$/i);for (a = 0; a < b.length; a++) {
						var e = b[a].trackContentId;if ("TEXT" === b[a].type && e) {
							var f = b[a].trackContentType;if (0 == ja("vtt", e.substr(e.length - 3, 3)) || void 0 != f && 0 == ja(f, "text/vtt")) e = document.createElement("track"), e.src = b[a].trackContentId, e.id = b[a].trackId, e.label = b[a].name, e.srclang = b[a].language, e.kind = (b[a].subtype || "").toLowerCase(), this.P.push(e), this.c.appendChild(e);
						}
					}sc(this);d && tc(this, d);oc(this, c);
				};t(rc, G);rc.prototype.a = F("cast.receiver.TextTracksManager");rc.prototype.J = function () {
					return "TextTracksManager";
				};
				var oc = function oc(a, b) {
					for (var c = 0; c < a.P.length; c++) {
						var d = a.P[c].track;0 <= y(b, parseInt(a.P[c].id, 10)) ? d.mode = "showing" : (d.mode = "showing", d.mode = "disabled");
					}
				},
				    Rc = function Rc(a) {
					a.bb && (a.c.removeAttribute(a.Ya), document.head.removeChild(a.bb), a.Ua = null);
				},
				    Sc = function Sc(a) {
					a.ab && (a.c.removeAttribute("crossorigin"), a.ab = !1);
				},
				    W = function W(a, b, c) {
					!0 === c || a.nc.test(b) ? a.Ua.insertRule(a.mc + "{ " + b + " }", a.Ua.cssRules.length) : Bb(a.a, "Invalid css cue: " + b);
				},
				    sc = function sc(a) {
					Rc(a);Sc(a);var b = document,
					    c = b.createElement("STYLE");
					c.type = "text/css";b.getElementsByTagName("HEAD")[0].appendChild(c);c.styleSheet ? c.styleSheet.cssText = "" : c.appendChild(b.createTextNode(""));a.bb = c;a.Ua = document.styleSheets[document.styleSheets.length - 1];W(a, "font-size: 4.1vh;");W(a, "font-family: monospace;");W(a, "font-style: normal;");W(a, "font-weight: normal;");W(a, "background-color: black;");W(a, "color: white;");a.c.setAttribute(a.Ya, !0);0 < a.P.length && !a.c.getAttribute("crossorigin") && (a.c.setAttribute("crossorigin", "anonymous"), a.ab = !0);
				},
				    Tc = function Tc(a, b, c) {
					var d;try {
						d = Qc(Pc(b));
					} catch (e) {
						Bb(a.a, "Invalid color: " + b);
					}if (d) switch ((a = "rgba(204, 204, 204, " + parseInt(b.substring(7, 9), 16) + ")", c)) {case "OUTLINE":
							return "text-shadow: 0 0 4px " + d + ", 0 0 4px " + d + ", 0 0 4px " + d + ", 0 0 4px " + d + ";";case "DROP_SHADOW":
							return "text-shadow: 0px 2px 3px " + d + ", 0px 2px 4px " + d + ", 0px 2px 5px " + d + ";";case "RAISED":
							return "text-shadow: 1px 1px " + d + ", 2px 2px " + d + ", 3px 3px " + d + ";";case "DEPRESSED":
							return "text-shadow: 1px 1px " + a + ", 0 1px " + a + ", -1px -1px " + d + ", 0 -1px " + d + ";";}return "";
				},
				    Uc = function Uc(a) {
					switch (a) {case "BOLD":
							return "font-weight: bold;";case "BOLD_ITALIC":
							return "font-style: italic; font-weight: bold;";case "ITALIC":
							return "font-style: italic;";}return "font-style: normal;";
				},
				    tc = function tc(a, b) {
					if (k(b.foregroundColor)) try {
						var c = Qc(Pc(b.foregroundColor));W(a, "color: " + c + ";", !0);
					} catch (d) {
						Bb(a.a, "Invalid color: " + b.foregroundColor);
					}if (k(b.backgroundColor)) try {
						var e = Qc(Pc(b.backgroundColor));W(a, "background-color: " + e + ";", !0);
					} catch (f) {
						Bb(a.a, "Invalid color: " + b.backgroundColor);
					}k(b.fontScale) && W(a, "font-size: " + 100 * b.fontScale + "%;");if (k(b.fontFamily) || k(b.fontGenericFamily)) {
						var c = b.fontFamily,
						    e = b.fontGenericFamily,
						    l = "font-family: ",
						    q = "";k(c) && (l += '"' + c + '"', q = ", ");if (k(e)) {
							var u;switch (e) {case "SANS_SERIF":
									u = '"Droid Sans", sans-serif';break;case "MONOSPACED_SANS_SERIF":
									u = '"Droid Sans Mono", monospace';break;case "SERIF":
									u = '"Droid Serif", serif';break;case "MONOSPACED_SERIF":
									u = '"Cutive Mono"';break;case "CASUAL":
									u = '"Short Stack"';break;case "CURSIVE":
									u = "Quintessential";break;case "SMALL_CAPITALS":
									u = '"Alegreya Sans SC"';}l += q + u;
						}W(a, l + ";");
					}k(b.fontStyle) && W(a, Uc(b.fontStyle));k(b.edgeType) && (u = k(b.foregroundColor) ? b.foregroundColor : "#FFFFFFFF", u = k(b.edgeColor) ? Tc(a, b.edgeColor, b.edgeType) : Tc(a, u, b.edgeType), W(a, u, !0));
				};rc.prototype.l = function () {
					rc.D.l.call(this);for (var a = 0; a < this.P.length; a++) this.c.removeChild(this.P[a]);this.P = [];Rc(this);Sc(this);M(this.a, E, "Disposed " + this.J());
				};var X = function X(a, b, c) {
					L.call(this);var d = R.Ib();this.pb = c || "local";this.Na = d.Hb("urn:x-cast:com.google.cast.media", "JSON");this.O = 0;this.ed = 1;this.td = b || 15;this.gc = this.Qb = this.la = this.ka = this.h = this.g = null;this.N = !1;this.B = this.U = this.m = null;this.La = !0;this.pa = null;this.Xa = this.lc.bind(this);this.f = null;this.Wa = !1;this.Y = null;this.qb = 1;this.Ta = -1;this.Ma = new zc();this.va = !1;this.customizedStatusCallback = this.oc;this.onLoad = this.vc;this.onPlay = this.yc;this.onSeek = this.Fc;this.onPause = this.xc;this.onStop = this.Hc;this.onSetVolume = this.Gc;this.onEditTracksInfo = this.qc;this.onQueueLoad = this.Bc;this.onQueueInsert = this.Ac;this.onQueueUpdate = this.Ec;this.onQueueRemove = this.Cc;this.onQueueReorder = this.Dc;this.onMetadataLoaded = this.wc;this.onLoadMetadataError = this.uc;this.onEnded = this.rc;this.onQueueEnded = this.zc;this.onAbort = aa;this.onError = this.sc;this.onMediaStatus = this.onLocalRequestError = aa;this.onCancelPreload = this.onPreload = null;this.onGetStatus = this.tc;this.dc(a);this.Na.onMessage = this.tb.bind(this);
					this.pa = Eb(this.Xa, 1E3);
				};t(X, L);r("cast.receiver.MediaManager", X);X.EventType = { LOAD: "load", STOP: "stop", PAUSE: "pause", PLAY: "play", SEEK: "seek", SET_VOLUME: "setvolume", GET_STATUS: "getstatus", EDIT_TRACKS_INFO: "edittracksinfo", QUEUE_LOAD: "queueload", QUEUE_INSERT: "queueinsert", QUEUE_UPDATE: "queueupdate", QUEUE_REMOVE: "queueremove", QUEUE_REORDER: "queuereorder", PRELOAD: "preload", CANCEL_PRELOAD: "cancelpreload" };var Y = function Y(a, b, c) {
					I.call(this, a);this.data = b;this.senderId = c;
				};t(Y, I);X.Event = Y;
				var Z = function Z() {
					this.requestId = 0;this.mediaSessionId = void 0;this.customData = null;
				};X.RequestData = Z;var Vc = function Vc() {
					Z.call(this);this.media = new Cc();this.autoplay = !1;this.currentTime = 0;this.activeTrackIds = void 0;
				};t(Vc, Z);X.LoadRequestData = Vc;var Wc = function Wc(a) {
					Vc.call(this);this.itemId = a;
				};t(Wc, Vc);X.PreloadRequestData = Wc;var Xc = function Xc() {
					Z.call(this);this.volume = new Dc();
				};t(Xc, Z);X.VolumeRequestData = Xc;var Yc = function Yc() {
					Z.call(this);this.textTrackStyle = this.activeTrackIds = void 0;
				};t(Yc, Z);
				X.EditTracksInfoData = Yc;var Zc = function Zc() {
					Z.call(this);this.resumeState = void 0;this.currentTime = 0;
				};t(Zc, Z);X.SeekRequestData = Zc;var $c = function $c() {
					Z.call(this);this.options = void 0;
				};t($c, Z);X.GetStatusRequestData = $c;var ad = function ad(a) {
					Z.call(this);this.repeatMode = void 0;this.items = a;this.currentTime = this.startIndex = void 0;
				};t(ad, Z);X.QueueLoadRequestData = ad;var bd = function bd(a) {
					Z.call(this);this.currentTime = this.currentItemId = this.currentItemIndex = this.insertBefore = void 0;this.items = a;
				};t(bd, Z);
				X.QueueInsertRequestData = bd;var cd = function cd() {
					Z.call(this);this.repeatMode = this.items = this.jump = this.currentTime = this.currentItemId = void 0;
				};t(cd, Z);X.QueueUpdateRequestData = cd;var dd = function dd(a) {
					Z.call(this);this.currentTime = this.currentItemId = void 0;this.itemIds = a;
				};t(dd, Z);X.QueueRemoveRequestData = dd;var ed = function ed(a) {
					Z.call(this);this.insertBefore = this.currentTime = this.currentItemId = void 0;this.itemIds = a;
				};t(ed, Z);X.QueueReorderRequestData = ed;
				X.LoadInfo = function (a, b) {
					this.message = a;this.senderId = b;
				};X.prototype.a = F("cast.receiver.MediaManager");X.prototype.J = function () {
					return "MediaManager";
				};X.prototype.Pc = function () {
					return this.h ? this.h.media || null : null;
				};X.prototype.getMediaInformation = X.prototype.Pc;X.prototype.Qc = function () {
					return this.f;
				};X.prototype.getMediaQueue = X.prototype.Qc;
				X.prototype.Wc = function (a, b, c, d, e) {
					a = new bd(a);a.insertBefore = b;a.currentItemIndex = c;a.currentItemId = d;a.currentTime = e;a.type = "QUEUE_INSERT";fd(this, this.pb, a);
				};X.prototype.insertQueueItems = X.prototype.Wc;X.prototype.hd = function (a, b, c) {
					a = new dd(a);a.currentItemId = b;a.currentTime = c;a.type = "QUEUE_REMOVE";fd(this, this.pb, a);
				};X.prototype.removeQueueItems = X.prototype.hd;
				X.prototype.md = function (a, b, c) {
					b = void 0 == b || b;if (c && !b) throw Error("No broadcast call but status customData has been provided");this.h && (this.h.media = a);b && this.j(!0, null, c);
				};X.prototype.setMediaInformation = X.prototype.md;
				var gd = function gd(a) {
					for (var b = 0; b < a.length; b++) if (!k(a[b].trackId) || !k(a[b].type)) return !1;return !0;
				},
				    hd = function hd(a, b, c) {
					if (!c || 0 === c.length) return !0;if (!b || c.length > b.length) return N(a.a, "Too many track IDs"), !1;for (var d = 0, e = 0, f = 0; f < c.length; f++) {
						for (var l = !1, q = 0; q < b.length; q++) if (c[f] === b[q].trackId) {
							l = !0;break;
						}if (!l) return N(a.a, "Track ID does not exist: " + c[f]), !1;"AUDIO" === b[q].type ? e++ : "VIDEO" === b[q].type && d++;if (1 < e || 1 < d) return N(a.a, "Maximum one active video and one active audio track supported"), !1;
					}return !0;
				},
				    fd = function fd(a, b, c) {
					c.mediaSessionId = a.O;a.tb(new Qb("message", b, c));
				};
				X.prototype.tb = function (a) {
					var b = a.data,
					    c = b.type;if (!this.va || Bc(this.Ma) && "LOAD" == c) {
						a = a.senderId;var d;d = b.type;var e = b.requestId;if (n(e) && e == Math.floor(e)) {
							var f = !1;void 0 != b.mediaSessionId && b.mediaSessionId != this.O ? (N(this.a, "Invalid media session ID: " + b.mediaSessionId + "  does not match the expected ID: " + this.O), f = !0) : "LOAD" != d && "GET_STATUS" != d && "QUEUE_LOAD" != d && (void 0 == b.mediaSessionId ? (N(this.a, "Invalid media session ID, it is undefined"), f = !0) : "IDLE" == id(this) && (N(this.a, "Unexpected command, player is in IDLE state so the media session ID is not valid yet"), f = !0));f ? (this.Ea(a, e, "INVALID_REQUEST", "INVALID_MEDIA_SESSION_ID"), d = !1) : (M(this.a, E, "MediaManager message received"), d = !0);
						} else N(this.a, "Ignoring request, requestId is not an integer: " + e), d = !1;if (d) {
							d = b.requestId;delete b.type;e = null;switch (c) {case "LOAD":
									this.Wa = !1;e = jd(this, a, b, !0);break;case "GET_STATUS":
									O(this.a, "Dispatching MediaManager getStatus event");b = new Y("getstatus", b, a);if (this.onGetStatus) this.onGetStatus(b);this.dispatchEvent(b);e = null;break;case "PLAY":
									O(this.a, "Dispatching MediaManager play event");
									b = new Y("play", b, a);if (this.onPlay) this.onPlay(b);this.dispatchEvent(b);e = null;break;case "SEEK":
									if (void 0 == b.currentTime) N(this.a, "currentTime is mandatory"), e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										O(this.a, "Dispatching MediaManager seek event");b = new Y("seek", b, a);if (this.onSeek) this.onSeek(b);this.dispatchEvent(b);e = null;
									}break;case "STOP":
									O(this.a, "Dispatching MediaManager stop event");b = new Y("stop", b, a);if (this.onStop) this.onStop(b);this.dispatchEvent(b);e = null;break;case "PAUSE":
									O(this.a, "Dispatching MediaManager pause event");b = new Y("pause", b, a);if (this.onPause) this.onPause(b);this.dispatchEvent(b);e = null;break;case "SET_VOLUME":
									if (!b.volume || void 0 == b.volume.level && void 0 == b.volume.muted) N(this.a, "volume is invalid"), e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else if (void 0 != b.volume.level && 0 > b.volume.level || 1 < b.volume.level) N(this.a, "volume level is invalid"), e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										O(this.a, "Dispatching MediaManager setvolume event");b = new Y("setvolume", b, a);if (this.onSetVolume) this.onSetVolume(b);this.dispatchEvent(b);e = null;
									}break;case "EDIT_TRACKS_INFO":
									O(this.a, "Dispatching MediaManager ediTracksInfo event");if (hd(this, this.h.media.tracks, b.activeTrackIds)) {
										c = new Y("edittracksinfo", b, a);b.textTrackStyle && (this.h.media.textTrackStyle = b.textTrackStyle);b.activeTrackIds && (this.B = b.activeTrackIds);if (this.onEditTracksInfo) this.onEditTracksInfo(c);this.dispatchEvent(c);e = null;
									} else N(this.a, "Invalid track IDs"), e = { type: "INVALID_REQUEST",
										reason: "INVALID_PARAMS" };break;case "QUEUE_LOAD":
									this.Wa = !0;O(this.a, "Dispatching MediaManager queueLoad event");c = !1;if (k(b.startIndex) && (!n(b.startIndex) || 0 > b.startIndex)) N(this.a, "Invalid startIndex"), e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										e = (b.startIndex || 0) + 1;if (!b.items || b.items.length < e) N(this.a, "Invalid number of items"), c = !0;else if (b.repeatMode && !Ec(b.repeatMode)) N(this.a, "Invalid repeatMode"), c = !0;else for (e = 0; e < b.items.length; e++) b.items[e].media ? k(b.items[e].itemId) ? (N(this.a, "ItemId is not undefined, element at index: " + e), c = !0) : b.items[e].itemId = this.qb++ : (N(this.a, "Media is mandatory, missing in element at index: " + e), c = !0);if (c) e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
											b.items = kd(b.items);b = new Y("queueload", b, a);if (this.onQueueLoad) this.onQueueLoad(b);this.dispatchEvent(b);e = null;
										}
									}break;case "QUEUE_INSERT":
									this.Wa = !0;O(this.a, "Dispatching MediaManager queueInsert event");c = !1;if (this.f) if (b.items && 0 != b.items.length) if (k(b.currentItemId) && k(b.currentItemIndex)) N(this.a, "Maximum one currentItem must be provided"), c = !0;else if (k(b.currentItemIndex) && (!n(b.currentItemIndex) || 0 > b.currentItemIndex || b.currentItemIndex >= b.items.length)) N(this.a, "Invalid currentItemIndex"), c = !0;else if (k(b.currentItemId) && (!n(b.currentItemId) || 0 > b.currentItemId)) N(this.a, "Invalid currentItemId"), c = !0;else for (e = this.qb++, f = 0; f < b.items.length; f++) if (n(b.items[f].itemId)) {
										N(this.a, "Item contains an itemId at index: " + f);c = !0;break;
									} else b.items[f].itemId = e, e++;else N(this.a, "No items to insert"), c = !0;else N(this.a, "Queue does not exist"), c = !0;if (c) e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										b.items = kd(b.items);b = new Y("queueinsert", b, a);if (this.onQueueInsert) this.onQueueInsert(b);this.dispatchEvent(b);e = null;
									}break;case "QUEUE_UPDATE":
									O(this.a, "Dispatching MediaManager queueUpdate event");c = !1;this.f ? b.items && !ld(this, b.items) ? c = !0 : b.repeatMode && !Ec(b.repeatMode) && (N(this.a, "Invalid repeatMode"), c = !0) : (N(this.a, "Queue does not exist"), c = !0);if (c) e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										if (b.items && 0 < b.items.length) {
											for (var c = this.f, e = b.items, f = [], l = 0; l < e.length; l++) for (var q = 0; q < c.b.length; q++) if (e[l].itemId == c.b[q].itemId) {
												f.push(e[l]);break;
											}b.items = kd(f);
										}b = new Y("queueupdate", b, a);if (this.onQueueUpdate) this.onQueueUpdate(b);this.dispatchEvent(b);e = null;
									}break;case "QUEUE_REMOVE":
									O(this.a, "Dispatching MediaManager queueRemove event");c = !1;this.f ? b.itemIds && 0 != b.itemIds.length ? md(this, b.itemIds) || (c = !0) : (N(this.a, "No itemIds to remove"), c = !0) : (N(this.a, "Queue does not exist"), c = !0);if (c) e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										b.itemIds && (b.itemIds = Gc(this.f, b.itemIds));b = new Y("queueremove", b, a);if (this.onQueueRemove) this.onQueueRemove(b);this.dispatchEvent(b);e = null;
									}break;case "QUEUE_REORDER":
									O(this.a, "Dispatching MediaManager queueReorder event");c = !1;this.f ? b.itemIds && 0 != b.itemIds.length ? md(this, b.itemIds) ? k(b.insertBefore) && 0 <= y(b.itemIds, b.insertBefore) && (N(this.a, "insertBefore can not be one of the reordered items"), c = !0) : c = !0 : (N(this.a, "No itemIds to reorder"), c = !0) : (N(this.a, "Queue does not exist"), c = !0);if (c) e = { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };else {
										b.itemIds && (b.itemIds = Gc(this.f, b.itemIds));b = new Y("queuereorder", b, a);if (this.onQueueReorder) this.onQueueReorder(b);this.dispatchEvent(b);e = null;
									}break;default:
									N(this.a, "Unexpected message type: " + c), e = { type: "INVALID_REQUEST", reason: "INVALID_COMMAND" };}e && (N(this.a, "Sending error: " + e.type + " " + e.reason), this.onLocalRequestError && a == this.pb ? (e.requestId = d, this.onLocalRequestError(e)) : this.Ea(a, d, e.type, e.reason));
						}
					} else this.Ma.enqueue(a);
				};
				var id = function id(a) {
					if (!a.h) return "IDLE";var b = a.g.getState();return "PLAYING" == b && a.N ? "BUFFERING" : b;
				},
				    nd = function nd(a, b, c, d) {
					var e = { type: "MEDIA_STATUS" };if (!a.h && !a.ka) return e.status = [], e;var f = { mediaSessionId: a.O, playbackRate: a.ed, playerState: id(a), currentTime: a.g.getCurrentTimeSec(), supportedMediaCommands: a.td, volume: a.g.getVolume() };a.B && (f.activeTrackIds = a.B);a.Y && (f.preloadedItemId = a.Y);if (a.h) b && (f.media = a.h.media || void 0), f.currentItemId = a.h.itemId;else if ((b && (f.media = a.ka.media || void 0), f.currentItemId = a.ka.itemId, a.ka = null, a.f)) {
						var l = a.f.ia();l && (f.loadingItemId = l.itemId);
					}"IDLE" == f.playerState ? a.U && (f.idleReason = a.U) : a.U = null;void 0 != c && (f.customData = c);a.f && (d && (f.items = a.f.Jb(b)), f.repeatMode = a.f.jb());a.customizedStatusCallback ? (a = a.customizedStatusCallback(f), null == a ? e = null : e.status = [a]) : e.status = [f];return e;
				},
				    od = function od(a) {
					var b = a.g.getCurrentTimeSec();a.la = b;a.Qb = b;a.gc = Date.now();null != a.pa && h.clearTimeout(a.pa);a.pa = Eb(a.Xa, 1E3);
				};
				X.prototype.lc = function () {
					this.pa = Eb(this.Xa, 1E3);var a = id(this);if ("IDLE" != a && "PAUSED" != a) {
						a = this.la;this.la = this.g.getCurrentTimeSec();var b = this.N;this.N = 100 > 1E3 * (this.la - a);if (b != this.N) M(this.a, E, "Buffering state changed, isPlayerBuffering: " + this.N + " old time: " + a + " current time: " + this.la), this.j(!1);else if (!this.N) if ((a = 1E3 * (this.la - this.Qb) - (Date.now() - this.gc), 1E3 < a || -1E3 > a)) M(this.a, E, "Time drifted: " + a), this.j(!1);else if (this.h && this.f && (a = this.f, (a = 0 > a.i ? null : "REPEAT_SINGLE" == a.aa ? a.b[a.i] : a.i + 1 >= a.b.length && (Hc(a) || "REPEAT_OFF" == a.aa) ? null : a.b[(a.i + 1) % a.b.length]) && n(a.preloadTime) && this.h.media && !this.m && pd(this, a.preloadTime) && this.Y != a.itemId)) if (this.onPreload) {
							var c;c = new Wc(a.itemId);c.requestId = 0;c.mediaSessionId = this.O;c.autoplay = a.autoplay;c.currentTime = a.startTime;c.customData = a.customData || null;c.activeTrackIds = a.activeTrackIds;c.media = a.media;c = new Y("preload", c, "");this.Y = a.itemId;O(this.a, "Sending preload event: " + JSON.stringify(c));this.onPreload(c) && this.j(!1);
						} else O(this.a, "Not sending preload event: " + JSON.stringify(c));
					}
				};X.prototype.j = function (a, b, c, d) {
					if (this.g) {
						if ((M(this.a, E, "Sending broadcast status message"), a = nd(this, a, c, d), null != a)) {
							if (this.onMediaStatus && a.status) this.onMediaStatus(a.status[0] || null);a.requestId = b || 0;this.Na.Eb(a);od(this);
						}
					} else N(this.a, "Not sending broadcast status message, state is invalid");
				};X.prototype.broadcastStatus = X.prototype.j;X.prototype.kd = function (a) {
					M(this.a, E, "Setting IDLE reason: " + a);this.U = a;
				};X.prototype.setIdleReason = X.prototype.kd;
				X.prototype.Ea = function (a, b, c, d, e) {
					O(this.a, "Sending error message to " + a);var f = {};f.requestId = b;f.type = c;d && (f.reason = d);e && (f.customData = e);this.Na.send(a, f);
				};X.prototype.sendError = X.prototype.Ea;
				X.prototype.ac = function (a, b, c, d, e) {
					if (this.g) {
						if ((M(this.a, E, "Sending status message to " + a), c = nd(this, c, d, e), null != c)) {
							if (this.onMediaStatus && c.status) this.onMediaStatus(c.status[0] || null);c.requestId = b;this.Na.send(a, c);od(this);
						}
					} else N(this.a, "State is invalid"), this.Ea(a, b, "INVALID_PLAYER_STATE", null, d);
				};X.prototype.sendStatus = X.prototype.ac;X.prototype.oc = function (a) {
					return a;
				};
				var qd = function qd(a) {
					a.m = null;if (a.va) for (a.va = !1; !Bc(a.Ma) && !a.va;) a.tb(Ac(a.Ma));
				},
				    jd = function jd(a, b, c, d, e) {
					O(a.a, "Dispatching MediaManager load event");O(a.a, "Load message received:" + JSON.stringify(c));var f = !1;c.media ? c.media.tracks && !gd(c.media.tracks) ? (N(a.a, "Invalid tracks information"), f = !0) : c.activeTrackIds && !hd(a, c.media.tracks, c.activeTrackIds) && (f = !0) : (N(a.a, "Media is mandatory"), f = !0);if (f) return { type: "INVALID_REQUEST", reason: "INVALID_PARAMS" };a.m ? a.Ab("LOAD_CANCELLED") : a.h && a.ba("INTERRUPTED");
					a.m = { senderId: b, message: c };a.B = c.activeTrackIds || null;a.va = !0;d && (a.O++, e ? a.f = e : (d = new Fc(a.qb++), d.media = c.media, d.autoplay = c.autoplay, d.activeTrackIds = c.activeTrackIds, d.customData = c.customData, a.f = new V([d], "REPEAT_OFF", 0)));a.h = a.f && a.f.ia();a.La && a.g.Vb && a.g.Vb(k(c.autoplay) ? c.autoplay : !0, 0 < c.currentTime ? c.currentTime : 0, a.h.playbackDuration, a.h.startTime);b = new Y("load", c, b);if (a.onLoad) a.onLoad(b);a.dispatchEvent(b);return a.Y = null;
				};
				X.prototype.vc = function (a) {
					a = a.data;if (a.media && a.media.contentId) {
						var b = void 0 === a.autoplay ? !0 : a.autoplay;a.media.tracks ? this.g.load(a.media.contentId, b, a.currentTime, { tracks: a.media.tracks, activeTrackIds: a.activeTrackIds, textTrackStyle: a.media.textTrackStyle }) : this.g.load(a.media.contentId, b, a.currentTime);
					}
				};
				X.prototype.Zc = function (a) {
					if (!this.m) return !1;a.tracks = a.tracks || void 0;if (a.tracks && !gd(a.tracks)) return N(this.a, "Invalid tracks information"), !1;if (a.activeTrackIds && !hd(this, a.tracks, a.activeTrackIds)) return N(this.a, "Invalid active tracks"), !1;this.B = a.activeTrackIds || null;if (this.f) {
						var b = this.f.ia();b && b.media && (b.media.tracks = a.tracks, b.media.textTrackStyle = a.textTrackStyle || void 0);
					}this.g.load("", !1, void 0, a, !0);return !0;
				};X.prototype.loadTracksInfo = X.prototype.Zc;
				X.prototype.dc = function (a) {
					a !== this.g && (this.g && (this.g.unregisterErrorCallback(), this.g.unregisterEndedCallback(), this.g.unregisterLoadCallback()), this.g = (this.La = a.getState ? !1 : !0) ? new mc(this.a, a) : a, this.g.registerErrorCallback(this.rb.bind(this)), this.g.registerEndedCallback(this.Pa.bind(this)), this.g.registerLoadCallback(this.wb.bind(this)));
				};X.prototype.setMediaElement = X.prototype.dc;
				X.prototype.wb = function () {
					if (this.m) if ((O(this.a, "Metadata loaded"), this.h && this.h.media && (this.h.media.duration = this.g.getDurationSec()), this.N = !0, this.onMetadataLoaded)) this.onMetadataLoaded(this.m);else qd(this);
				};X.prototype.wc = function (a) {
					this.La && a.message && void 0 != a.message.currentTime && a.message.currentTime != this.g.getCurrentTimeSec() && this.g.seek(a.message.currentTime);this.$b();
				};
				X.prototype.rb = function (a) {
					if (this.m) if ((N(this.a, "Load metadata error: " + a), this.onLoadMetadataError)) this.onLoadMetadataError(this.m);else qd(this);else if (this.onError) this.onError(a);
				};X.prototype.Ab = function (a, b) {
					this.m ? (this.Ea(this.m.senderId, this.m.message.requestId, a || "LOAD_FAILED", null, b), qd(this)) : N(this.a, "Not sending LOAD error as there is no on going LOAD request");
				};X.prototype.sendLoadError = X.prototype.Ab;
				X.prototype.$b = function (a) {
					if (this.m) {
						var b = this.m.message.requestId;this.j(!0, b, a, 0 != b);qd(this);
					} else N(this.a, "Not sending status as there is no on going LOAD request");
				};X.prototype.sendLoadComplete = X.prototype.$b;g = X.prototype;g.sc = function () {
					this.ba("ERROR");
				};g.uc = function () {
					this.m && "" == this.m.senderId && this.m.message && 0 == this.m.message.requestId ? this.ba("ERROR", !0) : (this.ba("ERROR", !1), this.Ab("LOAD_FAILED"));
				};g.Pa = function () {
					if (this.onEnded) this.onEnded();
				};
				g.rc = function () {
					if (this.f) {
						var a = -1 != this.Ta ? this.Ta : void 0;this.Ta = -1;rd(this, "REPEAT_SINGLE" == this.f.jb() ? 0 : 1, !1, a, void 0, void 0, void 0, "FINISHED");
					}
				};g.zc = function (a, b) {
					this.ba(a, !0, b);
				};
				var rd = function rd(a, b, c, d, e, f, l, q) {
					q = q || "INTERRUPTED";if (a.f && "QUEUE_ENDED" != Mc(a.f, b, !1)) {
						var u = Mc(a.f, b, !0);O(a.a, "After " + b + " jump, transition is: " + u);if (b = sd(a, a.f.ia(), void 0, l)) {
							if (a.h && (a.B = null, a.U = q, a.ka = a.h, a.h = null, "QUEUE_SHUFFLED" == u && (f = !0), a.j(c, d, e, f), "INTERRUPTED" == a.U)) a.onAbort();jd(a, "", b, !1);
						} else if (a.onQueueEnded) a.onQueueEnded(q, d);
					} else if (a.onQueueEnded) a.onQueueEnded(q, d);
				};g = X.prototype;
				g.tc = function (a) {
					M(this.a, E, "onGetStatus");var b = a.data;M(this.a, E, "onGetStatus: " + JSON.stringify(b));var c = !0,
					    d = !0;b.options && (b.options & 1 && (c = !1), b.options & 1 && (d = !1));this.ac(a.senderId, a.data.requestId, c, null, d);
				};g.yc = function (a) {
					M(this.a, E, "onPlay");this.g.play();this.j(!1, a.data.requestId);
				};
				g.Fc = function (a) {
					a = a.data;M(this.a, E, "onSeek: " + JSON.stringify(a));this.g.seek(a.currentTime, a.resumeState);"PAUSED" != this.g.getState() && (this.N = !0);this.g.getCurrentTimeSec() < this.g.getDurationSec() ? this.j(!1, a.requestId) : this.Ta = a.requestId;
				};g.Hc = function (a) {
					this.ba("CANCELLED", !0, a.data.requestId);
				};
				g.ba = function (a, b, c, d) {
					b = void 0 == b || b;if ((d || c) && !b) throw Error("customData and requestId should only be provided in broadcast mode");this.h ? (this.f = null, this.g.reset(), this.B = null, a && (this.U = a), this.ka = this.h, this.h = null, b && this.j(!1, c, d, void 0)) : O(this.a, "Nothing to reset, Media is already null");if (a && "INTERRUPTED" == a) this.onAbort();
				};X.prototype.resetMediaElement = X.prototype.ba;X.prototype.xc = function (a) {
					this.g.pause();this.j(!1, a.data.requestId);
				};
				X.prototype.Gc = function (a) {
					a = a.data;this.g.setVolume(a.volume);this.j(!1, a.requestId);
				};X.prototype.qc = function (a) {
					a = a.data;var b = { activeTrackIds: a.activeTrackIds, textTrackStyle: a.textTrackStyle };this.g.editTracksInfo && this.g.editTracksInfo(b);this.j(a.textTrackStyle ? !0 : !1, a.requestId);
				};
				var md = function md(a, b) {
					if (2 > b.length) return !0;for (var c = 0; c < b.length; c++) for (var d = c + 1; d < b.length; d++) if (b[c] == b[d]) return N(a.a, "Duplicate itemId: " + b[c] + "at positions:" + c + " " + d), !1;return !0;
				},
				    ld = function ld(a, b) {
					for (var c = 0; c < b.length; c++) {
						if (!n(b[c].itemId)) return N(a.a, "Invalid itemId at position: " + c), !1;for (var d = c + 1; d < b.length; d++) {
							if (!n(b[d].itemId)) return N(a.a, "Invalid itemId at position: " + d), !1;if (b[c].itemId == b[d].itemId) return N(a.a, "Duplicate itemId: " + b[c].itemId + "at positions:" + c + " " + d), !1;
						}
					}return !0;
				},
				    kd = function kd(a) {
					for (var b = [], c = 0; c < a.length; c++) {
						var d = new Fc(a[c].itemId);d.media = a[c].media;d.autoplay = a[c].autoplay;d.startTime = a[c].startTime;d.playbackDuration = a[c].playbackDuration;d.preloadTime = a[c].preloadTime;d.activeTrackIds = a[c].activeTrackIds;d.customData = a[c].customData;b.push(d);
					}return b;
				},
				    sd = function sd(a, b, c, d) {
					if (!b) return null;var e = new Vc();e.requestId = c || 0;e.mediaSessionId = a.O;e.type = "LOAD";e.autoplay = b.autoplay;e.currentTime = k(d) ? d : b.startTime;e.activeTrackIds = b.activeTrackIds;
					e.customData = b.customData || null;e.media = b.media;return e;
				},
				    pd = function pd(a, b) {
					if (a.h.media.duration - a.g.getCurrentTimeSec() <= b) return !0;if (null == a.Y) return !1;a.Y = null;if (!a.onCancelPreload) return !1;var c;c = new Z();c.requestId = 0;c.mediaSessionId = a.O;c = new Y("cancelpreload", c, "");O(a.a, "Sending cancel preload event: " + JSON.stringify(c));a.onCancelPreload(c) && a.j(!1);return !1;
				};g = X.prototype;
				g.Bc = function (a) {
					var b = a.data,
					    c = new V(b.items, b.repeatMode || "REPEAT_OFF", b.startIndex || 0);(b = sd(this, c.ia(), b.requestId, b.currentTime)) ? jd(this, a.senderId, b, !0, c) : N(this.a, "Queue Load request is invalid");
				};
				g.Ac = function (a) {
					a = a.data;O(this.a, "Queue insert data: " + JSON.stringify(a));var b = !1;k(a.currentItemId) && (b = Kc(this.f, a.currentItemId));k(a.currentItemIndex) && (b = !0);var c = this.f,
					    d = a.items,
					    e = a.insertBefore,
					    f = a.currentItemIndex,
					    e = n(e) ? Ic(c, e) : c.b.length,
					    e = -1 == e ? c.b.length : e;ea(ta, c.b, e, 0).apply(null, d);k(f) ? c.i = e + f : c.i >= e && (c.i += d.length);b ? rd(this, 0, !0, a.requestId, a.customData, !0, a.currentTime) : this.j(!0, a.requestId, a.customData, !0);
				};
				g.Ec = function (a) {
					a = a.data;if (this.Wa) {
						O(this.a, "Queue update data: " + JSON.stringify(a));var b = !1,
						    c = !1;n(a.currentItemId) && (c = Kc(this.f, a.currentItemId));n(a.jump) && (c = !0);a.repeatMode && (this.f.aa = a.repeatMode);if (a.items && 0 < a.items.length) {
							for (var b = this.f, d = a.items, e = 0; e < d.length; e++) for (var f = 0; f < b.b.length; f++) d[e].itemId == b.b[f].itemId && (b.b[f] = d[e]);b = !0;
						}c ? rd(this, a.jump || 0, b, a.requestId, a.customData, b, a.currentTime) : this.j(b, a.requestId, a.customData, b);
					} else O(this.a, "QUEUE_UPDATE request ignored"), this.j(!1, a.requestId);
				};
				g.Cc = function (a) {
					a = a.data;O(this.a, "Queue remove data: " + JSON.stringify(a));var b = !1;n(a.currentItemId) && (b = Kc(this.f, a.currentItemId));if (a.itemIds && 0 != a.itemIds.length) {
						if (!b) {
							for (var b = this.f, c = a.itemIds, d = !1, e = 0; e < c.length; e++) for (var f = 0; f < b.b.length; f++) if (c[e] == b.b[f].itemId) {
								b.b.splice(f, 1);b.i == f ? d = !0 : b.i > f && b.i--;break;
							}b.i >= b.b.length && (b.i = Jc(b) ? 0 : -1, Hc(b) && 0 == b.i && Lc(b));b = d;
						}b ? rd(this, 0, !1, a.requestId, a.customData, !0, a.currentTime) : this.j(!1, a.requestId, a.customData, !0);
					} else N(this.a, "No itemIds to remove");
				};
				g.Dc = function (a) {
					a = a.data;O(this.a, "Queue reorder data: " + JSON.stringify(a));var b = !1,
					    c = !1;n(a.currentItemId) && (c = Kc(this.f, a.currentItemId));if (a.itemIds && 0 < a.itemIds.length) {
						var b = this.f,
						    d = a.itemIds,
						    e = a.insertBefore;if (d && 0 != d.length) {
							for (var f = b.b[b.i].itemId, l = k(e) ? e : -1, e = b.b.length - d.length, q = [], u = -1 == l ? !0 : !1, H = 0; H < b.b.length; H++) 0 <= y(d, b.b[H].itemId) ? u || b.b[H].itemId != d[0] || (e = q.length) : (q.push(b.b[H]), l == b.b[H].itemId && (e = q.length - 1, u = !0));l = [];for (u = 0; u < d.length; u++) {
								a: {
									for (H = 0; H < b.b.length; H++) if (d[u] == b.b[H].itemId) {
										H = b.b[H];break a;
									}H = null;
								}l.push(H);
							}ea(ta, q, e, 0).apply(null, l);b.b = q;k(f) && Kc(b, f);
						}b = !0;
					}c ? rd(this, 0, !1, a.requestId, a.customData, b, a.currentTime) : this.j(!1, a.requestId, a.customData, b);
				};g.l = function () {
					X.D.l.call(this);M(this.a, E, "Disposed " + this.J());
				};
			}).call(window);

			cast.receiver.logger.setLevelValue(cast.receiver.LoggerLevel.WARNING);

			_export("default", cast.receiver.CastReceiverManager.getInstance());
		}
	};
});
$__System.register('15c', [], function (_export) {
  'use strict';

  var APP_ID, NS, DEBUG_NS, APP_READY, APP_UNSUPPORTED;
  return {
    setters: [],
    execute: function () {
      APP_ID = 'EE0F2C13';

      _export('APP_ID', APP_ID);

      NS = 'urn:x-cast:com.toyota.cast.chr';

      _export('NS', NS);

      DEBUG_NS = 'urn:x-cast:com.toyota.cast.chr.debug';

      _export('DEBUG_NS', DEBUG_NS);

      APP_READY = "Application status is ready...";

      _export('APP_READY', APP_READY);

      APP_UNSUPPORTED = "Device is not supported";

      _export('APP_UNSUPPORTED', APP_UNSUPPORTED);
    }
  };
});
$__System.register("1", ["10", "f8", "d", "15a", "15b", "15c"], function (_export) {
	var TweenMax, _Object$assign, howl, Artwork, castReceiverManager, NS, APP_READY, APP_UNSUPPORTED, DEBUG_NS, canvas, artwork, hardwareSupportsApplication, messageBus, messageDebugBus;

	function resizeCanvasCss(dimension) {
		_Object$assign(canvas.style, dimension);
	}

	// initialize the CastReceiverManager with an application status message
	return {
		setters: [function (_2) {
			TweenMax = _2.TweenMax;
		}, function (_f8) {
			_Object$assign = _f8["default"];
		}, function (_d) {
			howl = _d["default"];
		}, function (_a) {
			Artwork = _a["default"];
		}, function (_b) {
			castReceiverManager = _b["default"];
		}, function (_c) {
			NS = _c.NS;
			APP_READY = _c.APP_READY;
			APP_UNSUPPORTED = _c.APP_UNSUPPORTED;
			DEBUG_NS = _c.DEBUG_NS;
		}],
		execute: function () {
			"use strict";

			canvas = document.createElement("canvas");

			document.querySelector("#main").appendChild(canvas);

			artwork = undefined;

			// Add a resize handler

			// Start

			hardwareSupportsApplication = Artwork.isSupported;

			console.log('Starting Receiver Manager');

			// handler for the 'ready' event
			castReceiverManager.onReady = function (event) {
				console.log('Received Ready event: ' + JSON.stringify(event.data));

				if (Artwork.isSupported) {

					_Object$assign(canvas.style, {
						width: '100%',
						height: '32%',
						position: 'absolute',
						top: '34%'
					});

					var artOpts = {
						useTextureNoise: false,
						fov: 20,
						timeScale: 0.9,
						viewOffset: [-400, 0]
					};

					artwork = new Artwork(canvas, './jspm_packages/github/marklundin/toyota2@gh-pages/', artOpts);
					window.addEventListener("resize", function (_) {
						return artwork.resize(canvas.offsetWidth, canvas.offsetHeight);
					});
					artwork.start();
					artwork.resize(window.innerWidth, window.innerWidth);
				}

				castReceiverManager.setApplicationState(Artwork.isSupported ? APP_READY : APP_UNSUPPORTED);
			};

			// handler for 'senderconnected' event
			castReceiverManager.onSenderConnected = function (event) {
				console.log('Received Sender Connected event: ' + event.data);
				console.log(castReceiverManager.getSender(event.data).userAgent);
			};

			// handler for 'senderdisconnected' event
			castReceiverManager.onSenderDisconnected = function (event) {
				console.log('Received Sender Disconnected event: ' + event.data);
				// if (castReceiverManager.getSenders().length == 0 && ) {
				// 	window.close();
				// }
			};

			// handler for 'systemvolumechanged' event
			castReceiverManager.onSystemVolumeChanged = function (event) {
				console.log('Received System Volume Changed event: ' + event.data['level'] + ' ' + event.data['muted']);
			};

			// create a CastMessageBus to handle messages for a custom namespace
			messageBus = castReceiverManager.getCastMessageBus(NS);

			// handler for the CastMessageBus message event
			messageBus.onMessage = function (event) {

				var logMessage = 'Message [' + event.senderId + ']: ' + event.data;

				console.log(logMessage);
				// display the message from the sender
				// displayText(event.data);
				artwork.app.changeSceneByName(event.data);

				// inform all senders on the CastMessageBus of the incoming message event
				// sender message listener will be invoked
				messageBus.send(event.senderId, logMessage);
			};

			// DEBUG MESSAGIN
			messageDebugBus = castReceiverManager.getCastMessageBus(DEBUG_NS);

			messageDebugBus.onMessage = function (event) {

				switch (event.data.command) {

					case 'resize-canvas-css':
						resizeCanvasCss(event.data.value);
						break;
					case 'terminate':
						castReceiverManager.stop();
						break;
					case 'reload':
						location.reload(event.data.value);
						break;
					default:
						break;
				}
			};castReceiverManager.start({ statusText: "Application is starting" });
			// console.log('Receiver Manager started');

			// utility function to display the text message in the input field
			//let displayText = text => document.getElementById( "message" ).innerHTML = text
		}
	};
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=main-receiver.min.js.map